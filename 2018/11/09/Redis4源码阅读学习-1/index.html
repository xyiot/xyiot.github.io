<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="c，数据库，缓存，redis,">





  <link rel="alternate" href="/atom.xml" title="三余无梦生" type="application/atom+xml">






<meta name="description" content="zmalloc.ctcmallocjemalloc1234567891011121314151617181920212223/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/void *zmalloc(size_t size) &amp;#123;    void *ptr = malloc(size+PREFIX">
<meta name="keywords" content="c，数据库，缓存，redis">
<meta property="og:type" content="article">
<meta property="og:title" content="redis4源码阅读学习-1">
<meta property="og:url" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/index.html">
<meta property="og:site_name" content="三余无梦生">
<meta property="og:description" content="zmalloc.ctcmallocjemalloc1234567891011121314151617181920212223/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/void *zmalloc(size_t size) &amp;#123;    void *ptr = malloc(size+PREFIX">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/5.png">
<meta property="og:image" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/1.png">
<meta property="og:image" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/2.png">
<meta property="og:image" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/3.jpeg">
<meta property="og:image" content="https://img-blog.csdn.net/20160503161237360">
<meta property="og:image" content="https://img-blog.csdn.net/20160503161309698">
<meta property="og:updated_time" content="2019-04-09T11:29:36.284Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="redis4源码阅读学习-1">
<meta name="twitter:description" content="zmalloc.ctcmallocjemalloc1234567891011121314151617181920212223/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/void *zmalloc(size_t size) &amp;#123;    void *ptr = malloc(size+PREFIX">
<meta name="twitter:image" content="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/5.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/">





  <title>redis4源码阅读学习-1 | 三余无梦生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三余无梦生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">redis4源码阅读学习-1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T18:02:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方源码库/" itemprop="url" rel="index">
                    <span itemprop="name">第三方源码库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h2><h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">tcmalloc</a></h2><h2 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a><a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure>
<h3 id="详情可以参考GCC官方文档链接"><a href="#详情可以参考GCC官方文档链接" class="headerlink" title="详情可以参考GCC官方文档链接"></a>详情可以参考GCC官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">链接</a></h3><ol>
<li>分配内存大小为size+PREFIX_SIZE的大小，zmalloc实际分配比需要多一些的内存，这一部分用于存储size信息。</li>
<li>zmalloc_oom_handler用来处理内存申请异常</li>
<li>(_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); = if(_n&amp;7) _n += 8 - (_n&amp;7);  32位4字节对齐，64位下8字节对齐</li>
</ol>
<h1 id="数据结构：objcet"><a href="#数据结构：objcet" class="headerlink" title="数据结构：objcet"></a>数据结构：objcet</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time).  </span></span><br><span class="line"><span class="comment">              16 bits      8 bits</span></span><br><span class="line"><span class="comment">      +------------------+--------+</span></span><br><span class="line"><span class="comment">      + Last access time | LOG_C  |</span></span><br><span class="line"><span class="comment">      +------------------+--------+*/</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">//通过引用计数的方式来管理内存，c++11，oc</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指向具体实现的具体区域和数据结构</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type字段表示数据类型，有以下几种定义：</span><br><span class="line">OBJ_STRING   <span class="comment">// 字符串</span></span><br><span class="line">OBJ_LIST  <span class="comment">// 链表</span></span><br><span class="line">OBJ_SET  <span class="comment">// 集合</span></span><br><span class="line">OBJ_ZSET  <span class="comment">// 有序集合</span></span><br><span class="line">OBJ_HASH  <span class="comment">// HASH结构（注意，此处不同于传统意义上的哈希表（如stl::hash_map），这里的hash仅有字段散列的语义）</span></span><br><span class="line">REDIS_VMPOINTER  <span class="comment">// VM指针，已经废弃，翻看了一下VM相关实现和历史</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Redis采用VM机制是希望把存储做成如同Oracle一样的方式，具备自动淘汰冷热数据功能，但是，它采用了RDB文件和VM机制来分别实现二进制存储、冷热淘汰的功能，期望是既节约内存又达到完美性能的地步</span></span><br><span class="line"><span class="comment">redis之所以高性能最本质的原因是数据都cache到内存里。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encoding则对应了 Redis 中的10种编码方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:right">一般情况</th>
<th style="text-align:center">少量情况</th>
<th style="text-align:right">特殊情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td style="text-align:right">RAW</td>
<td style="text-align:center">EMBSTR</td>
<td style="text-align:right">INT</td>
</tr>
<tr>
<td>LIST</td>
<td style="text-align:right">LINKEDLIST</td>
<td style="text-align:center">ZIPLIST</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>HASH</td>
<td style="text-align:right">HT</td>
<td style="text-align:center">ZIPLIST</td>
</tr>
</tbody>
</table>
<h3 id="refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"><a href="#refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较" class="headerlink" title="refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"></a>refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的<a href="https://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">引用计数与垃圾收集之比较</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objcet.c基本上就是提供了一堆对象操作，初始化等相关的api接口</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>&#123; <span class="comment">/* 最初的创建robj对象方法，后面的创建方法与此类似 */</span>	</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">        <span class="comment">//lru lfu算法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK(); <span class="comment">//都记录下该对象的LRU时钟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//正常释放</span></span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);<span class="comment">//异常</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法"><a href="#Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法" class="headerlink" title="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法"></a>Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法</h2><ol>
<li>引用计数  refcount</li>
<li>lru （Least Recently Used）//最长时间未被使用<br><img src="/2018/11/09/Redis4源码阅读学习-1/5.png" alt="Image text"></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) = 2^24 - 1 单位毫秒 /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000  <span class="comment">//代表LRU算法的精度，即一个LRU的单位是多长时间，1秒</span></span></span><br><span class="line"><span class="comment">//LRU时钟的时间粒度高于serverCron刷新的时间粒度，那么就主动获取最新的时间，否则使用server缓存的时间</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">    <span class="comment">//如果定时器执行的频率高于LRU算法的精度时，可以直接将server.lruclock直接在对象创建时赋值过去，避免了函数调用的内存开销以及时间开销</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.........</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lruclock = getLRUClock();</span><br><span class="line">    atomicSet(server.lruclock,lruclock);</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数据的空闲时间</span></span><br><span class="line">evictionPoolPopulate-&gt;estimateObjectIdleTime-&gt;LRU_CLOCK</span><br><span class="line">objectCommand(idletime) -&gt; estimateObjectIdleTime</span><br></pre></td></tr></table></figure>
<p>3.LFU（Least Frequently Used） 最不常用页面置换算法，基于LFU的热点key发现机制  4.0<br>counter：基于概率的对数计数器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX; <span class="comment">//RAND_MAX c语言宏，rand最大上限值</span></span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">//LFU_INIT_VAL = 5</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//默认server.lfu_log_factor=10，概率因子</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++;   <span class="comment">//baseval增加后，p&lt;r的概率非线形增长</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span><span class="comment">//从db-&gt;dict字典中获取key的val，并更新val的lru/lfu</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/09/Redis4源码阅读学习-1/1.png" alt="Image text"></p>
<h3 id="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"><a href="#counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万" class="headerlink" title="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"></a>counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万</h3><h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span> 概率因子</span><br><span class="line">lfu-decay-time <span class="number">1</span>  每分钟衰减<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新对象的访问时间和计数器值,减少，每分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">//获取lru时间  分钟   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//获取使用频次</span></span><br><span class="line">    <span class="comment">//时间超过了lfu_decay_time的话，那么将使用频次减少</span></span><br><span class="line">    <span class="keyword">if</span> (LFUTimeElapsed(ldt) &gt;= server.lfu_decay_time &amp;&amp; counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; LFU_INIT_VAL*<span class="number">2</span>) &#123;</span><br><span class="line">            counter /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; LFU_INIT_VAL*<span class="number">2</span>) counter = LFU_INIT_VAL*<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新时间和频次</span></span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次访问该数据对象已经过去了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前的分钟计数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="redis内存达到上限后的释放内存原则"><a href="#redis内存达到上限后的释放内存原则" class="headerlink" title="redis内存达到上限后的释放内存原则"></a>redis内存达到上限后的释放内存原则</h3><ol>
<li>释放内存的标准是释放之后使用内存的大小小于maxmemory的大小</li>
<li>每次释放的数量，redis.conf配置</li>
<li>超过限制后redis策略</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis.conf配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-lru -&gt; 从设置了过期时间的键中选择空转时间最长的键值对清除掉</span><br><span class="line"><span class="keyword">volatile</span>-lfu -&gt; 从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</span><br><span class="line"><span class="keyword">volatile</span>-random -&gt; 从设置了过期时间的键中，随机选择键进行清除.</span><br><span class="line"></span><br><span class="line">allkeys-lru -&gt; 从所有的键中选择空转时间最长的键值对清除</span><br><span class="line">allkeys-lfu -&gt; 从所有的键中选择某段时间之内使用频次最少的键值对清除.</span><br><span class="line">allkeys-random -&gt; 从所有的key中随机删除</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-ttl -&gt; 从已设置过期时间的数据集合中挑选即将过期的数据淘汰</span><br><span class="line">noeviction -&gt;不做任何的清理工作，禁止写入，报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The <span class="keyword">default</span> of <span class="number">5</span> produces good enough results. <span class="number">10</span> Approximates very closely</span><br><span class="line"><span class="meta"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line">#</span><br><span class="line"><span class="meta"># maxmemory-samples 5 lru，lfu每次采样数，5最佳</span></span><br></pre></td></tr></table></figure>
<h1 id="如何筛选释放的key"><a href="#如何筛选释放的key" class="headerlink" title="如何筛选释放的key"></a>如何筛选释放的key</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16 <span class="comment">//存储待释放的键相关信息的存储空间能够容纳的键的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255 <span class="comment">//cached中的最大的键的长度    512mb</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span> <span class="comment">//存储待释放的键所在内存的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化EvictionPoolLRU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolAlloc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    ep = zmalloc(<span class="keyword">sizeof</span>(*ep)*EVPOOL_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; EVPOOL_SIZE; j++) &#123;</span><br><span class="line">        ep[j].idle = <span class="number">0</span>;</span><br><span class="line">        ep[j].key = <span class="literal">NULL</span>;</span><br><span class="line">        ep[j].cached = sdsnewlen(<span class="literal">NULL</span>,EVPOOL_CACHED_SDS_SIZE);</span><br><span class="line">        ep[j].dbid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EvictionPoolLRU = ep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"><a href="#根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中" class="headerlink" title="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"></a>根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从sampledict中最多选取server.maxmemory_samples个指向sampledict的指针存放在放入到samples中,</span></span><br><span class="line">	<span class="comment">//server.maxmemory_samples配置5</span></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment">         * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment">         * again in the key dictionary to obtain the value object. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果maxmemory_policy为MAXMEMORY_VOLATILE_TTL，证明需要将距离过期时间最近的键清除掉;那么直接从redisDB-&gt;expire对应的字典中获取键对应的过期时间值即可，此时不需要改变已经存在的de。</span></span><br><span class="line">   <span class="comment">//如果maxmemory_policy != MAXMEMORY_VOLATILE_TTL且不是从redisDB-&gt;dict中获取键的值(使用redisDB-&gt;expire中获取的键),</span></span><br><span class="line">  那么需要从redisDB-&gt;dict中获取键对应的值的对象，才能够获取lru字段 </span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//lru，lfu，ttl 统一用idle来衡量</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            <span class="comment">/* When we use an LRU policy, we sort the keys by idle time</span></span><br><span class="line"><span class="comment">             * so that we expire keys starting from greater idle time.</span></span><br><span class="line"><span class="comment">             * However when the policy is an LFU one, we have a frequency</span></span><br><span class="line"><span class="comment">             * estimation, and we want to evict keys with lower frequency</span></span><br><span class="line"><span class="comment">             * first. So inside the pool we put objects using the inverted</span></span><br><span class="line"><span class="comment">             * frequency subtracting the actual frequency to the maximum</span></span><br><span class="line"><span class="comment">             * frequency of 255. */</span></span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o); <span class="comment">//LFUDecrAndReturn返回 counter</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">         </span><br><span class="line">  		<span class="comment">//EvictionPoolLRU中的元素全部按照元素对应的idle值按照从小到大的顺序</span></span><br><span class="line"> 	   <span class="comment">//idle越大，位置越靠后，当然也就最先被清除掉。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找元素的插入位置</span></span><br><span class="line">        <span class="comment">//pool中所有的元素都不为空，且其中元素的最小的idle大于等于idle</span></span><br><span class="line">        <span class="comment">//EVPOOL_SIZE 16</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">               <span class="comment">//满了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to reuse the cached SDS string allocated in the pool entry,</span></span><br><span class="line"><span class="comment">         * because allocating and deallocating this object is costly</span></span><br><span class="line"><span class="comment">         * (according to the profiler, not my fantasy. Remember:</span></span><br><span class="line"><span class="comment">         * premature optimizbla bla bla bla. */</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用"><a href="#统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用" class="headerlink" title="统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用"></a>统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment"> * count of used memory. */</span></span><br><span class="line">mem_used = mem_reported;</span><br><span class="line"><span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure>
<h3 id="内存管理策略的入口函数—freeMemoryIfNeeded"><a href="#内存管理策略的入口函数—freeMemoryIfNeeded" class="headerlink" title="内存管理策略的入口函数—freeMemoryIfNeeded()"></a>内存管理策略的入口函数—freeMemoryIfNeeded()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">     <span class="comment">//在阻塞状态，并且阻塞时间未到，应该是和阻塞状态有关</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">     <span class="comment">// 如果没有超过限制，那么没必要进行内存的清理工作</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (mem_reported &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    <span class="comment">// 排查aof，slaves</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">     <span class="comment">//在进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//默认情况，不搞了</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i, keys_freed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">          <span class="comment">//如果策略是TTL，设置了过期时间的LRU，LRU</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">     </span><br><span class="line">                <span class="comment">//针对server中的所有db中选出最佳的可以被淘汰的键进行淘汰 </span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">//从EvctionPoolLRU中的最后一个元素(idle值最大）开始释放内存</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line">					<span class="comment">//如果是allkeys开头的删除策略，从dict字典中获取对象; 否则从expire字典中获取对象</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">//获取了bestid和de，释放EvctionPoolLRU里面key对应的内存</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="comment">//如果使用random相关的空间管理策略，则直接随机从dict或者expire中获取一个键进行删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">             <span class="comment">//每次选不同db的一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="comment">//最终删除选择的bestkey</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            <span class="comment">/* We compute the amount of memory freed by db*Delete() alone.</span></span><br><span class="line"><span class="comment">             * It is possible that actually the memory needed to propagate</span></span><br><span class="line"><span class="comment">             * the DEL in AOF and replication link is greater than the one</span></span><br><span class="line"><span class="comment">             * we are freeing removing the key, but we can't account for</span></span><br><span class="line"><span class="comment">             * that otherwise we would never exit the loop.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * AOF and Output buffer memory will be freed eventually so</span></span><br><span class="line"><span class="comment">             * we only care about memory used by the key space. */</span></span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">             * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">             * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">             * transmission here inside the loop. */</span></span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally our stop condition is the ability to release</span></span><br><span class="line"><span class="comment">             * a fixed, pre-computed amount of memory. However when we</span></span><br><span class="line"><span class="comment">             * are deleting objects in another thread, it's better to</span></span><br><span class="line"><span class="comment">             * check, from time to time, if we already reached our target</span></span><br><span class="line"><span class="comment">             * memory, since the "mem_freed" amount is computed only</span></span><br><span class="line"><span class="comment">             * across the dbAsyncDelete() call, while the thread can</span></span><br><span class="line"><span class="comment">             * release the memory all the time. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">                mem_used = zmalloc_used_memory();</span><br><span class="line">                mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) &#123;</span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keys_freed) &#123;</span><br><span class="line">            latencyEndMonitor(latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;= mem_tofree)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ol>
<li>淘汰算法的优化，更有效的需要淘汰的key</li>
<li>算法对性能，内存的影响</li>
</ol>
<h2 id="过期key删除策略"><a href="#过期key删除策略" class="headerlink" title="过期key删除策略"></a>过期key删除策略</h2><h3 id="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"><a href="#惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；" class="headerlink" title="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"></a>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">//获取过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">     <span class="comment">//执行lua脚本，先阻塞</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">     <span class="comment">//主从同步，从不删除，只删除主节点，从节点同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">//没过期</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">//过期数量++	</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">//失效记录，aof记录等</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);  <span class="comment">//lazy机制</span></span><br><span class="line">    <span class="comment">//发送删除通知从数据库</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//删除方式选择，异步或者同步</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">     <span class="comment">//删除待清理key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">     <span class="comment">//返回数据库字典中包含key的条目指针，并从数据库字典中摘除该条目</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);<span class="comment">//评估代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If releasing the object is too much work, let's put it into the</span></span><br><span class="line"><span class="comment">         * lazy free list. */</span></span><br><span class="line">         <span class="comment">//判断大小，是否需要后台删除，大于64的再丢给后台线程bio后台处理</span></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD) &#123;</span><br><span class="line">            </span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);<span class="comment">//待处理对象增加1</span></span><br><span class="line">            </span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//丢给bio后台子线程弄</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="comment">//集群模式下</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.conf </span><br><span class="line">lazyfree-lazy-eviction no  <span class="comment">//内存满  freeMemoryIfNeeded</span></span><br><span class="line">lazyfree-lazy-expire no  <span class="comment">//过期     expireIfNeeded</span></span><br><span class="line">lazyfree-lazy-server-del no  <span class="comment">//del命令  dbDelete</span></span><br><span class="line">slave-lazy-flush no   <span class="comment">//slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景   readSyncBulkPayload</span></span><br></pre></td></tr></table></figure>
<p><strong>lazyfree机制  删除大数据的键值，导致redis阻塞，4.0引入的，将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</strong></p>
<h4 id="redis-思考"><a href="#redis-思考" class="headerlink" title="redis 思考"></a>redis 思考</h4><ol>
<li>redis4.0引入的命令 unlink（unlinkCommand）</li>
<li>FLUSHALL/FLUSHDB ASYNC  线上禁用</li>
<li>Lazy 应该全开</li>
</ol>
<h3 id="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长"><a href="#定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长" class="headerlink" title="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长"></a>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长</h3><ol>
<li>databasesCron -&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);分多次<br>遍历各个数据库，从expires字典中随机检查一部分过期键的过期时间，删除其中的过期键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW 0</span></span><br><span class="line"><span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;  </span><br><span class="line"><span class="comment">//server.hz  10 默认值，conf，serverCron任务的执行周期执行周期，空闲每秒执行10次，清理时间最大为25ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_FAST 1   <span class="comment">//1000微秒</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">               <span class="comment">//随机取，过期删除</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span><span class="comment">//删除5个就遍历下一个db</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>事件处理函数aeMain    beforeSleep  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</li>
<li>访问key 判断lookupKeyRead，过期删除</li>
</ol>
<h2 id="持久化rdb-aof"><a href="#持久化rdb-aof" class="headerlink" title="持久化rdb/aof"></a>持久化rdb/aof</h2><h3 id="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"><a href="#rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态" class="headerlink" title="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"></a>rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态</h3><ol>
<li>RDB文件创建两个命令可以生成RDB文件：SAVE和BGSAVE。</li>
</ol>
<p><img src="/2018/11/09/Redis4源码阅读学习-1/2.png" alt="Image text"><br>   SAVE命令会阻塞redis的服务器进程，直到RDB文件创建完毕为止。在阻塞过程中，server不能处理任何请求    saveCommand-&gt;rdbSave-&gt;rdbSaveRio-&gt;rdbSaveKeyValuePair<br>   REDIS // RDB协议约束的固定字符串<br>   0006 // redis的版本<br>   FE 00 // 表示当前接下来的key都是db=0中的key;<br>   FC 1506327609 // 表示key失效时间点为1506327609<br>   0 // 表示key的属性是string类型<br>   username // key<br>   afei // value<br>   FF // 表示遍历完成<br>   y73e9iq1 // checksum  , CRC64</p>
<p>   <img src="/2018/11/09/Redis4源码阅读学习-1/3.jpeg" alt="Image text"><br>   BGSAVE则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。<br>   fork()系统调用我们可以创建一个和当前进程一样的新进程，继承了父进程的整个地址空间,其中包括了进程上下文,堆栈地址,内存信息进程控制块<br>   bgsaveCommand-&gt;rdbSaveBackground-&gt; rdbSave<br>   <a href="https://blog.codingnow.com/2011/01/fork_multi_thread.html" target="_blank" rel="noopener">fork危害，多进程的多线程程序</a><br>   自动执行bgsave，配置redis.conf  </p>
<h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>   save 900 1<br>   save 300 10<br>   save 60 10000<br>   只要这三个条件中的任意一条符合，那么服务器就会执行BGSAVE。配置保存在 redisServer saveparam中，serverCron中判断执行<br>   rdb加载，loadDataFromDisk -&gt; rdbLoad（），阻塞</p>
<ol start="2">
<li><p>aof记录服务器所处理的所有的除查询意外的操作，以文本的方式记录<br>原理是：处理文件事件执行写命令，使得命令被追加到aof_buf中，，然后在处理时间事件执行serverCron函数会调用flushAppendOnlyFile函数进行文件的写入和同步。<br> appendonly yes<br> appendfilename “appendonly.aof”<br> appendfsync everysec<br> always：将aof_buf中的所有内容写入并同步到aof文件。<br> everysec：将aof_buf中的所有内容写入到aof文件，如果上次同步的时间距离现在超过1s，那么对aof文件进行同步，同步操作由一个线程专门负责执行<br> no：将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，同步有操作系统执行。</p>
<p> aof流程主要函数：<br> //函数1：将command写入aof_buff  propagate-&gt; feedAppendOnlyFile，数据修改更新到AOF缓存中<br> //函数2：启动子进程，后台用于整理aof的数据 serverCron-&gt; rewriteAppendOnlyFileBackground<br> //函数3：刷一遍server.db[16],依次将对象写入磁盘临时文件tmpfile，rewriteAppendOnlyFile -&gt;rewriteAppendOnlyFileRio<br> //函数4：将aof_buff内容持久化flushAppendOnlyFile<br> //函数5：将backgroundRewriteDoneHandler 更新子进程同步期间产生的修改</p>
<p><img src="https://img-blog.csdn.net/20160503161237360" alt="Image text">   </p>
<p> aof_rewrite 解决AOF文件体积膨胀的问题<br> 触发条件  </p>
<ol>
<li>被动： 当AOF文件尺寸超过conf：auto-aof-rewrite-min-size 64mb &amp; 达到一定增长比，<br>指当前aof文件比上次重写的增长比例大小 auto-aof-rewrite-percentage 100； </li>
<li>主动： 调用BGREWRITEAOF命令；<br><img src="https://img-blog.csdn.net/20160503161309698" alt="Image text"><br>对应bgrewriteaofCommand逻辑  </li>
</ol>
</li>
<li><p>混合持久化 conf aof-use-rdb-preamble no， aof rewrite 的时候就直接把 rdb 的内容写到 aof 文件开头     </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |          RDB           |   </span><br><span class="line">            |         FORMAT         |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |        AOF             |   </span><br><span class="line">            |       FORMAT           |   </span><br><span class="line">            +------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">       <span class="keyword">int</span> error;</span><br><span class="line">       <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">           errno = error;</span><br><span class="line">           <span class="keyword">goto</span> werr;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>rdb优缺点：二进制文件，速度快，存在数据丢失，性能消耗低<br>aof优缺点：数据丢失小，性能消耗大，4.0管道优化相对好些<br>混合持久化：加载速度快，避免丢失数据</p>
<h3 id="事故案例：陌陌争霸"><a href="#事故案例：陌陌争霸" class="headerlink" title="事故案例：陌陌争霸"></a>事故案例：陌陌争霸</h3><p>32 个数据仓库部署到 4 台物理机上即可，每台机器上启动 8 个 Redis 进程。使用 64G 内存的机器，后来增加到了 96G 内存。实测每个 Redis 服务会占到 4~5 G 内存，四台配置相同的从主机进行主从备份。  </p>
<p>事故1：有一台数据服务主机无法被游戏服务器访问到，影响了部分用户登陆，运维维护时发现，一台从机的内存耗尽，导致了从机的数据库服务重启。在从机重新对主机连接，8 个 Redis 同时发送 SYNC 的冲击下，把主机击毁了。<br>问题1：从主机为什么出现内存不足<br>原因：redis 服务同时做 BGSAVE，概率性 ，而导致 fork 多个进程需要消耗太多内存<br>问题2：重新进行 SYNC 操作会导致主机过载<br>原因：重启后，8 个 slave redis 同时开启同步，等于瞬间在主机上 fork 出 8 个 redis 进程<br>解决方案：取消主从，脚本控制bgsave</p>
<p>事故2:内存内存不足<br>原因：定期备份redis数据库文件，拷贝数据库文件时，系统使用大量的内存做为cache，释放不及时，脚本控制bgsave，内存不住，使用交换分区，脚本保证30分钟内必须执行一次bgsave</p>
<p>思考：1.备份方案的选择。2.使用leveldb做redis的持久化存储 3.redis内存上限设置一半  </p>
<h1 id="hyperloglog-c"><a href="#hyperloglog-c" class="headerlink" title="hyperloglog.c"></a>hyperloglog.c</h1><h2 id="在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"><a href="#在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身" class="headerlink" title="在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"></a>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</h2><p>##看到第一句话就知道这个已经完全没有了解的必要了，逆天的算法，用于比如ip访问数的基数统计。</p>
<h2 id="动态字符串-sds-h和sds-c"><a href="#动态字符串-sds-h和sds-c" class="headerlink" title="+ 动态字符串 sds.h和sds.c"></a>+ 动态字符串 sds.h和sds.c</h2><h2 id="双端链表-adlist-c和adlist-h"><a href="#双端链表-adlist-c和adlist-h" class="headerlink" title="+ 双端链表 adlist.c和adlist.h"></a>+ 双端链表 adlist.c和adlist.h</h2><h2 id="字典-dict-h和dict-c"><a href="#字典-dict-h和dict-c" class="headerlink" title="+ 字典 dict.h和dict.c"></a>+ 字典 dict.h和dict.c</h2><h2 id="跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。"><a href="#跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。" class="headerlink" title="+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。"></a>+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。</h2><h2 id="intset-c和intset-h"><a href="#intset-c和intset-h" class="headerlink" title="+intset.c和intset.h"></a>+intset.c和intset.h</h2><ol>
<li>intset 是一种有序的整型集合，共有 <code>INTSET_ENC_INT16</code>、<code>INTSET_ENC_INT32</code>、<code>INTSET_ENC_INT64</code> 编码类型。</li>
<li>intset <code>length</code> 属性记了录集合的大小。</li>
<li>intset 内部采用<code>二分查找算法</code> 定位元素。</li>
<li>intset 只会升级，不会降级。当将一个高位元素添加到低编码集合时，此时，需要对集合进行升级。</li>
</ol>
<h2 id="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"><a href="#这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。" class="headerlink" title="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"></a>这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。</h2><h2 id="ziplist-c和ziplist-h"><a href="#ziplist-c和ziplist-h" class="headerlink" title="ziplist.c和ziplist.h"></a>ziplist.c和ziplist.h</h2><ol>
<li>实在是不想看实现了，估计也看不懂，看名字就知道是一种极节内存内存的链表，redis是内存性数据库，肯定还是要能省则省，代码肯定是有的，肯定是性能稍微差一点，但是应该差的不多，大神撸出来的东西是不用有任何怀疑的。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/c，数据库，缓存，redis/" rel="tag"># c，数据库，缓存，redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/09/DDoS防护的方案和演进/" rel="next" title="DDoS防护的方案和演进">
                <i class="fa fa-chevron-left"></i> DDoS防护的方案和演进
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/09/Redis4源码阅读学习-2/" rel="prev" title="redis4源码阅读学习-2">
                redis4源码阅读学习-2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="三鱼">
            
              <p class="site-author-name" itemprop="name">三鱼</p>
              <p class="site-description motion-element" itemprop="description">挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xyiot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:softstarxy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/5419866199/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#zmalloc-c"><span class="nav-number">1.</span> <span class="nav-text">zmalloc.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcmalloc"><span class="nav-number">2.</span> <span class="nav-text">tcmalloc</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jemalloc"><span class="nav-number">3.</span> <span class="nav-text">jemalloc</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详情可以参考GCC官方文档链接"><span class="nav-number">3.1.</span> <span class="nav-text">详情可以参考GCC官方文档链接</span></a></li></ol></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构：objcet"><span class="nav-number"></span> <span class="nav-text">数据结构：objcet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"><span class="nav-number">0.1.</span> <span class="nav-text">refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法"><span class="nav-number">1.</span> <span class="nav-text">Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"><span class="nav-number">1.1.</span> <span class="nav-text">counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#动态配置"><span class="nav-number"></span> <span class="nav-text">动态配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis内存达到上限后的释放内存原则"><span class="nav-number">0.1.</span> <span class="nav-text">redis内存达到上限后的释放内存原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#如何筛选释放的key"><span class="nav-number"></span> <span class="nav-text">如何筛选释放的key</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"><span class="nav-number">1.</span> <span class="nav-text">根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用"><span class="nav-number">1.1.</span> <span class="nav-text">统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存管理策略的入口函数—freeMemoryIfNeeded"><span class="nav-number">1.2.</span> <span class="nav-text">内存管理策略的入口函数—freeMemoryIfNeeded()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#后续优化方向"><span class="nav-number">1.3.</span> <span class="nav-text">后续优化方向</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#过期key删除策略"><span class="nav-number">2.</span> <span class="nav-text">过期key删除策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"><span class="nav-number">2.1.</span> <span class="nav-text">惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#redis-思考"><span class="nav-number">2.1.1.</span> <span class="nav-text">redis 思考</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长"><span class="nav-number">2.2.</span> <span class="nav-text">定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#持久化rdb-aof"><span class="nav-number">3.</span> <span class="nav-text">持久化rdb/aof</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"><span class="nav-number">3.1.</span> <span class="nav-text">rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#save-“”"><span class="nav-number"></span> <span class="nav-text">save “”</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#事故案例：陌陌争霸"><span class="nav-number">0.1.</span> <span class="nav-text">事故案例：陌陌争霸</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hyperloglog-c"><span class="nav-number"></span> <span class="nav-text">hyperloglog.c</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"><span class="nav-number">1.</span> <span class="nav-text">在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态字符串-sds-h和sds-c"><span class="nav-number">2.</span> <span class="nav-text">+ 动态字符串 sds.h和sds.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#双端链表-adlist-c和adlist-h"><span class="nav-number">3.</span> <span class="nav-text">+ 双端链表 adlist.c和adlist.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字典-dict-h和dict-c"><span class="nav-number">4.</span> <span class="nav-text">+ 字典 dict.h和dict.c</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。"><span class="nav-number">5.</span> <span class="nav-text">+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intset-c和intset-h"><span class="nav-number">6.</span> <span class="nav-text">+intset.c和intset.h</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"><span class="nav-number">7.</span> <span class="nav-text">这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ziplist-c和ziplist-h"><span class="nav-number">8.</span> <span class="nav-text">ziplist.c和ziplist.h</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三鱼</span>
  
</div>









        
<div class="busuanzi-count">
     <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
