<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三余无梦生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-09T06:16:26.663Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>三鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缺舟</title>
    <link href="http://yoursite.com/2019/04/01/begin/"/>
    <id>http://yoursite.com/2019/04/01/begin/</id>
    <published>2019-04-01T10:00:00.000Z</published>
    <updated>2019-04-09T06:16:26.663Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"><a href="#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。" class="headerlink" title="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"></a>思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot;&gt;&lt;a href=&quot;#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot; class=&quot;headerlink&quot; title=&quot;思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot;&gt;&lt;/a&gt;思绪
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis4源码阅读学习-2</title>
    <link href="http://yoursite.com/2019/02/09/Redis4%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://yoursite.com/2019/02/09/Redis4源码阅读学习-2/</id>
    <published>2019-02-09T10:02:37.000Z</published>
    <updated>2019-04-09T11:22:23.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis客户端和服务器的相关代码"><a href="#redis客户端和服务器的相关代码" class="headerlink" title="redis客户端和服务器的相关代码"></a>redis客户端和服务器的相关代码</h1><h2 id="ae-c（Redis-的事件处理器实现（基于-Reactor-模式））"><a href="#ae-c（Redis-的事件处理器实现（基于-Reactor-模式））" class="headerlink" title="ae.c（Redis 的事件处理器实现（基于 Reactor 模式））"></a>ae.c（Redis 的事件处理器实现（基于 Reactor 模式））</h2><p><img src="/2019/02/09/Redis4源码阅读学习-2/1.png" alt></p><p>handle_events()</p><p>在Redis中，对于文件事件，相应的处理函数为Ae.c/aeProcessEvents</p><p>register_handler/remove_handler 对应Redis中，相关的处理函数也在Ae.c文件中方法</p><p>select对应不同平台的io复用的函数库</p><p>handle对应fd资源，文件描述符</p><p>event handler  事件处理器的接口</p><p>Concrete Event Handler 事件处理器的实际实现，绑定handle，比如acceptTcpHandler  这些</p><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="aeFileEvent"><a href="#aeFileEvent" class="headerlink" title="aeFileEvent"></a>aeFileEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件事件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    aeFileProc *rfileProc;  <span class="comment">//读文件事件回调</span></span><br><span class="line">    aeFileProc *wfileProc;  <span class="comment">//写文件事件回调</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><h5 id="aeTimeEvent"><a href="#aeTimeEvent" class="headerlink" title="aeTimeEvent"></a>aeTimeEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间事件结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;<span class="comment">//定时回调函数指针</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;<span class="comment">// 定时事件清理函数，当删除定时事件的时候会被调用</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span><span class="comment">//时间事件表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><h5 id="aeFiredEvent"><a href="#aeFiredEvent" class="headerlink" title="aeFiredEvent"></a>aeFiredEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//表示事件发生在哪个文件描述符上面</span></span><br><span class="line">    <span class="keyword">int</span> mask;<span class="comment">//被触发事件的类型</span></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure><h5 id="aeEventLoop"><a href="#aeEventLoop" class="headerlink" title="aeEventLoop"></a>aeEventLoop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件循环结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">//记录最大的定时事件 id </span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; </span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">//用于系统时间的矫正</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">//文件表</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">//触发事件表</span></span><br><span class="line">    aeTimeEvent *timeEventHead;<span class="comment">//定时事件表</span></span><br><span class="line">    <span class="keyword">int</span> stop; <span class="comment">//事件循环停止标志</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">//统一接口，屏蔽不同平台io服用机制，</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">//进入poll之前需要处理的事情</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">//进入poll之后需要处理的事情</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    aeCreateEventLoop    <span class="comment">/* 创建总的事件管理结构 */</span></span><br><span class="line">    aeCreateTimeEvent    <span class="comment">/* 创建定时器事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> inet socket    <span class="comment">/* 创建网络事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> unix socket    <span class="comment">/* 内部通信事件的管理结构 */</span></span><br><span class="line">    aeSetBeforeSleepProc    <span class="comment">/* 设置beforeSleep处理函数 */</span></span><br><span class="line">    aeSetAfterSleepProc    <span class="comment">/* 设置afterSleep处理函数 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!stop)  <span class="comment">//aeMain</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//aeProcessEvents</span></span><br><span class="line">        beforeSleep                <span class="comment">/* 调用beforeSleep处理函数 */</span></span><br><span class="line">        aeApiPoll                <span class="comment">/* 进入poll函数 */</span></span><br><span class="line">        afterSleep                <span class="comment">/* 调用afterSleep处理函数 */</span></span><br><span class="line">        process file events    <span class="comment">/* 处理file events */</span></span><br><span class="line">        process time events    <span class="comment">/* 处理time events */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="aeCreateEventLoop-initServer调用初始化"><a href="#aeCreateEventLoop-initServer调用初始化" class="headerlink" title="aeCreateEventLoop  //initServer调用初始化"></a>aeCreateEventLoop  //initServer调用初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *aeCreateEventLoop(int setsize) &#123; </span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);</span><br><span class="line">    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(NULL);</span><br><span class="line">    eventLoop-&gt;timeEventHead = NULL;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = 0;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    eventLoop-&gt;maxfd = -1;</span><br><span class="line">    eventLoop-&gt;beforesleep = NULL;</span><br><span class="line">    eventLoop-&gt;aftersleep = NULL;</span><br><span class="line">    if (aeApiCreate(eventLoop) == -1) goto err;</span><br><span class="line">    /* Events with mask == AE_NONE are not set. So let&apos;s initialize the</span><br><span class="line">     * vector with it. */</span><br><span class="line">    for (i = 0; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    return eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h6><p>server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</p><p>setsize = server.maxclients+CONFIG_FDSET_INCR = 10000 + CONFIG_MIN_RESERVED_FDS+96</p><p>CONFIG_MIN_RESERVED_FDS = 32 是Sentinel保留的用于额外的的操作，如listening sockets, log files 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max 查看系统级别的能够打开的文件句柄的数量</span><br><span class="line">ulimit -a 1024 查看用户进程级的能够打开文件句柄的数量</span><br></pre></td></tr></table></figure><h6 id="相关的案例事件……"><a href="#相关的案例事件……" class="headerlink" title="相关的案例事件……"></a>相关的案例事件……</h6><p>9554:M 24 Mar 10:40:25.869 # Error registering fd event for the new client: Numerical result out of range (fd=10128)</p><p>系统内存不足以fork子进程时，AOF重写就无法启动，而此之前已打开的pipe也永远不会关闭，并在下一次尝试AOF重写时又创建新的pipe，从而造成fd泄漏。</p><p>具体代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">// 创建pipe</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">//子进程启动出错处理</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Can't rewrite append only file in background: fork: %s"</span>,</span><br><span class="line">                strerror(errno)); <span class="comment">// 最初内存不足正是这里打出的错误log</span></span><br><span class="line">            aofClosePipes();<span class="comment">//fix bug issues/2857</span></span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><h5 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h5><p>在一般情况下，<code>aeProcessEvents</code> 都会先<strong>计算最近的时间事件发生所需要等待的时间</strong>，然后调用 <code>aeApiPoll</code> 方法在这段时间中等待事件的发生，在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发：</p><pre><code>numevents = aeApiPoll(eventLoop, tvp);/* After sleep callback. */if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)    eventLoop-&gt;aftersleep(eventLoop);for (j = 0; j &lt; numevents; j++) {    aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];    int mask = eventLoop-&gt;fired[j].mask;    int fd = eventLoop-&gt;fired[j].fd;    int fired = 0; /* Number of events fired for current fd. */    int invert = fe-&gt;mask &amp; AE_BARRIER;</code></pre><h2 id="文件事件注册-aeCreateFileEvent"><a href="#文件事件注册-aeCreateFileEvent" class="headerlink" title="文件事件注册  aeCreateFileEvent"></a>文件事件注册  aeCreateFileEvent</h2><h2 id="监听实现"><a href="#监听实现" class="headerlink" title="监听实现"></a>监听实现</h2><p>1.<code>initServer()</code>中完成了对事件循环的初始化操作</p><p>listenToPort</p><p>2.完成了监听套接字的初始化，<code>initServer()</code>还需要为所有监听套接字注册读事件</p><p>acceptTcpHandler/acceptUnixHandler  //回调监听到新连接请求时</p><p>acceptTcpHandler()-&gt;acceptCommonHandler  </p><p>在与客户端成功建立连接之后，调用了<code>acceptCommonHandler()</code>函数，其作用为：<br> 1、 建立并保存服务器与客户端的连接信息，将信息保存到一个struct redisClient 中；<br> 2、为客户端的cfd（已连接的socket）注册读事件，相应的回调函数为<code>readQueryFromClient()</code>，其作用是从socket读取数据，执行相应操作，并回复给客户端(而acceptCommonHandler是为监听socket的读事件回调函数)</p><h2 id="事件循环aeMain"><a href="#事件循环aeMain" class="headerlink" title="事件循环aeMain"></a>事件循环aeMain</h2><p>1、根据时间事件链表计算需要等待的最短事件；<br>2、调用<code>redis aeApiPoll()</code> 进入监听轮询，如果没有事件发生就进入睡眠状态，其实就是进行I/O多路复用函数调用。<br>3、如果有事件发生，处理事件。</p><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>aeApiPoll //多路复用函数阻塞监听</p><p>##### </p><h5 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2.时间事件"></a>2.时间事件</h5><p>在 Redis 中会发生两种时间事件：</p><ul><li>一种是定时事件，每隔一段时间会执行一次；</li><li>另一种是非定时事件，只会在某个时间点执行一次；</li></ul><p>aeProcessEvents -&gt;processTimeEvents</p><p><img src="/2019/02/09/Redis4源码阅读学习-2/2.png" alt></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1时间事件分为定时时间和周期事件，周期事件serverCron  100毫秒</p><p>2时间事件和文件事件合并到一起处理，分开；</p><p>3.时间事件晚于预设</p><p><img src="/2019/02/09/Redis4源码阅读学习-2/aeEventLoop.png" alt></p><h4 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h4><p>readQueryFromClient   processCommand</p><p>clientsCronHandleTimeout //keep_alive，ping,异常处理</p><p>三类方法</p><p>1.addReply API  往数据结构里面写东西</p><p>2.Client API 客户端创建释放</p><p>3.工具方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listMatchObjects</span><br><span class="line">disconnectSlaves</span><br><span class="line">flushSlavesOutputBuffers</span><br><span class="line">acceptTcpHandler</span><br><span class="line">copyClientOutputBuffer</span><br></pre></td></tr></table></figure><h4 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h4><p>1.Globals</p><p>2.Utility functions</p><p>3.Hash table</p><p>4.Cron</p><p>trackInstantaneousMetric  bug</p><p>writeToClient    server.stat_net_output_bytes += totwritten;</p><pre><code>5.0//缓冲区大于32K，且远大于查询缓冲区数据峰值//询缓冲区大于32K，且客户端当前处于非活跃状态int clientsCronResizeQueryBuffer(client *c)if (querybuf_size &gt; PROTO_MBULK_BIG_ARG &amp;&amp;     ((querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2 ||      idletime &gt; 2)){    /* Only resize the query buffer if it is actually wasting     * at least a few kbytes. */    if (sdsavail(c-&gt;querybuf) &gt; 1024*4) {        c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);    }}4.0// 查询缓冲区大于32K，且远大于查询缓冲区数据峰值// 查询缓冲区大于1K，且客户端当前处于非活跃状态if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;    (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||    (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2)){        /* Only resize the query buffer if it is actually wasting space. */        if (sdsavail(c-&gt;querybuf) &gt; 1024) {            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);        } }//c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);初始化默认分配的大小就是32k如果客户端数量比较多，且刚好比较空闲，需要一次处理很多客户端的输入缓冲区，阻塞或者崩溃</code></pre><p>5.serverCron 相关的知识点</p><p>1）.信息更新，统计</p><p>2).  XXXXCron</p><p>3). 持久化</p><p>4). 集群</p><p>6.Server initialization</p><p>7.Redis OP Array API  持久化复制的时候命令数组</p><p>8.Commands lookup and execution</p><p>9.Shutdown</p><p>10.Commands</p><ol start="11"><li><strong>linux</strong></li></ol><p>12.main</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis客户端和服务器的相关代码&quot;&gt;&lt;a href=&quot;#redis客户端和服务器的相关代码&quot; class=&quot;headerlink&quot; title=&quot;redis客户端和服务器的相关代码&quot;&gt;&lt;/a&gt;redis客户端和服务器的相关代码&lt;/h1&gt;&lt;h2 id=&quot;ae-c（
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://yoursite.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c，数据库，缓存，redis" scheme="http://yoursite.com/tags/c%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>redis4源码阅读学习-1</title>
    <link href="http://yoursite.com/2018/11/09/Redis4%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/</id>
    <published>2018-11-09T10:02:37.000Z</published>
    <updated>2019-04-09T11:20:25.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h2><h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">tcmalloc</a></h2><h2 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a><a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><h3 id="详情可以参考GCC官方文档链接"><a href="#详情可以参考GCC官方文档链接" class="headerlink" title="详情可以参考GCC官方文档链接"></a>详情可以参考GCC官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">链接</a></h3><ol><li>分配内存大小为size+PREFIX_SIZE的大小，zmalloc实际分配比需要多一些的内存，这一部分用于存储size信息。</li><li>zmalloc_oom_handler用来处理内存申请异常</li><li>(_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); = if(_n&amp;7) _n += 8 - (_n&amp;7);  32位4字节对齐，64位下8字节对齐</li></ol><h1 id="数据结构：objcet"><a href="#数据结构：objcet" class="headerlink" title="数据结构：objcet"></a>数据结构：objcet</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time).  </span></span><br><span class="line"><span class="comment">              16 bits      8 bits</span></span><br><span class="line"><span class="comment">      +------------------+--------+</span></span><br><span class="line"><span class="comment">      + Last access time | LOG_C  |</span></span><br><span class="line"><span class="comment">      +------------------+--------+*/</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">//通过引用计数的方式来管理内存，c++11，oc</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指向具体实现的具体区域和数据结构</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type字段表示数据类型，有以下几种定义：</span><br><span class="line">OBJ_STRING   <span class="comment">// 字符串</span></span><br><span class="line">OBJ_LIST  <span class="comment">// 链表</span></span><br><span class="line">OBJ_SET  <span class="comment">// 集合</span></span><br><span class="line">OBJ_ZSET  <span class="comment">// 有序集合</span></span><br><span class="line">OBJ_HASH  <span class="comment">// HASH结构（注意，此处不同于传统意义上的哈希表（如stl::hash_map），这里的hash仅有字段散列的语义）</span></span><br><span class="line">REDIS_VMPOINTER  <span class="comment">// VM指针，已经废弃，翻看了一下VM相关实现和历史</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Redis采用VM机制是希望把存储做成如同Oracle一样的方式，具备自动淘汰冷热数据功能，但是，它采用了RDB文件和VM机制来分别实现二进制存储、冷热淘汰的功能，期望是既节约内存又达到完美性能的地步</span></span><br><span class="line"><span class="comment">redis之所以高性能最本质的原因是数据都cache到内存里。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encoding则对应了 Redis 中的10种编码方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>数据类型</th><th style="text-align:right">一般情况</th><th style="text-align:center">少量情况</th><th style="text-align:right">特殊情况</th></tr></thead><tbody><tr><td>STRING</td><td style="text-align:right">RAW</td><td style="text-align:center">EMBSTR</td><td style="text-align:right">INT</td></tr><tr><td>LIST</td><td style="text-align:right">LINKEDLIST</td><td style="text-align:center">ZIPLIST</td><td style="text-align:right"></td></tr><tr><td>HASH</td><td style="text-align:right">HT</td><td style="text-align:center">ZIPLIST</td></tr></tbody></table><p>###refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的<a href="https://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">引用计数与垃圾收集之比较</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objcet.c基本上就是提供了一堆对象操作，初始化等相关的api接口</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>&#123; <span class="comment">/* 最初的创建robj对象方法，后面的创建方法与此类似 */</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">        <span class="comment">//lru lfu算法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK(); <span class="comment">//都记录下该对象的LRU时钟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//正常释放</span></span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);<span class="comment">//异常</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法"><a href="#Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法" class="headerlink" title="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法"></a>Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法</h2><ol><li>引用计数  refcount</li><li>lru （Least Recently Used）//最长时间未被使用<br><img src="/2018/11/09/Redis4源码阅读学习-1/5.png" alt="Image text"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) = 2^24 - 1 单位毫秒 /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000  <span class="comment">//代表LRU算法的精度，即一个LRU的单位是多长时间，1秒</span></span></span><br><span class="line"><span class="comment">//LRU时钟的时间粒度高于serverCron刷新的时间粒度，那么就主动获取最新的时间，否则使用server缓存的时间</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">    <span class="comment">//如果定时器执行的频率高于LRU算法的精度时，可以直接将server.lruclock直接在对象创建时赋值过去，避免了函数调用的内存开销以及时间开销</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.........</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lruclock = getLRUClock();</span><br><span class="line">    atomicSet(server.lruclock,lruclock);</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数据的空闲时间</span></span><br><span class="line">evictionPoolPopulate-&gt;estimateObjectIdleTime-&gt;LRU_CLOCK</span><br><span class="line">objectCommand(idletime) -&gt; estimateObjectIdleTime</span><br></pre></td></tr></table></figure><p>3.LFU（Least Frequently Used） 最不常用页面置换算法，基于LFU的热点key发现机制  4.0<br>counter：基于概率的对数计数器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX; <span class="comment">//RAND_MAX c语言宏，rand最大上限值</span></span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">//LFU_INIT_VAL = 5</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//默认server.lfu_log_factor=10，概率因子</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++;   <span class="comment">//baseval增加后，p&lt;r的概率非线形增长</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span><span class="comment">//从db-&gt;dict字典中获取key的val，并更新val的lru/lfu</span></span></span><br></pre></td></tr></table></figure><p><img src="/2018/11/09/Redis4源码阅读学习-1/1.png" alt="Image text"></p><h3 id="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"><a href="#counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万" class="headerlink" title="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"></a>counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万</h3><h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span> 概率因子</span><br><span class="line">lfu-decay-time <span class="number">1</span>  每分钟衰减<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新对象的访问时间和计数器值,减少，每分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">//获取lru时间  分钟   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//获取使用频次</span></span><br><span class="line">    <span class="comment">//时间超过了lfu_decay_time的话，那么将使用频次减少</span></span><br><span class="line">    <span class="keyword">if</span> (LFUTimeElapsed(ldt) &gt;= server.lfu_decay_time &amp;&amp; counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; LFU_INIT_VAL*<span class="number">2</span>) &#123;</span><br><span class="line">            counter /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; LFU_INIT_VAL*<span class="number">2</span>) counter = LFU_INIT_VAL*<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新时间和频次</span></span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次访问该数据对象已经过去了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前的分钟计数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis内存达到上限后的释放内存原则"><a href="#redis内存达到上限后的释放内存原则" class="headerlink" title="redis内存达到上限后的释放内存原则"></a>redis内存达到上限后的释放内存原则</h3><ol><li>释放内存的标准是释放之后使用内存的大小小于maxmemory的大小</li><li>每次释放的数量，redis.conf配置</li><li>超过限制后redis策略</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis.conf配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-lru -&gt; 从设置了过期时间的键中选择空转时间最长的键值对清除掉</span><br><span class="line"><span class="keyword">volatile</span>-lfu -&gt; 从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</span><br><span class="line"><span class="keyword">volatile</span>-random -&gt; 从设置了过期时间的键中，随机选择键进行清除.</span><br><span class="line"></span><br><span class="line">allkeys-lru -&gt; 从所有的键中选择空转时间最长的键值对清除</span><br><span class="line">allkeys-lfu -&gt; 从所有的键中选择某段时间之内使用频次最少的键值对清除.</span><br><span class="line">allkeys-random -&gt; 从所有的key中随机删除</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-ttl -&gt; 从已设置过期时间的数据集合中挑选即将过期的数据淘汰</span><br><span class="line">noeviction -&gt;不做任何的清理工作，禁止写入，报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The <span class="keyword">default</span> of <span class="number">5</span> produces good enough results. <span class="number">10</span> Approximates very closely</span><br><span class="line"><span class="meta"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line">#</span><br><span class="line"><span class="meta"># maxmemory-samples 5 lru，lfu每次采样数，5最佳</span></span><br></pre></td></tr></table></figure><h1 id="如何筛选释放的key"><a href="#如何筛选释放的key" class="headerlink" title="如何筛选释放的key"></a>如何筛选释放的key</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16 <span class="comment">//存储待释放的键相关信息的存储空间能够容纳的键的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255 <span class="comment">//cached中的最大的键的长度    512mb</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span> <span class="comment">//存储待释放的键所在内存的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化EvictionPoolLRU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolAlloc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    ep = zmalloc(<span class="keyword">sizeof</span>(*ep)*EVPOOL_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; EVPOOL_SIZE; j++) &#123;</span><br><span class="line">        ep[j].idle = <span class="number">0</span>;</span><br><span class="line">        ep[j].key = <span class="literal">NULL</span>;</span><br><span class="line">        ep[j].cached = sdsnewlen(<span class="literal">NULL</span>,EVPOOL_CACHED_SDS_SIZE);</span><br><span class="line">        ep[j].dbid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EvictionPoolLRU = ep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"><a href="#根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中" class="headerlink" title="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"></a>根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从sampledict中最多选取server.maxmemory_samples个指向sampledict的指针存放在放入到samples中,</span></span><br><span class="line"><span class="comment">//server.maxmemory_samples配置5</span></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment">         * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment">         * again in the key dictionary to obtain the value object. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果maxmemory_policy为MAXMEMORY_VOLATILE_TTL，证明需要将距离过期时间最近的键清除掉;那么直接从redisDB-&gt;expire对应的字典中获取键对应的过期时间值即可，此时不需要改变已经存在的de。</span></span><br><span class="line">   <span class="comment">//如果maxmemory_policy != MAXMEMORY_VOLATILE_TTL且不是从redisDB-&gt;dict中获取键的值(使用redisDB-&gt;expire中获取的键),</span></span><br><span class="line">  那么需要从redisDB-&gt;dict中获取键对应的值的对象，才能够获取lru字段 </span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lru，lfu，ttl 统一用idle来衡量</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            <span class="comment">/* When we use an LRU policy, we sort the keys by idle time</span></span><br><span class="line"><span class="comment">             * so that we expire keys starting from greater idle time.</span></span><br><span class="line"><span class="comment">             * However when the policy is an LFU one, we have a frequency</span></span><br><span class="line"><span class="comment">             * estimation, and we want to evict keys with lower frequency</span></span><br><span class="line"><span class="comment">             * first. So inside the pool we put objects using the inverted</span></span><br><span class="line"><span class="comment">             * frequency subtracting the actual frequency to the maximum</span></span><br><span class="line"><span class="comment">             * frequency of 255. */</span></span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o); <span class="comment">//LFUDecrAndReturn返回 counter</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">         </span><br><span class="line">  <span class="comment">//EvictionPoolLRU中的元素全部按照元素对应的idle值按照从小到大的顺序</span></span><br><span class="line">    <span class="comment">//idle越大，位置越靠后，当然也就最先被清除掉。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找元素的插入位置</span></span><br><span class="line">        <span class="comment">//pool中所有的元素都不为空，且其中元素的最小的idle大于等于idle</span></span><br><span class="line">        <span class="comment">//EVPOOL_SIZE 16</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">               <span class="comment">//满了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to reuse the cached SDS string allocated in the pool entry,</span></span><br><span class="line"><span class="comment">         * because allocating and deallocating this object is costly</span></span><br><span class="line"><span class="comment">         * (according to the profiler, not my fantasy. Remember:</span></span><br><span class="line"><span class="comment">         * premature optimizbla bla bla bla. */</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用"><a href="#统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用" class="headerlink" title="统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用"></a>统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment"> * count of used memory. */</span></span><br><span class="line">mem_used = mem_reported;</span><br><span class="line"><span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure><h3 id="内存管理策略的入口函数—freeMemoryIfNeeded"><a href="#内存管理策略的入口函数—freeMemoryIfNeeded" class="headerlink" title="内存管理策略的入口函数—freeMemoryIfNeeded()"></a>内存管理策略的入口函数—freeMemoryIfNeeded()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">     <span class="comment">//在阻塞状态，并且阻塞时间未到，应该是和阻塞状态有关</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">     <span class="comment">// 如果没有超过限制，那么没必要进行内存的清理工作</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (mem_reported &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    <span class="comment">// 排查aof，slaves</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">     <span class="comment">//在进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//默认情况，不搞了</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i, keys_freed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">          <span class="comment">//如果策略是TTL，设置了过期时间的LRU，LRU</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">     </span><br><span class="line">                <span class="comment">//针对server中的所有db中选出最佳的可以被淘汰的键进行淘汰 </span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">//从EvctionPoolLRU中的最后一个元素(idle值最大）开始释放内存</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"><span class="comment">//如果是allkeys开头的删除策略，从dict字典中获取对象; 否则从expire字典中获取对象</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">//获取了bestid和de，释放EvctionPoolLRU里面key对应的内存</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="comment">//如果使用random相关的空间管理策略，则直接随机从dict或者expire中获取一个键进行删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">             <span class="comment">//每次选不同db的一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="comment">//最终删除选择的bestkey</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            <span class="comment">/* We compute the amount of memory freed by db*Delete() alone.</span></span><br><span class="line"><span class="comment">             * It is possible that actually the memory needed to propagate</span></span><br><span class="line"><span class="comment">             * the DEL in AOF and replication link is greater than the one</span></span><br><span class="line"><span class="comment">             * we are freeing removing the key, but we can't account for</span></span><br><span class="line"><span class="comment">             * that otherwise we would never exit the loop.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * AOF and Output buffer memory will be freed eventually so</span></span><br><span class="line"><span class="comment">             * we only care about memory used by the key space. */</span></span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">             * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">             * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">             * transmission here inside the loop. */</span></span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally our stop condition is the ability to release</span></span><br><span class="line"><span class="comment">             * a fixed, pre-computed amount of memory. However when we</span></span><br><span class="line"><span class="comment">             * are deleting objects in another thread, it's better to</span></span><br><span class="line"><span class="comment">             * check, from time to time, if we already reached our target</span></span><br><span class="line"><span class="comment">             * memory, since the "mem_freed" amount is computed only</span></span><br><span class="line"><span class="comment">             * across the dbAsyncDelete() call, while the thread can</span></span><br><span class="line"><span class="comment">             * release the memory all the time. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">                mem_used = zmalloc_used_memory();</span><br><span class="line">                mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) &#123;</span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keys_freed) &#123;</span><br><span class="line">            latencyEndMonitor(latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;= mem_tofree)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ol><li>淘汰算法的优化，更有效的需要淘汰的key</li><li>算法对性能，内存的影响</li></ol><h2 id="过期key删除策略"><a href="#过期key删除策略" class="headerlink" title="过期key删除策略"></a>过期key删除策略</h2><h3 id="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"><a href="#惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；" class="headerlink" title="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"></a>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">//获取过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">     <span class="comment">//执行lua脚本，先阻塞</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">     <span class="comment">//主从同步，从不删除，只删除主节点，从节点同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">//没过期</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">//过期数量++</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">//失效记录，aof记录等</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);  <span class="comment">//lazy机制</span></span><br><span class="line">    <span class="comment">//发送删除通知从数据库</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//删除方式选择，异步或者同步</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">     <span class="comment">//删除待清理key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">     <span class="comment">//返回数据库字典中包含key的条目指针，并从数据库字典中摘除该条目</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);<span class="comment">//评估代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If releasing the object is too much work, let's put it into the</span></span><br><span class="line"><span class="comment">         * lazy free list. */</span></span><br><span class="line">         <span class="comment">//判断大小，是否需要后台删除，大于64的再丢给后台线程bio后台处理</span></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD) &#123;</span><br><span class="line">            </span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);<span class="comment">//待处理对象增加1</span></span><br><span class="line">            </span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//丢给bio后台子线程弄</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="comment">//集群模式下</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.conf </span><br><span class="line">lazyfree-lazy-eviction no  <span class="comment">//内存满  freeMemoryIfNeeded</span></span><br><span class="line">lazyfree-lazy-expire no  <span class="comment">//过期     expireIfNeeded</span></span><br><span class="line">lazyfree-lazy-server-del no  <span class="comment">//del命令  dbDelete</span></span><br><span class="line">slave-lazy-flush no   <span class="comment">//slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景   readSyncBulkPayload</span></span><br></pre></td></tr></table></figure><p><strong>lazyfree机制  删除大数据的键值，导致redis阻塞，4.0引入的，将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</strong></p><p>####redis 思考</p><ol><li>redis4.0引入的命令 unlink（unlinkCommand）</li><li>FLUSHALL/FLUSHDB ASYNC  线上禁用</li><li>Lazy 应该全开</li></ol><p>###定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长</p><ol><li>databasesCron -&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);分多次<br>遍历各个数据库，从expires字典中随机检查一部分过期键的过期时间，删除其中的过期键</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW 0</span></span><br><span class="line"><span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;  </span><br><span class="line"><span class="comment">//server.hz  10 默认值，conf，serverCron任务的执行周期执行周期，空闲每秒执行10次，清理时间最大为25ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_FAST 1   <span class="comment">//1000微秒</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">               <span class="comment">//随机取，过期删除</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span><span class="comment">//删除5个就遍历下一个db</span></span><br></pre></td></tr></table></figure><ol start="2"><li>事件处理函数aeMain    beforeSleep  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</li><li>访问key 判断lookupKeyRead，过期删除</li></ol><p>##持久化rdb/aof</p><p>###rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态</p><ol><li>RDB文件创建两个命令可以生成RDB文件：SAVE和BGSAVE。</li></ol><p><img src="/2018/11/09/Redis4源码阅读学习-1/2.png" alt="Image text"><br>   SAVE命令会阻塞redis的服务器进程，直到RDB文件创建完毕为止。在阻塞过程中，server不能处理任何请求    saveCommand-&gt;rdbSave-&gt;rdbSaveRio-&gt;rdbSaveKeyValuePair<br>   REDIS // RDB协议约束的固定字符串<br>   0006 // redis的版本<br>   FE 00 // 表示当前接下来的key都是db=0中的key;<br>   FC 1506327609 // 表示key失效时间点为1506327609<br>   0 // 表示key的属性是string类型<br>   username // key<br>   afei // value<br>   FF // 表示遍历完成<br>   y73e9iq1 // checksum  , CRC64</p><p>   <img src="/2018/11/09/Redis4源码阅读学习-1/3.jpeg" alt="Image text"><br>   BGSAVE则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。<br>   fork()系统调用我们可以创建一个和当前进程一样的新进程，继承了父进程的整个地址空间,其中包括了进程上下文,堆栈地址,内存信息进程控制块<br>   bgsaveCommand-&gt;rdbSaveBackground-&gt; rdbSave<br>   <a href="https://blog.codingnow.com/2011/01/fork_multi_thread.html" target="_blank" rel="noopener">fork危害，多进程的多线程程序</a><br>   自动执行bgsave，配置redis.conf  </p><h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>   save 900 1<br>   save 300 10<br>   save 60 10000<br>   只要这三个条件中的任意一条符合，那么服务器就会执行BGSAVE。配置保存在 redisServer saveparam中，serverCron中判断执行<br>   rdb加载，loadDataFromDisk -&gt; rdbLoad（），阻塞</p><ol start="2"><li><p>aof记录服务器所处理的所有的除查询意外的操作，以文本的方式记录<br>原理是：处理文件事件执行写命令，使得命令被追加到aof_buf中，，然后在处理时间事件执行serverCron函数会调用flushAppendOnlyFile函数进行文件的写入和同步。<br> appendonly yes<br> appendfilename “appendonly.aof”<br> appendfsync everysec<br> always：将aof_buf中的所有内容写入并同步到aof文件。<br> everysec：将aof_buf中的所有内容写入到aof文件，如果上次同步的时间距离现在超过1s，那么对aof文件进行同步，同步操作由一个线程专门负责执行<br> no：将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，同步有操作系统执行。</p><p> aof流程主要函数：<br> //函数1：将command写入aof_buff  propagate-&gt; feedAppendOnlyFile，数据修改更新到AOF缓存中<br> //函数2：启动子进程，后台用于整理aof的数据 serverCron-&gt; rewriteAppendOnlyFileBackground<br> //函数3：刷一遍server.db[16],依次将对象写入磁盘临时文件tmpfile，rewriteAppendOnlyFile -&gt;rewriteAppendOnlyFileRio<br> //函数4：将aof_buff内容持久化flushAppendOnlyFile<br> //函数5：将backgroundRewriteDoneHandler 更新子进程同步期间产生的修改</p><p><img src="https://img-blog.csdn.net/20160503161237360" alt="Image text">   </p><p> aof_rewrite 解决AOF文件体积膨胀的问题<br> 触发条件  </p><ol><li>被动： 当AOF文件尺寸超过conf：auto-aof-rewrite-min-size 64mb &amp; 达到一定增长比，<br>指当前aof文件比上次重写的增长比例大小 auto-aof-rewrite-percentage 100； </li><li>主动： 调用BGREWRITEAOF命令；<br><img src="https://img-blog.csdn.net/20160503161309698" alt="Image text"><br>对应bgrewriteaofCommand逻辑  </li></ol></li><li><p>混合持久化 conf aof-use-rdb-preamble no， aof rewrite 的时候就直接把 rdb 的内容写到 aof 文件开头     </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |          RDB           |   </span><br><span class="line">            |         FORMAT         |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |        AOF             |   </span><br><span class="line">            |       FORMAT           |   </span><br><span class="line">            +------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">       <span class="keyword">int</span> error;</span><br><span class="line">       <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">           errno = error;</span><br><span class="line">           <span class="keyword">goto</span> werr;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>rdb优缺点：二进制文件，速度快，存在数据丢失，性能消耗低<br>aof优缺点：数据丢失小，性能消耗大，4.0管道优化相对好些<br>混合持久化：加载速度快，避免丢失数据</p><p>###事故案例：陌陌争霸<br>32 个数据仓库部署到 4 台物理机上即可，每台机器上启动 8 个 Redis 进程。使用 64G 内存的机器，后来增加到了 96G 内存。实测每个 Redis 服务会占到 4~5 G 内存，四台配置相同的从主机进行主从备份。  </p><p>事故1：有一台数据服务主机无法被游戏服务器访问到，影响了部分用户登陆，运维维护时发现，一台从机的内存耗尽，导致了从机的数据库服务重启。在从机重新对主机连接，8 个 Redis 同时发送 SYNC 的冲击下，把主机击毁了。<br>问题1：从主机为什么出现内存不足<br>原因：redis 服务同时做 BGSAVE，概率性 ，而导致 fork 多个进程需要消耗太多内存<br>问题2：重新进行 SYNC 操作会导致主机过载<br>原因：重启后，8 个 slave redis 同时开启同步，等于瞬间在主机上 fork 出 8 个 redis 进程<br>解决方案：取消主从，脚本控制bgsave</p><p>事故2:内存内存不足<br>原因：定期备份redis数据库文件，拷贝数据库文件时，系统使用大量的内存做为cache，释放不及时，脚本控制bgsave，内存不住，使用交换分区，脚本保证30分钟内必须执行一次bgsave</p><p>思考：1.备份方案的选择。2.使用leveldb做redis的持久化存储 3.redis内存上限设置一半  </p><p>#hyperloglog.c</p><p>##在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</p><p>##看到第一句话就知道这个已经完全没有了解的必要了，逆天的算法，用于比如ip访问数的基数统计。</p><p>##+ 动态字符串 sds.h和sds.c </p><p>##+ 双端链表 adlist.c和adlist.h </p><p>##+ 字典 dict.h和dict.c </p><p>##+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。 </p><p>##+intset.c和intset.h</p><ol><li>intset 是一种有序的整型集合，共有 <code>INTSET_ENC_INT16</code>、<code>INTSET_ENC_INT32</code>、<code>INTSET_ENC_INT64</code> 编码类型。</li><li>intset <code>length</code> 属性记了录集合的大小。</li><li>intset 内部采用<code>二分查找算法</code> 定位元素。</li><li>intset 只会升级，不会降级。当将一个高位元素添加到低编码集合时，此时，需要对集合进行升级。</li></ol><p>##这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。</p><p>##ziplist.c和ziplist.h</p><ol><li>实在是不想看实现了，估计也看不懂，看名字就知道是一种极节内存内存的链表，redis是内存性数据库，肯定还是要能省则省，代码肯定是有的，肯定是性能稍微差一点，但是应该差的不多，大神撸出来的东西是不用有任何怀疑的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zmalloc-c&quot;&gt;&lt;a href=&quot;#zmalloc-c&quot; class=&quot;headerlink&quot; title=&quot;zmalloc.c&quot;&gt;&lt;/a&gt;zmalloc.c&lt;/h2&gt;&lt;h2 id=&quot;tcmalloc&quot;&gt;&lt;a href=&quot;#tcmalloc&quot; class=&quot;
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://yoursite.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c，数据库，缓存，redis" scheme="http://yoursite.com/tags/c%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>ssl pinning</title>
    <link href="http://yoursite.com/2017/10/01/ssl-pinning/"/>
    <id>http://yoursite.com/2017/10/01/ssl-pinning/</id>
    <published>2017-10-01T00:59:58.000Z</published>
    <updated>2019-04-09T06:08:53.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssl-pinning-mode"><a href="#ssl-pinning-mode" class="headerlink" title="ssl pinning mode"></a>ssl pinning mode</h1><p>https抓包的问题，工作的一个小争论引发的，不相信https可以抓包分析数据，非要我演示一次。https抓包其实早就已经烂大街，本着用事实说话的方式，安装了Charles，发现竟然有部分如淘宝，支付宝的包无法解析，jd的是正常的，好奇的查了一下，才知道现在有ssl pinning mode这个东西。</p><h2 id="简述一下https的连接过程"><a href="#简述一下https的连接过程" class="headerlink" title="简述一下https的连接过程"></a>简述一下https的连接过程</h2><p><img src="/2017/10/01/ssl-pinning/1.gif" alt></p><h3 id="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"><a href="#上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。" class="headerlink" title="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"></a>上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。</h3><p>1、client hello和 server hello表示双方要建立一个加密会话。</p><p>2、服务器把数字证书传输给客户端，证书中包含服务器公钥，客户端用公钥解析证书中的数字签名，可以验证服务器的身份。</p><p>3、Server Hello Done表示hello 流程结束。</p><p>4、客户端生成一个对称加密密钥，用于实际数据的加密传输，并用服务器的公钥加密，把对生成的密钥传递给服务器。同时携带一个用刚刚生成的加密密钥加密的“client finished”。</p><p>5、服务器收到对称加密密钥，并尝试用该密钥解密加密字段，如能得到明文“client finished”，认为该密钥有效，可以用于之后的数据加密传输。同时用该密钥加密“server finished”，传递给客户端。</p><p>6、客户端用对称机密密钥解密，如能得到明文“server finished”，客户端认为该服务器已经正确的接收到对称密钥。</p><p>7、加密数据传输开始。</p><blockquote><p>虚线部分是服务器端要求验证客户身份,和双向认证有关。</p></blockquote><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ol><li>内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。 </li><li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持 </li><li>数据完整性。防止内容被第三方冒充或者篡改。</li></ol><h3 id="带来的问题：中间人攻击（MITM）"><a href="#带来的问题：中间人攻击（MITM）" class="headerlink" title="带来的问题：中间人攻击（MITM）"></a>带来的问题：中间人攻击（MITM）</h3><p><img src="/2017/10/01/ssl-pinning/2.jpeg" alt></p><ol><li>客户端首先要向远程的服务器发送建立连接的请求，并带有自己的支持的加解密的方式级别，这个过程经过了中间人的窃听，中间人把消息修改后发给了真正的目的地——服务端</li><li>服务端收到了要建立https链接的请求后，会发送当时从证书签发机构签发的公钥证书。这个过程中中间人又窃听了，然后中间人替换上自己的证书后又转发给了客户端。</li><li>客户端收到了中间人发过来的公钥证书，验证证书的真伪，并产生随机的对称加密的密钥，用中间人发的公钥加密后发给了中间人。由于刚才客户端收到的公钥证书本身就是中间人产生的，所以中间人用相应的私钥就解开了，拿到了客户端产生的那个随机产生的对称加密密钥。中间人再用刚才服务端返回的公钥证书加密这个客户端产生的用来对称加密的密钥，发给服务端。</li><li>服务端收到了当时用自己下发的公钥的证书加密的对称加密密钥，用自己的私钥解密，也得到了对称加密的密钥。</li></ol><blockquote><p>用Charles来搞是比较常见的，网上的教程也是一把一把的，大部分https的数据包都的可以解析出来，但是阿里系的不行。</p></blockquote><h3 id="解决中间人攻击的办法：ssl-pinning-mode"><a href="#解决中间人攻击的办法：ssl-pinning-mode" class="headerlink" title="解决中间人攻击的办法：ssl pinning mode"></a>解决中间人攻击的办法：ssl pinning mode</h3><ol><li>简单点说就是：ssl pinning就是client能够把server的证书和一个已知的server的证书的拷贝做对比，通过把server的ssl 证书捆绑到程序中就可以达到目的</li><li>如果还是想获取接口请求参数估计只能从客户端逆向入手了，类似于iOS上的Snoop-it一类的工具，网上实际上也有很完整的解决方案了，实际上就是hook的方式将此次校验的结果返回true或者干脆不让其做校验，前提是手机一定要越狱，开源<a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">方案地址</a>，具体原理可以<a href="https://nabla-c0d3.github.io/blog/2016/02/21/ssl-kill-switch-twitter/" target="_blank" rel="noopener">参考</a>。</li><li>其实做到https+强制pinning就很少有人搞的动了，还担心就加上双向认证，关键还有就是客户端的代码质量。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ssl-pinning-mode&quot;&gt;&lt;a href=&quot;#ssl-pinning-mode&quot; class=&quot;headerlink&quot; title=&quot;ssl pinning mode&quot;&gt;&lt;/a&gt;ssl pinning mode&lt;/h1&gt;&lt;p&gt;https抓包的问题，工作的
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ssl" scheme="http://yoursite.com/tags/ssl/"/>
    
      <category term="https" scheme="http://yoursite.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Android Facede</title>
    <link href="http://yoursite.com/2016/08/01/Android-Facede/"/>
    <id>http://yoursite.com/2016/08/01/Android-Facede/</id>
    <published>2016-08-01T00:59:58.000Z</published>
    <updated>2019-04-09T07:59:46.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android外观模式的应用"><a href="#Android外观模式的应用" class="headerlink" title="Android外观模式的应用"></a>Android外观模式的应用</h1><pre><code>这是一个`app`最初的项目结构  </code></pre><p><img src="/2016/08/01/Android-Facede/1.png" alt></p><p>所有的页面都放在<code>activities</code>，自定义<code>view</code>放在<code>widget</code>，网络相关的封装在<code>network</code>，所有工具类放在<code>utils</code>，少数的<code>xxxManager</code>单例藏在某个包下面，因为少没必要过度提炼就这样吧…<br>没什么问题，项目上线！  </p><p>随着项目迭代，越来越多的页面来了，数据库的表也多起来了，工具类更是爆炸性增长，还不排除有些工具类还在<code>activity</code>里面没来得及提炼出来，<code>xxxManager</code>散落一地，<code>callback</code>到处都是…各个包的类都在快速增长</p><p>如果用线来表示相互间的调用，那么整个项目就是一个毛线团，找代码都开始难找了<br>那么这时候就改理一理这个线团了</p><p>之前app没有一个明确的职责分层，横向依赖很严重，小改伤筋动骨</p><h5 id="AppContext与外观模式的应用"><a href="#AppContext与外观模式的应用" class="headerlink" title="AppContext与外观模式的应用"></a>AppContext与外观模式的应用</h5><p>随着业务的发展，<code>app</code>里面的组件，业务线也会逐渐的增多。<br>每个业务线一个<code>module</code>，那么新的问题就来了，<code>module</code>之间的通信问题，横向依赖问题。  </p><p>每个<code>module</code>除了在自己的地盘处理业务，还有可能给其他module提供服务，或者这个<code>module</code>就是一个<code>plugin</code>风格的业务组件。<br>比较粗暴的做法，直接引用<code>module</code>，想调谁就引用谁，那么这和之前单<code>module</code>，类的横向引用又有什么本质上的区别呢？<br>这里我们可以借鉴下<code>Android</code>的<code>Context</code>类的设计，<code>Context</code>就是封装了一大堆<code>Android</code>的子系统（通过<code>getSystemService</code>获取），处理在Android环境下的通信问题。<br>那么我们可以依葫芦画瓢的设计一个我们自己的<code>AppContext</code>，我们的业务<code>module</code>或者组件都是在<code>AppContext</code>环境下，他们之间的通信就通过<code>AppContext</code>，具体业务就交给具体的<code>modul</code>e实现.<br>如果设计多个业务<code>module</code>的协作，那么也应该由<code>AppContext</code>屏蔽协作的细节，这是一个很典型的外观模式的应用。<br>在面向对象编程范式内，很多问题都可以通过引入额外的一层来解决<br><img src="/2016/08/01/Android-Facede/2.png" alt>  </p><p>有些基础组件<code>module</code>或通用性非常高的<code>module</code>，可以下沉到<code>AppContext</code>下面</p><p><code>AppContext</code>的核心职责就是封装好<code>app</code>所用到的子系统（审视下以前代码里面的单例<code>manager</code>，思考一下他是不是能作为<code>app</code>的一个子系统工作）来统一管理服务，无论该服务是基于<code>Android</code>，还是业务<code>module</code>，还是其他第三方组件。当然这里也应该<code>module</code>与<code>app</code>通信，一些app级别的配置也可以在这里处理</p><p>在实际操作中，一定要渐进式的处理，主要是因为：</p><ul><li>互联网时代不能让飞机停下来，做到在天上就给飞机动了手术</li><li>可以逐渐验证自己的方案，不要一开始就置自己于险境</li></ul><blockquote><p>比如目前工程中moduleA直接依赖moduleB调用接口，重构过程中不必直接取消依赖（不要影响目前的业务），在AppContext中添加一个moduleB的service，这个service代理moduleB提供的接口服务，然后moduleA调用接口逐渐的转向AppContext提供的方式，当转得差不多的时候就断掉moduleA与moduleB之间的依赖。</p></blockquote><p>对于有些业务线的<code>module</code>，完全可以把他当做一个app来对待  </p><p><img src="/2016/08/01/Android-Facede/3.png" alt>  </p><h5 id="AppContext只是解决了module之间的通信或者是子系统的管理"><a href="#AppContext只是解决了module之间的通信或者是子系统的管理" class="headerlink" title="AppContext只是解决了module之间的通信或者是子系统的管理"></a>AppContext只是解决了module之间的通信或者是子系统的管理</h5><blockquote><p>由多收缩到一的问题（统一依赖AppContext），只限于单进程，还没有跨进程，跨app，关于跨进程local，remote的问题，另开一贴讲设计思路与实现</p></blockquote><p>一个<code>App</code>除了通信，还有一些工具类，一些的<code>style</code>，<code>theme</code>，<code>resource</code>相关的定义。  </p><p>很多<code>app</code>都会搞一个类似<code>core</code>，<code>common</code>的<code>module</code>，一股脑儿的扔里面，这玩意儿到后面绝对是一锅东北菜，乱炖的感觉。  </p><p>对于<code>module</code>层级下面的<code>util</code>，只能是高度通用的<code>util</code>才放到下面，命名一定要体现其具体功能，千万不要直接<code>utils</code>，<code>StringUtils</code>等很模糊的命名，推荐<code>Logger</code>，<code>DeviceUtil</code>，<code>UrlUtil</code>等一眼就能看出其具体功能的<code>util</code>。  </p><p>对于<code>resource</code>相关的定义，单独一个<code>module</code><br>这些<code>module</code>都会逐渐沉淀下来，以后<code>app</code>按需依赖.<br><img src="/2016/08/01/Android-Facede/4.png" alt><br>黑线一下的就是业务线开发的基础，是不是有点类似<code>android.jar</code>的感觉</p><h4 id="UserCase"><a href="#UserCase" class="headerlink" title="UserCase"></a>UserCase</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">人之所以聪明，是因为人会创造工具并使用</span><br><span class="line"></span><br><span class="line">重构的基础是人员，如何照顾开发的情绪，如何渐进式的进行重构，</span><br><span class="line">如何借助工具进行重构，重构不等于重写，重构不等于业务都给我停下让路</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android外观模式的应用&quot;&gt;&lt;a href=&quot;#Android外观模式的应用&quot; class=&quot;headerlink&quot; title=&quot;Android外观模式的应用&quot;&gt;&lt;/a&gt;Android外观模式的应用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;这是一个`app`最初的项目
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>libco</title>
    <link href="http://yoursite.com/2016/04/08/libco/"/>
    <id>http://yoursite.com/2016/04/08/libco/</id>
    <published>2016-04-08T14:39:02.000Z</published>
    <updated>2019-04-09T06:20:24.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="co-create-初始化相关"><a href="#co-create-初始化相关" class="headerlink" title="co_create  初始化相关"></a>co_create  初始化相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,</span><br><span class="line">   pfn_co_routine_t pfn,void *arg )</span><br><span class="line"></span><br><span class="line">static stCoRoutineEnv_t* g_arrCoEnvPerThread[ 204800 ] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">void co_init_curr_thread_env()</span><br></pre></td></tr></table></figure><ol><li><p>将Env_t信息保存在全局变量g_arrCoEnvPerThread中对应于threadId的位置</p></li><li><p>创建一个空协程，被设置为当前Env_t的main routine，用于运行该线程的主逻辑</p></li><li><p>Epoll_t相关的信息初始化，管理时间片相关</p></li><li><p>stCoRoutine_t 保存每个协程的信息</p></li></ol><ol><li><p>co_create_env</p><p>创建协程的函数是co_create_env()，每个协程有自己密切相关的结构stCoRoutine_t</p></li><li><p>支持共享栈</p><p>所以共享栈采用的方式就是每次发生协程切换的时候，把实际用到的栈内容stack_bp   stack_sp通过save_stack_buffer来保存到malloc的内存中去，然后调用coctx_swap进行寄存器信息的切换，再把切换进来的新协程之前以相同方式保存的栈数据再拷贝到上面的共享栈空间的对应的内存位置上去(栈指针在coctx_swap已经更新完了，这里只是填补数据的作用，而且每个协程切换前后一直使用相同的共享栈，即使有局部指针也没有问题)，从而大大增加了内存的利用效率。</p></li></ol><h2 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h2><p>协程 = 回调 + 栈内存</p><p>协程执行实际是协程的切换，包括协程上下文（寄存器状态）的切换，回调执行之后会再次切换回来</p><p>如果协程中创建了新的协程，则会有嵌套的协程切换</p><p>co_resume</p><p>同时创建的协程第一次启动也是使用这个接口，并且在第一次启动的时候会初始化特殊的coctx_t结构，在协程执行结束后，会自动设置cEnd=1，同时将自己yield出去</p><p>栈帧stack frame layout：</p><p><img src="/2016/04/08/libco/illustration-1.png" alt></p><p>调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2</p><p><img src="/2016/04/08/libco/illustration-2.png" alt></p><p>libco程序的第一个协程呢，假如第一个协程yield时，CPU控制权让给谁呢？关于这个问题，我们首先要明白这“第一个”协程是什么。实际上，libco的第一个协程，即执行main函数的协程，是一个特殊的协程。这个协程又可以称作主协程，它负责协调其他协程的调度执行（后文我们会看到，还有网络 </p><p>I/O以及定时事件的驱动），它自己则永远不会yield，不会主动让出 </p><p>CPU。不让出CPU，不等于说它一直霸占着CPU。我们知道CPU执行权有两种转移途径，一是通过yield让给调用者，其二则是resume启动其他协程运行。</p><h4 id="阻塞调用Hook"><a href="#阻塞调用Hook" class="headerlink" title="阻塞调用Hook"></a>阻塞调用Hook</h4><p>通过glibc中dlfcn.h的dlsym和RTLD_NEXT结合起来，从而给标准库函数添加钩子</p><p>#define HOOK_SYS_FUNC(name) if( !g_sys_##name##_func ) { g_sys_##name##_func = (name##_pfn_t)dlsym(RTLD_NEXT,#name); }</p><p>epoll 基于事件驱动的IO多路复用技术，1. mmap，2. 红黑树，33. rdlist</p><p><strong>int</strong> <strong>epoll_create(**</strong>int<strong> </strong>size);**</p><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p><p>epoll的事件注册函数 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p><p>等待事件的产生</p><h4 id="协程的事件管理"><a href="#协程的事件管理" class="headerlink" title="协程的事件管理"></a>协程的事件管理</h4><ol><li><p>初始化 AllocEpoll</p></li><li><p>添加监听事件 co_poll</p></li><li><p>轮询 co_eventloop</p></li></ol><h4 id="感受"><a href="#感受" class="headerlink" title="感受:"></a>感受:</h4><blockquote><p>总体代码质量并不是特别好，总感觉为了使用C++而使用C++，甚至有些命名都不是 特别规范，最好理解的协程库还是云风c语言版本的，强力推荐，libco最大的优势就是作为微信内部框架的底层库，在线上也承受了巨大的流量，稳定跑到几千台服务器上，其他的都不重要。</p></blockquote><p>libco github ：<a href="https://github.com/Tencent/libco" target="_blank" rel="noopener">地址</a></p><p>云风 github： <a href="https://github.com/cloudwu/coroutine/" target="_blank" rel="noopener">地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;co-create-初始化相关&quot;&gt;&lt;a href=&quot;#co-create-初始化相关&quot; class=&quot;headerlink&quot; title=&quot;co_create  初始化相关&quot;&gt;&lt;/a&gt;co_create  初始化相关&lt;/h2&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://yoursite.com/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="协程" scheme="http://yoursite.com/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--智能指针</title>
    <link href="http://yoursite.com/2014/08/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://yoursite.com/2014/08/09/c-11学习笔记-智能指针/</id>
    <published>2014-08-09T10:14:25.000Z</published>
    <updated>2019-04-09T10:28:28.110Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常高，很多地方都会使用到，只存在一份拷贝显然是最好的，这个时候对象生命周期的管理就会很复杂，所以c++引入了智能指针。</p><p>任何事物都会有两面性。</p></blockquote><h2 id="Shared-ptr"><a href="#Shared-ptr" class="headerlink" title="Shared_ptr"></a>Shared_ptr</h2><h3 id="摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）"><a href="#摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）" class="headerlink" title="摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）"></a>摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;construct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    ~Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;destruct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int priority()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;22222&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processWidget(int priority,std::shared_ptr&lt;Widget&gt; pw)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;111111&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    processWidget(priority(),std::shared_ptr&lt;Widget&gt;(new Widget));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processWidget运行的过程应该是</p><ol><li><p>New Widget</p></li><li><p>shared_ptr constructor</p></li><li><p>Priority()</p></li></ol><p>我在llvm上测试的结果也是这个执行顺序</p><p>也许某些编译器上可能执行的顺序是</p><ol><li><p>New Widget</p></li><li><p>Priority() //发生异常</p></li><li>shared_ptr constructor</li></ol><p>就有可能有内存泄露</p><blockquote><p><strong>所以最好的办法还是应该把new widget提到外面来写，所以好的编码习惯很重要。</strong></p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BPtr b;</span><br><span class="line">    ~A () &#123;</span><br><span class="line">         cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    APtr a;</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b; // 1</span><br><span class="line">    b-&gt;a = a; // 2</span><br><span class="line">    </span><br><span class="line">     cout &lt;&lt; &quot;over!!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr"><a href="#要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr" class="headerlink" title="要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr"></a>要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line"></span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line">typedef std::weak_ptr&lt;A&gt; AWeakPtr;</span><br><span class="line">typedef std::weak_ptr&lt;B&gt; BWeakPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BWeakPtr b; // 注意这里</span><br><span class="line">    ~A () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    AWeakPtr a; // 注意这里</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两种指针其实和oc里面的 strong, weak非常相识。</p><p> weak_ptr的另外一种用法</p><p>使用情景：当类对象被 shared_ptr 管理时，需要在类自己定义的函数里把当前类对象作为参数传给其他函数时，这时需要传递一个 shared_ptr ，否则就不能保持 shared_ptr 管理这个类对象的语义（因为有一个 raw pointer 指向这个类对象，而 shared_ptr 对类对象的这个引用没有计数，很有可能 shared_ptr 已经把类对象资源释放了，而那个调用函数还在使用类对象——显然，这肯定会产生错误）。《摘录：<a href="http://blog.csdn.net/zhongguoren666/article/details/8617436》" target="_blank" rel="noopener">http://blog.csdn.net/zhongguoren666/article/details/8617436》</a></p><p>直接看官网的例子吧：</p><p>《<a href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Good: std::enable_shared_from_this&lt;Good&gt;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; getptr() &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bad</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CObj: public std::enable_shared_from_this&lt;CObj&gt; &#123;</span><br><span class="line">    friend class CObjMgr;</span><br><span class="line">protected:</span><br><span class="line">    CObj() &#123;&#125;   // 只有CObjMgr可以创建与删除</span><br><span class="line">    ~CObj()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // Good: the two shared_ptr&apos;s share the same object</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1(new Good);</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;gp2.use_count() = &quot; &lt;&lt; gp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    </span><br><span class="line">    // Bad, each shared_ptr thinks it&apos;s the only owner of the object</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad);</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; // UB: double-delete of Bad</span><br></pre></td></tr></table></figure><ol><li>绝对不能在构造函数中调用shared_from_this()</li></ol><p>​      因为shared_ptr里面初始化enable_shared_from_this的成员weak_ptr，      这个时候weak_ptr还是空值。</p><ol start="2"><li>为什么内部不能用this指针</li></ol><p>​      因为我们程序中用shared_ptr来管理指针，如果我们在类的内部传递的过程中用原始指针，这样类内部的引用shared_ptr不会察觉到，因为有可能我们传进去的时候已经被shared_ptr释放掉了</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><blockquote><p>相对就要单纯许多了，unique_ptr“唯一”拥有其所指对象，只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p></blockquote><h3 id="代替普通指针"><a href="#代替普通指针" class="headerlink" title="代替普通指针"></a>代替普通指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo()  </span><br><span class="line">&#123;//不安全的代码  </span><br><span class="line">    X *px = new X;  </span><br><span class="line">    // do something, exception may occurs  </span><br><span class="line">delete px; // may not go here     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unique_ptr&lt;X&gt; px(new X);</span><br></pre></td></tr></table></figure><h3 id="在函数中返回对象"><a href="#在函数中返回对象" class="headerlink" title="在函数中返回对象"></a>在函数中返回对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;X&gt; foo()  </span><br><span class="line">&#123;  </span><br><span class="line">    unique_ptr&lt;X&gt; px(new X);  </span><br><span class="line">    // do something  </span><br><span class="line">    return px; //移动语义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="放入容器中"><a href="#放入容器中" class="headerlink" title="放入容器中"></a>放入容器中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“1111”&#125;, new string&#123;“2222”&#125;，new string&#123;“3333”&#125;  &#125;;  </span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; test(new string(&quot;11111&quot;));  </span><br><span class="line">v.push_back(std::move(test));//使用移动语法</span><br></pre></td></tr></table></figure><h3 id="支持直接持有数组"><a href="#支持直接持有数组" class="headerlink" title="支持直接持有数组"></a>支持直接持有数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],</span><br><span class="line">    [](int* p)&#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;);</span><br><span class="line">//或者使用helper</span><br><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--Lambda 表达式（对比测试Lambda ，bind，Function Object）</title>
    <link href="http://yoursite.com/2014/08/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95Lambda-%EF%BC%8Cbind%EF%BC%8CFunction-Object%EF%BC%89/"/>
    <id>http://yoursite.com/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/</id>
    <published>2014-08-09T10:02:37.000Z</published>
    <updated>2019-04-09T10:07:37.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。</p><p>还是直接看对比栗子吧，抄袭的是msdn的官网</p><p>该示例使用 for_each 函数调用中嵌入的 lambda 向控制台打印 vector 对象中的每个元素是偶数还是奇数。</p></blockquote><h3 id="使用lambda"><a href="#使用lambda" class="headerlink" title="使用lambda"></a>使用lambda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">   // Create a vector object that contains 10 elements.</span><br><span class="line">   vector&lt;int&gt; v;</span><br><span class="line">   for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">      v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Count the number of even numbers in the vector by </span><br><span class="line">   // using the for_each function and a lambda.</span><br><span class="line">   int evenCount = 0;</span><br><span class="line">   for_each(v.begin(), v.end(),[&amp;evenCount] (int n) &#123;</span><br><span class="line">      cout &lt;&lt; n;</span><br><span class="line">      if (n % 2 == 0) &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">         ++evenCount;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // Print the count of even numbers to the console.</span><br><span class="line">   cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Function-Object"><a href="#使用Function-Object" class="headerlink" title="使用Function Object"></a>使用Function Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(int&amp; evenCount) </span><br><span class="line">        : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">            ++m_evenCount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line"></span><br><span class="line">    int&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    // Create a vector object that contains 10 elements.</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Count the number of even numbers in the vector by </span><br><span class="line">    // using the for_each function and a function object.</span><br><span class="line">    int evenCount = 0;</span><br><span class="line">    for_each(v.begin(), v.end(), FunctorClass(evenCount));</span><br><span class="line"></span><br><span class="line">    // Print the count of even numbers to the console.</span><br><span class="line">    cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正如微软文档所言，这两种在效率上并没有实质性的差距，我自己也测试了，不管在debug模式下还是release模式下，果然没有差距。</p><p>无意中我在晚上发现了bind和Lambda对比测试，前三种方式是网上的，后面两种是我自己加的，结果绝对让我蛋碎了一地。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdint&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(uint64_t&amp; evenCount)</span><br><span class="line">    : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">         m_evenCount += n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line">    </span><br><span class="line">    uint64_t&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef std::chrono::high_resolution_clock clock;</span><br><span class="line">    typedef clock::time_point                  time_point;</span><br><span class="line">    typedef clock::duration                    duration;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    timer()</span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void reset()</span><br><span class="line">    &#123;</span><br><span class="line">        _starttime = clock::now();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    duration elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">        return clock::now() - _starttime;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    time_point _starttime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool test_timer()</span><br><span class="line">&#123;</span><br><span class="line">    using std::chrono::milliseconds;</span><br><span class="line">    typedef timer::duration duration;</span><br><span class="line">    </span><br><span class="line">    const milliseconds sleep_time(500);</span><br><span class="line">    </span><br><span class="line">    timer t;</span><br><span class="line">    std::this_thread::sleep_for(sleep_time);</span><br><span class="line">    duration recorded = t.elapsed();</span><br><span class="line">    </span><br><span class="line">    // make sure the clock and this_thread::sleep_for is precise within one millisecond (or at least in agreement as to</span><br><span class="line">    // how inaccurate they are)</span><br><span class="line">    return (recorded - milliseconds(1) &lt; sleep_time)</span><br><span class="line">    &amp;&amp; (recorded + milliseconds(1) &gt; sleep_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void volatile_write(const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    volatile T* p = new T;</span><br><span class="line">    *p = x;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void run_test(const std::string&amp; name, Function func)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line">    timer t;</span><br><span class="line">    volatile_write(func());</span><br><span class="line">    timer::duration duration = t.elapsed();</span><br><span class="line">    std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; duration.count() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void do_test_loop(Function func, const uint64_t upper_limit = 100000000ULL)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t i;</span><br><span class="line">    for (i = 0; i &lt; upper_limit; ++i)</span><br><span class="line">        func(i);</span><br><span class="line">    if(i == upper_limit)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = [&amp;x] (uint64_t i) &#123; x += i;</span><br><span class="line"> &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_accumulate_bind_function(uint64_t&amp; x, uint64_t i)</span><br><span class="line">&#123;</span><br><span class="line">    x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_class_function()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line"></span><br><span class="line">    do_test_loop(FunctorClass(x));</span><br><span class="line">   // for_each(v.begin(), v.end(), FunctorClass(x));</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind_auto()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">uint64_t test_accumulate_boost_bind()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    </span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = boost::bind(&amp;test_accumulate_bind_function, boost::ref(x), _1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_boost_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!test_timer())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed timer test.&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run_test(&quot;Accumulate (lambda)            &quot;, &amp;test_accumulate_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (bind)              &quot;, &amp;test_accumulate_bind);</span><br><span class="line">    run_test(&quot;Accumulate (bound lambda)      &quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (Function Object)    &quot;, &amp;test_accumulate_class_function);</span><br><span class="line">    run_test(&quot;Accumulate (bind auto)    &quot;, &amp;test_accumulate_bind_auto);</span><br><span class="line">#if USE_BOOST</span><br><span class="line">    run_test(&quot;Accumulate (boost bind)        &quot;, &amp;test_accumulate_boost_bind);</span><br><span class="line">    run_test(&quot;Accumulate (boost bound lambda)&quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debug模式："><a href="#debug模式：" class="headerlink" title="debug模式："></a>debug模式：</h3><p><strong>Accumulate (lambda)            100000000  422885105</strong></p><p><strong>Accumulate (bind)              100000000   4346676523</strong></p><p><strong>Accumulate (bound lambda)      100000000 1707092933</strong></p><p><strong>Accumulate (class function)    100000000   494674507</strong></p><p><strong>Accumulate (bind auto)         100000000 3381097610</strong></p><h3 id="Release模式"><a href="#Release模式" class="headerlink" title="Release模式"></a>Release模式</h3><p><strong>Accumulate (lambda)            100000000  17978</strong></p><p><strong>Accumulate (bind)              100000000   607188485</strong></p><p><strong>Accumulate (bound lambda)      100000000 520421500</strong></p><p><strong>Accumulate (Function Object)    100000000  1925</strong></p><p><strong>Accumulate (bind auto)         100000000 1726</strong></p><blockquote><p>编译器：APPLE LLVM5.1</p><p>c++就是这样让人蛋疼，随便一个东西，初学者都可以写5中写法，那大神下，至少可以写10种以上，效率上的差距也是大的惊人，我还是那句话c++应该做减法了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。&lt;/p&gt;
&lt;p&gt;还是直接看对比栗子吧，抄袭的是msdn的官网&lt;/p&gt;
&lt;p&gt;该示例使用 for_each 函数调用中嵌入的 lambda 向控制
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--右值引用和移动构造语义</title>
    <link href="http://yoursite.com/2014/06/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%AF%AD%E4%B9%89/"/>
    <id>http://yoursite.com/2014/06/09/c-11学习笔记-右值引用和移动构造语义/</id>
    <published>2014-06-09T09:42:12.000Z</published>
    <updated>2019-04-09T10:12:57.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"><a href="#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。" class="headerlink" title="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"></a>今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const char* rhs)            // 普通赋值构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const myStr&amp; rhs)             // 拷贝构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs.str_);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str copy constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(myStr&amp;&amp; rhs)</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(rhs);</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str move constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~myStr()                          // 析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        if (!str_) return;</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str destructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">        delete [] str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const myStr&amp; operator=(myStr rhs)   // 赋值操作符重载</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.swap(*this);            // 使用copy-and-swap惯用法获得数据</span><br><span class="line">        return (*this);             // 避免重复撰写operator=</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void swap(myStr&amp; rhs)             // 交换算法</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(str_, rhs.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operator char*(void) const</span><br><span class="line">    &#123;</span><br><span class="line">        return str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr&amp; operator+=(const char* rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs) strcat(str_, rhs);</span><br><span class="line">        return (*this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行下面的代码"><a href="#执行下面的代码" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myStr ss(&quot;000&quot;);</span><br><span class="line">    myStr s1(&quot;11111&quot;), s2(&quot;22222&quot;), s3(&quot;3333333&quot;), s4(&quot;4444444&quot;);</span><br><span class="line">    cout &lt;&lt; std::endl;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line">    </span><br><span class="line">    const long long max = 30000000;</span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i&lt;max; i++) &#123;</span><br><span class="line">        ss = s1 + s2 + s3 + s4;</span><br><span class="line">    &#125;</span><br><span class="line">     time(&amp;timestamp2);</span><br><span class="line">    </span><br><span class="line"> timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure><h3 id="下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。"><a href="#下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。" class="headerlink" title="下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。"></a>下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再找一个例子"><a href="#再找一个例子" class="headerlink" title="再找一个例子"></a>再找一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class MemoryBlock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    // 构造器（初始化资源）</span><br><span class="line">    explicit MemoryBlock(size_t length)</span><br><span class="line">    : _length(length)</span><br><span class="line">    , _data(new int[length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 析构器（释放资源）</span><br><span class="line">    ~MemoryBlock()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_data != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _data;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock destructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝构造器（实现拷贝语义：拷贝that）</span><br><span class="line">    MemoryBlock(const MemoryBlock&amp; that)</span><br><span class="line">    // 拷贝that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(new int[that._length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        std::cout &lt;&lt; &quot;copy constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝赋值运算符（实现拷贝语义：释放this ＋ 拷贝that）</span><br><span class="line">    MemoryBlock&amp; operator=(const MemoryBlock&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 拷贝that对象所拥有的资源</span><br><span class="line">            _length = that._length;</span><br><span class="line">            _data = new int[_length];</span><br><span class="line">            std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动构造器（实现移动语义：移动that）</span><br><span class="line">    MemoryBlock(MemoryBlock&amp;&amp; that)</span><br><span class="line">    // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(that._data)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">        that._data = nullptr;</span><br><span class="line">        that._length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动赋值运算符（实现移动语义：释放this ＋ 移动that）</span><br><span class="line">    MemoryBlock&amp; operator=(MemoryBlock&amp;&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">            _data = that._data;</span><br><span class="line">            _length = that._length;</span><br><span class="line">            </span><br><span class="line">            // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">            that._data = nullptr;</span><br><span class="line">            that._length = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _length; // 资源的长度</span><br><span class="line">    int* _data; // 指向资源的指针，代表资源本身</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MemoryBlock f() &#123; return MemoryBlock(50); &#125;</span><br></pre></td></tr></table></figure><h3 id="执行下面的代码-1"><a href="#执行下面的代码-1" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const long long max = 100000;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line"></span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line">    for (long long i = 0; i&lt;max; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryBlock a = MemoryBlock(50);</span><br><span class="line"></span><br><span class="line">        MemoryBlock c = std::move(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time(&amp;timestamp2);</span><br><span class="line">timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure><blockquote><p>如果把MemoryBlock c = std::move(a)换成MemoryBlock c = a;</p><p>性能上大概也有30%的差距。</p><p>这就是右值引用和移动构造语义带来的好处，我理解就是以前只能引用左值，而右值是不能引用的，新语法的加入实现了右值的引用，减少了零时对象的产生销毁，但是也带来了更多怪异的语法，明显增加了c++的学习成本，如果语法设计角度，像oc一样增加类似引用计数器来管理对象，会不会更加优雅一下，至少让上层的码农不会那么累，其实通智能指针也能达到同样的效果。</p><p>这么多年了c++都在做加法，让学习，使用成本太高了，标准委员为的大爷些什么时候考虑一下做点减法呢，不要让c++那么学院派或者满地都是陷阱，也不要让实现一种技术有10种方法，但是有5种都是陷阱。靠！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。&quot;&gt;&lt;a href=&quot;#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--explicit构造函数和private</title>
    <link href="http://yoursite.com/2014/06/06/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Cprivate/"/>
    <id>http://yoursite.com/2014/06/06/c-11学习笔记-explicit构造函数和private/</id>
    <published>2014-06-06T09:58:32.000Z</published>
    <updated>2019-04-09T10:07:28.313Z</updated>
    
    <content type="html"><![CDATA[<p>某天写一个用特定数据类型才能构造的类，就习惯性的声明了一个默认的构造函数，并声明为了private，避免勿调用默认的构造函数去声明这个类。但是却收到涛哥的一封邮件，建议用explicit去申明就行了，不建议用private.</p><p>处于懒惰的习惯，我回了一个ok，今天无意中看到邮件了，发现不对，靠</p><p>还是用代码说话吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(int i)                       //带int类型构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不管我是调用    myStr s = ‘A’;还是调用    myStr s = 1；都会去调用到myStr(int i)这个构造函数，默认的做了类型转.特别是这种看上去还合理的转换，换个离谱点的myStr s = “test”,还是可以编译，也最多只是收到一个警告：Multi-character character constant，也许某些编译上不允许，或者把警告等级打高了会报错，但是这都不是我想要的转换，c++就是这样充满了各种坑的语言，</p><p>如果加上explicit，表示不允许编译器做这种转换。</p><p>总结来说就是所有单参数的构造函数都应该声明explicit，避免编译器做各种明明奇妙的类型转换。</p><p>引用effective c++：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。我鼓励你遵循相同的政策。</p><p>把默认构造函数申明为private,我认为很简单，就是要么是单例，要么就是希望只调用我提供的构造函数来声明对象。</p><p>大多数时候，我觉得更好的做法就是将拷贝构造函数和operator=(赋值操作符重载)声明成private。</p><p>禁止一个类的外部用户对这个类的对象进行复制动作，有需要的时候再去打开这些。</p><p>为什么编译器就不能提供一个默认安全封闭的类呢，当我们需要的时候再去申请各种特性。不要把类的安全都交给不靠谱的码农，大多数时候我们自己写代码的时候也不清楚自己代码的危险性。c++太相信码农了，其实大部分码农都是极度不靠谱的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某天写一个用特定数据类型才能构造的类，就习惯性的声明了一个默认的构造函数，并声明为了private，避免勿调用默认的构造函数去声明这个类。但是却收到涛哥的一封邮件，建议用explicit去申明就行了，不建议用private.&lt;/p&gt;
&lt;p&gt;处于懒惰的习惯，我回了一个ok，今
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>撸京东APP学到的</title>
    <link href="http://yoursite.com/2014/05/19/%E6%92%B8%E4%BA%AC%E4%B8%9CAPP%E5%AD%A6%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2014/05/19/撸京东APP学到的/</id>
    <published>2014-05-19T10:30:38.000Z</published>
    <updated>2019-04-09T10:42:05.942Z</updated>
    
    <content type="html"><![CDATA[<h3 id="登陆http请求："><a href="#登陆http请求：" class="headerlink" title="登陆http请求："></a>登陆http请求：</h3><p>d_model=iPhone3%2C1&amp;networkType=wifi&amp;adid=A7F435E4-9C29-4540-8AE9-4657FAD20A05&amp;st=1405680657333&amp;body=%7B%22loginname%22%3A%22softstarxy%22%2C%22loginpwd%22%3A%2211fa12f3adacd2ec366d807d4b09467a%22%7D&amp;osVersion=7.0.6&amp;d_brand=apple&amp;client=apple&amp;screen=640%2A960&amp;sv=1&amp;area=22_1930_50947_0&amp;sign=BXQbIzs8p7vKLnjcCtAwMg&amp;uuid=hjudwgohxzVu96krv%2FT6Hg%3D%3D&amp;clientVersion=3.6.1&amp;openudid=97bfb35f56b144250ce8aa0fc500c085ae5eac66&amp;partner=apple</p><p>md5加密，对于稍微复杂点的密码基本上就无解了，但是稍微简单点的密码还是可以通过彩虹表之类的东西穷举，破解还是很容易的。</p><p>所以加密两次或者混不同的机密算法应该是最安全的做法。</p><p>出于好奇，顺便测试了一下重置密码的http请求，结果，我无耻的发现自己的密码</p><p><img src="/2014/05/19/撸京东APP学到的/1.png" alt></p><h3 id="查看app内部数据保存"><a href="#查看app内部数据保存" class="headerlink" title="查看app内部数据保存"></a>查看app内部数据保存</h3><p><img src="/2014/05/19/撸京东APP学到的/2.png" alt></p><blockquote><p>用keyChain保存的敏感信息，也是用的md5加密密码，那就把keyChain数据导出来看看。。。。</p><p><a href="https://github.com/ptoomey3/Keychain-Dumper" target="_blank" rel="noopener">https://github.com/ptoomey3/Keychain-Dumper</a></p><p>Service: com.360buy.jdmobile</p><p>Account: softstarxy</p><p>Entitlement Group: SE98WUL95S.com.360buy.jdmobile</p><p>Label: com.360buy.jdmobile</p><p>Generic Field: (null)</p><p>Keychain Data: 0a053fc0987fb679965db9d099381672</p><p>保存的也是加密后的md5值，所以基本上无解，除非密码非常简单，可见任何时候稍微复杂的密码是必须的</p><p>这个方法可以看见手机里的所以wifi热点密码</p><p>需要注意的是使用Keychain-Dumper的时候需要赋予可读的权限</p><p>Jack-xiaode-iPhone:/private/var/Keychains root# chmod +r keychain-2.db</p><p>还需要给Keychain-Dumper添加执行权限</p><p>chmod +x /bin/keychain_dumper</p><p>剩下的就是</p><p>Jack-xiaode-iPhone:/private/var/Keychains root# /bin/Keychain-Dumper/keychain_dumper &gt; keychain-export.txt</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;登陆http请求：&quot;&gt;&lt;a href=&quot;#登陆http请求：&quot; class=&quot;headerlink&quot; title=&quot;登陆http请求：&quot;&gt;&lt;/a&gt;登陆http请求：&lt;/h3&gt;&lt;p&gt;d_model=iPhone3%2C1&amp;amp;networkType=wifi&amp;a
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>撸文轩APP学到的</title>
    <link href="http://yoursite.com/2014/05/13/%E6%92%B8%E6%96%87%E8%BD%A9APP%E5%AD%A6%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2014/05/13/撸文轩APP学到的/</id>
    <published>2014-05-13T10:30:38.000Z</published>
    <updated>2019-04-09T10:48:14.715Z</updated>
    
    <content type="html"><![CDATA[<p>因为我的朋友在文轩上班，那就撸一下他们公司的app</p><p><img src="/2014/05/13/撸文轩APP学到的/1.png" alt></p><p>找到要撸的app，并生成要解密的ipa</p><p> 找到这个文件，先解压再</p><p><img src="/2014/05/13/撸文轩APP学到的/2.png" alt></p><p>再用class-dump-z来导出类的信息</p><p><img src="/2014/05/13/撸文轩APP学到的/3.png" alt></p><p>现在就可以把文件导入电脑上来看看到底有些什么信息了</p><p>在看类信息之前习惯性的看看plist，很悲剧的看见了我的用户名和密码</p><p>还是明文的。。。。。突然间就有了千万只草泥马在心中奔腾</p><p><img src="/2014/05/13/撸文轩APP学到的/4.png" alt></p><p>好奇的抓包试了试，http请求也是</p><p><a href="http://auth.winxuan.com/accessToken?password=111111&amp;username=cccccc&amp;appkey=100046&amp;appsecret=16f31b66f828c1bf237db288b106ccce&quot;" target="_blank" rel="noopener">http://auth.winxuan.com/accessToken?password=111111&amp;username=cccccc&amp;appkey=100046&amp;appsecret=16f31b66f828c1bf237db288b106ccce&quot;</a>,</p><p>算了，看看class的信息</p><p>他竟然http请求是自己封装的，还专门封装为了同步方法和异步的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface QAsyncHttp : NSObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id)httpPostWithFile:(id)file url:(id)url queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">-(id)httpPost:(id)post queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">-(id)httpGet:(id)get queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@interface QSyncHttp : NSObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id)httpPostWithFile:(id)file url:(id)url queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)httpPost:(id)post queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)httpGet:(id)get queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)getResponseWithRequest:(id)request;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><blockquote><p>有必要这样嘛，个人觉得只封装一种就够了，需要同步的时候，自己在UI上处理一下，让用户感觉是同步的方式就可以了</p><p>实在是太多了，也懒得看</p><p>资源文件就是一堆图片，cache文件里面就是各种书籍的缓存图片，反正里面的东西都没有加密，也就一目了然了，并不是很能理解这种做法。</p><p>软件某些功能都无法正常使用，分享，升级检测，支付功能也相当难用，对于如此恶心的app,突然失去继续撸下去的必要。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为我的朋友在文轩上班，那就撸一下他们公司的app&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2014/05/13/撸文轩APP学到的/1.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;找到要撸的app，并生成要解密的ipa&lt;/p&gt;
&lt;p&gt; 找到这个文件，先解压再&lt;/p&gt;
&lt;p&gt;&lt;img s
      
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
      <category term="逆向" scheme="http://yoursite.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>c++11学习笔记--常量表达式(constexpr)</title>
    <link href="http://yoursite.com/2014/05/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-constexpr/"/>
    <id>http://yoursite.com/2014/05/09/c-11学习笔记-常量表达式-constexpr/</id>
    <published>2014-05-09T09:34:01.000Z</published>
    <updated>2019-04-09T09:39:23.829Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最新在弄android ndk相关的，惊奇的发现最新的ndk10的版本已经gcc4.9了，我印象中，gcc4.8就支持C++0x11，14的支持，gcc再次走到了llvm的前面，LLVM最新的版本3.4.2应该只支持c++ 11，如果是同样的c++代码我一直认为llvm的效率会明显强过gcc.</p><p>废话不多说，让我们开始学习c++ 11吧，说实话我之前一直都很抗拒c++新的语法，感觉太难接受了，现在看来不熟悉也不行了。</p><p>常量表达式（constexpr）</p><p>常量表达式机制是为了：</p><p>提供了更多的通用的值不发生变化的表达式</p><p>允许用户自定义的类型成为常量表达式</p><p>提供了一种保证在编译期完成初始化的方法（可以在编译时期执行某些函数调用）</p></blockquote><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ol><li><p>修饰常量表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> int var1 = 100;</span><br><span class="line">   </span><br><span class="line"> const int const_var2 = 200;</span><br><span class="line">   </span><br><span class="line"> const int const_var3 = var1;</span><br><span class="line">   </span><br><span class="line"> constexpr int constexpr_var1 = 3 + const_var2 * 4; //成立</span><br><span class="line">   </span><br><span class="line">// constexpr int constexpr_var2 = 3 + var1 * 4; //错误</span><br><span class="line">   </span><br><span class="line">// constexpr int constexpr_var3 = 3 + const_var3 * 4; //错误</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修饰函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">constexpr int Inc(int i) &#123;</span><br><span class="line"></span><br><span class="line">    return i + 1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">constexpr int a = Inc(1); // 正确</span><br><span class="line"></span><br><span class="line">constexpr int b = Inc(cin.get()); // 错误</span><br><span class="line"></span><br><span class="line">constexpr int c = a * 2 + 1; // 正确，但是如果没有Inc(1)，也是错误的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constexpr修饰的值要有初始值，和const不同的是初始化的值可以一个表达式，但是这个表达式的值必须是在编译期间就能确定值的。</span><br></pre></td></tr></table></figure><ol start="3"><li><p>修饰类或者结构体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line"></span><br><span class="line">    constexpr A(int xx, int yy): x(xx), y(yy) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    int x, y;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">constexpr A aa(1, 2);</span><br><span class="line"></span><br><span class="line">constexpr int ccc = aa.x;</span><br><span class="line"></span><br><span class="line">enum &#123;SIZE_X = aa.x, SIZE_Y = aa.y&#125;;//llvm报错</span><br><span class="line"></span><br><span class="line">Reference to local variable &apos;aa&apos; declared in enclosing function &apos;main&apos;</span><br><span class="line"></span><br><span class="line">如果把constexpr A aa(1, 2);写成全局的就Ok，但是某些编译器并不会报错，我个人认为这个llvm编译器不太合理的地方，如果紧紧是aa是一个局部变量就不允许，但是aa本身的值是在编译的时候就确认了的。</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>个人的理解就是constexpr扩展了常量的含义，从语法上支持更多的常量定义，对比宏又有更好的类型检测和安全性，更强的约束语法带来更好的代码优化。</strong></p><blockquote><p>无意中在csdn论坛上看见大神的一段短话，摘录下来，很值的体会</p><p>constexpr：不光是可以取代模板是某些常量的表达更简洁，其实一个决定性的作用是支持地址类常量。这恰好补上了模板缺失的部分。比如有一个字符串常量”abc”，很自然的可以认为其中的元素也是常量地址，对一个有编译期内容的常量地址取值理论上可以在编译器确定结果，但实际上按旧语法却不能直接拿去做为常量使用而是当作变量。</p><p>union带构造函数、支持带用户定义构造函数的类作为其成员，本意是用来支持某种多型变量，比如根据某个标志决定一个这样的union当前是什么类型。滥用则会导致数据错误。</p><p>noexcept支持推导，而容器元素在支持右值引用的情况下这类推导是很重要的。右值引用可以减少深拷贝的需求，但是在某些情况下会破坏强异常安全保证。利用noexcept推导来决定一个复杂类型作为容器元素的时候到底适合用移动还是适合用普通的拷贝策略来保证强异常安全。比如一个类型如果不支持无异常的移动（自身或任一基类或者数据成员的移动构造函数不支持noexcept，因此需要用到推导），则这个类型不适合移动而只能使用拷贝实现异常安全</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最新在弄android ndk相关的，惊奇的发现最新的ndk10的版本已经gcc4.9了，我印象中，gcc4.8就支持C++0x11，14的支持，gcc再次走到了llvm的前面，LLVM最新的版本3.4.2应该只支持c++ 11，如果是同样的c++
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>跨平台播放器</title>
    <link href="http://yoursite.com/2014/04/09/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://yoursite.com/2014/04/09/跨平台播放器/</id>
    <published>2014-04-09T08:59:03.000Z</published>
    <updated>2019-04-09T09:15:44.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>播放器算是手机上用的最多的软件之一，vlc是其中的佼佼者，更是第一大开源软件，但是vlc实在是太重了，附带的几十个开源框架编译都很辛苦。</p><p>其实我只想学习一下视频解码到显示的过程。</p><p>所以我选的方案是ffmpeg解码，sdl显示，这两个开源项目都有很好的维护，而且都能很好的跨各个平台。</p></blockquote><ol><li><p>编译ffmpeg for android</p></li><li><p>下载sdl的代码hg clone <a href="http://hg.libsdl.org/SDL" target="_blank" rel="noopener">http://hg.libsdl.org/SDL</a></p></li><li><p>在android-project导入到Eclipse中，进入jni文件夹，新建一个SDL文件，将SDL2-2.0.4\src,SDL2-2.0.4\include,SDL2-2.0.4\Android.mk文件拷贝到android-project\jni\SDL\中。</p></li></ol><p><img src="/2014/04/09/跨平台播放器/1.jpg" alt></p><h4 id="src下面增加了一个Android-mk"><a href="#src下面增加了一个Android-mk" class="headerlink" title="src下面增加了一个Android.mk:"></a>src下面增加了一个Android.mk:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"> 1 LOCAL_PATH := $(call my-dir)</span><br><span class="line"> 2 </span><br><span class="line"> 3 include $(CLEAR_VARS)</span><br><span class="line"> 4 LOCAL_MODULE := avcodec-55-prebuilt</span><br><span class="line"> 5 LOCAL_SRC_FILES := prebuilt/libavcodec-55.so</span><br><span class="line"> 6 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line"> 7 </span><br><span class="line"> 8 include $(CLEAR_VARS)</span><br><span class="line"> 9 LOCAL_MODULE := avdevice-55-prebuilt</span><br><span class="line">10 LOCAL_SRC_FILES := prebuilt/libavdevice-55.so</span><br><span class="line">11 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">12 </span><br><span class="line">13 include $(CLEAR_VARS)</span><br><span class="line">14 LOCAL_MODULE := avfilter-4-prebuilt</span><br><span class="line">15 LOCAL_SRC_FILES := prebuilt/libavfilter-4.so</span><br><span class="line">16 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">17 </span><br><span class="line">18 include $(CLEAR_VARS)</span><br><span class="line">19 LOCAL_MODULE := avformat-55-prebuilt</span><br><span class="line">20 LOCAL_SRC_FILES := prebuilt/libavformat-55.so</span><br><span class="line">21 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">22 </span><br><span class="line">23 include $(CLEAR_VARS)</span><br><span class="line">24 LOCAL_MODULE :=  avutil-52-prebuilt</span><br><span class="line">25 LOCAL_SRC_FILES := prebuilt/libavutil-52.so</span><br><span class="line">26 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">27 </span><br><span class="line">28 include $(CLEAR_VARS)</span><br><span class="line">29 LOCAL_MODULE :=  avswresample-0-prebuilt</span><br><span class="line">30 LOCAL_SRC_FILES := prebuilt/libswresample-0.so</span><br><span class="line">31 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">32 </span><br><span class="line">33 include $(CLEAR_VARS)</span><br><span class="line">34 LOCAL_MODULE :=  swscale-2-prebuilt</span><br><span class="line">35 LOCAL_SRC_FILES := prebuilt/libswscale-2.so</span><br><span class="line">36 </span><br><span class="line">37 include $(PREBUILT_SHARED_LIBRARY)</span><br><span class="line">38 </span><br><span class="line">39 include $(CLEAR_VARS)</span><br><span class="line">40  </span><br><span class="line">41 LOCAL_MODULE := main</span><br><span class="line">42 </span><br><span class="line">43 SDL_PATH := ../SDL</span><br><span class="line">44 </span><br><span class="line">45 LOCAL_C_INCLUDES := $(LOCAL_PATH)/$(SDL_PATH)/include \</span><br><span class="line">46 </span><br><span class="line">47 # Add your application source files here...</span><br><span class="line">48 LOCAL_SRC_FILES := $(SDL_PATH)/src/main/android/SDL_android_main.c \</span><br><span class="line">49     ktDecodeDisplay.c</span><br><span class="line">50 </span><br><span class="line">51 LOCAL_SHARED_LIBRARIES := avcodec-55-prebuilt avdevice-55-prebuilt avfilter-4-prebuilt avformat-55-prebuilt avutil-52-prebuilt  avswresample-0-prebuilt swscale-2-prebuilt SDL2</span><br><span class="line">52 </span><br><span class="line">53 LOCAL_LDLIBS := -lGLESv1_CM -lGLESv2 -llog </span><br><span class="line">54 </span><br><span class="line">55   </span><br><span class="line">56 include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure><h4 id="主要的播放代码ktDecodeDisplay-c"><a href="#主要的播放代码ktDecodeDisplay-c" class="headerlink" title="主要的播放代码ktDecodeDisplay.c"></a>主要的播放代码ktDecodeDisplay.c</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ktDecodeDisplay.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: </span><br><span class="line"> *      Author: xiaoyao</span><br><span class="line"> */</span><br><span class="line">#ifdef __ANDROID__</span><br><span class="line">#include &quot;ktDecodeDisplay.h&quot;</span><br><span class="line"></span><br><span class="line">void packet_queue_init(PacketQueue *q)</span><br><span class="line">&#123;</span><br><span class="line">    memset(q, 0, sizeof(PacketQueue));</span><br><span class="line">    q-&gt;mutex = SDL_CreateMutex();</span><br><span class="line">    q-&gt;cond = SDL_CreateCond();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int packet_queue_put(PacketQueue *q, AVPacket *pkt)</span><br><span class="line">&#123;</span><br><span class="line">    AVPacketList *pkt_temp;</span><br><span class="line"></span><br><span class="line">    pkt_temp = (AVPacketList *) av_malloc(sizeof(AVPacketList));</span><br><span class="line">    if (!pkt_temp)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    pkt_temp-&gt;pkt = *pkt;</span><br><span class="line">    pkt_temp-&gt;next = NULL;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    if (!q-&gt;last_pkt)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;first_pkt = pkt_temp;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;last_pkt-&gt;next = pkt_temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;last_pkt = pkt_temp;</span><br><span class="line">    q-&gt;nb_packets++;</span><br><span class="line">    q-&gt;size += pkt_temp-&gt;pkt.size;</span><br><span class="line"></span><br><span class="line">    SDL_CondSignal(q-&gt;cond);</span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block)</span><br><span class="line">&#123;</span><br><span class="line">    AVPacketList *pkt_temp;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (global_video_state-&gt;quit)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = -1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt_temp = q-&gt;first_pkt;</span><br><span class="line"></span><br><span class="line">        if (pkt_temp)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;first_pkt = pkt_temp-&gt;next;</span><br><span class="line">            if (!q-&gt;first_pkt)</span><br><span class="line">            &#123;</span><br><span class="line">                q-&gt;last_pkt = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            q-&gt;nb_packets--;</span><br><span class="line">            q-&gt;size -= pkt_temp-&gt;pkt.size;</span><br><span class="line">            *pkt = pkt_temp-&gt;pkt;</span><br><span class="line"></span><br><span class="line">            av_free(pkt_temp);</span><br><span class="line">            ret = 1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (!block)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            SDL_CondWait(q-&gt;cond, q-&gt;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(q-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get_audio_clock(VideoState *is)</span><br><span class="line">&#123;</span><br><span class="line">    double pts;</span><br><span class="line">    int hw_buf_size, bytes_per_sec, n;</span><br><span class="line"></span><br><span class="line">    pts = is-&gt;audio_clock; /* maintained in the audio thread */</span><br><span class="line">    hw_buf_size = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">    bytes_per_sec = 0;</span><br><span class="line">    n = is-&gt;audio_st-&gt;codec-&gt;channels * 2;</span><br><span class="line">    if (is-&gt;audio_st)</span><br><span class="line">    &#123;</span><br><span class="line">        bytes_per_sec = is-&gt;audio_st-&gt;codec-&gt;sample_rate * n;</span><br><span class="line">    &#125;</span><br><span class="line">    if (bytes_per_sec)</span><br><span class="line">    &#123;</span><br><span class="line">        pts -= (double) hw_buf_size / bytes_per_sec;</span><br><span class="line">    &#125;</span><br><span class="line">    return pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get_video_clock(VideoState *is)</span><br><span class="line">&#123;</span><br><span class="line">    double delta;</span><br><span class="line"></span><br><span class="line">    delta = (av_gettime() - is-&gt;video_current_pts_time) / 1000000.0;</span><br><span class="line">    return is-&gt;video_current_pts + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get_external_clock(VideoState *is)</span><br><span class="line">&#123;</span><br><span class="line">    return av_gettime() / 1000000.0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double get_master_clock(VideoState *is)</span><br><span class="line">&#123;</span><br><span class="line">    if (is-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER)</span><br><span class="line">    &#123;</span><br><span class="line">        //LOGI(&quot;get_video_clock&quot;);</span><br><span class="line">        return get_video_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (is-&gt;av_sync_type == AV_SYNC_AUDIO_MASTER)</span><br><span class="line">    &#123;</span><br><span class="line">        return get_audio_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        return get_external_clock(is);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Add or subtract samples to get a better sync, return new</span><br><span class="line"> audio buffer size */</span><br><span class="line">int synchronize_audio(VideoState *is, short *samples, int samples_size,double pts)</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    double ref_clock;</span><br><span class="line"></span><br><span class="line">    n = 2 * is-&gt;audio_st-&gt;codec-&gt;channels;</span><br><span class="line"></span><br><span class="line">    if (is-&gt;av_sync_type != AV_SYNC_AUDIO_MASTER)</span><br><span class="line">    &#123;</span><br><span class="line">        double diff, avg_diff;</span><br><span class="line">        int wanted_size, min_size, max_size;</span><br><span class="line">        //int nb_samples;</span><br><span class="line"></span><br><span class="line">        ref_clock = get_master_clock(is);</span><br><span class="line">        diff = get_audio_clock(is) - ref_clock;</span><br><span class="line"></span><br><span class="line">        if (diff &lt; AV_NOSYNC_THRESHOLD)</span><br><span class="line">        &#123;</span><br><span class="line">            // accumulate the diffs</span><br><span class="line">            is-&gt;audio_diff_cum = diff + is-&gt;audio_diff_avg_coef * is-&gt;audio_diff_cum;</span><br><span class="line">            if (is-&gt;audio_diff_avg_count &lt; AUDIO_DIFF_AVG_NB)</span><br><span class="line">            &#123;</span><br><span class="line">                is-&gt;audio_diff_avg_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                avg_diff = is-&gt;audio_diff_cum * (1.0 - is-&gt;audio_diff_avg_coef);</span><br><span class="line">                if (fabs(avg_diff) &gt;= is-&gt;audio_diff_threshold)</span><br><span class="line">                &#123;</span><br><span class="line">                    wanted_size = samples_size + ((int) (diff * is-&gt;audio_st-&gt;codec-&gt;sample_rate)* n);</span><br><span class="line">                    min_size = samples_size * ((100 - SAMPLE_CORRECTION_PERCENT_MAX) / 100);</span><br><span class="line">                    max_size = samples_size * ((100 + SAMPLE_CORRECTION_PERCENT_MAX) / 100);</span><br><span class="line">                    if (wanted_size &lt; min_size)</span><br><span class="line">                    &#123;</span><br><span class="line">                        wanted_size = min_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (wanted_size &gt; max_size)</span><br><span class="line">                    &#123;</span><br><span class="line">                        wanted_size = max_size;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (wanted_size &lt; samples_size)</span><br><span class="line">                    &#123;</span><br><span class="line">                        /* remove samples */</span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else if (wanted_size &gt; samples_size)</span><br><span class="line">                    &#123;</span><br><span class="line">                        uint8_t *samples_end, *q;</span><br><span class="line">                        int nb;</span><br><span class="line"></span><br><span class="line">                        /* add samples by copying final sample*/</span><br><span class="line">                        nb = (samples_size - wanted_size);</span><br><span class="line">                        samples_end = (uint8_t *) samples + samples_size - n;</span><br><span class="line">                        q = samples_end + n;</span><br><span class="line">                        while (nb &gt; 0)</span><br><span class="line">                        &#123;</span><br><span class="line">                            memcpy(q, samples_end, n);</span><br><span class="line">                            q += n;</span><br><span class="line">                            nb -= n;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        samples_size = wanted_size;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            /* difference is TOO big; reset diff stuff */</span><br><span class="line">            is-&gt;audio_diff_avg_count = 0;</span><br><span class="line">            is-&gt;audio_diff_cum = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return samples_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//解码音频</span><br><span class="line">int audio_decode_frame(VideoState *is, double *pts_ptr)</span><br><span class="line">&#123;</span><br><span class="line">    int len1, len2, decoded_data_size;</span><br><span class="line">    AVPacket *pkt = &amp;is-&gt;audio_pkt;</span><br><span class="line">    int got_frame = 0;</span><br><span class="line">    int64_t dec_channel_layout;</span><br><span class="line">    int wanted_nb_samples, resampled_data_size, n;</span><br><span class="line"></span><br><span class="line">    double pts;</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        while (is-&gt;audio_pkt_size &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!is-&gt;audio_frame)</span><br><span class="line">            &#123;</span><br><span class="line">                if (!(is-&gt;audio_frame = avcodec_alloc_frame()))</span><br><span class="line">                &#123;</span><br><span class="line">                    return AVERROR(ENOMEM);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                avcodec_get_frame_defaults(is-&gt;audio_frame);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            len1 = avcodec_decode_audio4(is-&gt;audio_st-&gt;codec, is-&gt;audio_frame,&amp;got_frame, pkt);</span><br><span class="line"></span><br><span class="line">            if (len1 &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // error, skip the frame</span><br><span class="line">                is-&gt;audio_pkt_size = 0;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            is-&gt;audio_pkt_data += len1;</span><br><span class="line">            is-&gt;audio_pkt_size -= len1;</span><br><span class="line"></span><br><span class="line">            if (!got_frame)</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /*计算解码出来帧缓存的大小*/</span><br><span class="line">            decoded_data_size = av_samples_get_buffer_size(NULL,is-&gt;audio_frame-&gt;channels, is-&gt;audio_frame-&gt;nb_samples, is-&gt;audio_frame-&gt;format, 1);</span><br><span class="line"></span><br><span class="line">            dec_channel_layout = (is-&gt;audio_frame-&gt;channel_layout &amp;&amp; is-&gt;audio_frame-&gt;channels == av_get_channel_layout_nb_channels(is-&gt;audio_frame-&gt;channel_layout))</span><br><span class="line">                                 ? is-&gt;audio_frame-&gt;channel_layout :av_get_default_channel_layout( is-&gt;audio_frame-&gt;channels);</span><br><span class="line"></span><br><span class="line">            wanted_nb_samples = is-&gt;audio_frame-&gt;nb_samples;</span><br><span class="line"></span><br><span class="line">            if (is-&gt;audio_frame-&gt;format != is-&gt;audio_src_fmt</span><br><span class="line">                    || dec_channel_layout != is-&gt;audio_src_channel_layout</span><br><span class="line">                    || is-&gt;audio_frame-&gt;sample_rate != is-&gt;audio_src_freq</span><br><span class="line">                    || (wanted_nb_samples != is-&gt;audio_frame-&gt;nb_samples</span><br><span class="line">                    &amp;&amp; !is-&gt;swr_ctx))</span><br><span class="line">            &#123;</span><br><span class="line">                if (is-&gt;swr_ctx)</span><br><span class="line">                &#123;</span><br><span class="line">                    swr_free(&amp;is-&gt;swr_ctx);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                is-&gt;swr_ctx = swr_alloc_set_opts(NULL,</span><br><span class="line">                        is-&gt;audio_tgt_channel_layout, is-&gt;audio_tgt_fmt,</span><br><span class="line">                        is-&gt;audio_tgt_freq, dec_channel_layout,</span><br><span class="line">                        is-&gt;audio_frame-&gt;format, is-&gt;audio_frame-&gt;sample_rate,</span><br><span class="line">                        0, NULL);</span><br><span class="line">                if (!is-&gt;swr_ctx || swr_init(is-&gt;swr_ctx) &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    fprintf(stderr, &quot;swr_init() failed\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                is-&gt;audio_src_channel_layout = dec_channel_layout;</span><br><span class="line">                is-&gt;audio_src_channels = is-&gt;audio_st-&gt;codec-&gt;channels;</span><br><span class="line">                is-&gt;audio_src_freq = is-&gt;audio_st-&gt;codec-&gt;sample_rate;</span><br><span class="line">                is-&gt;audio_src_fmt = is-&gt;audio_st-&gt;codec-&gt;sample_fmt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            /* 可以对采样数进行调整，增加或者减少，一般可以用来做声画同步*/</span><br><span class="line">            if (is-&gt;swr_ctx)</span><br><span class="line">            &#123;</span><br><span class="line">                const uint8_t **in = (const uint8_t **) is-&gt;audio_frame-&gt;extended_data;</span><br><span class="line">                uint8_t *out[] = &#123; is-&gt;audio_buf2 &#125;;</span><br><span class="line">                if (wanted_nb_samples != is-&gt;audio_frame-&gt;nb_samples)</span><br><span class="line">                &#123;</span><br><span class="line">                    if (swr_set_compensation(is-&gt;swr_ctx,</span><br><span class="line">                            (wanted_nb_samples - is-&gt;audio_frame-&gt;nb_samples)</span><br><span class="line">                                    * is-&gt;audio_tgt_freq</span><br><span class="line">                                    / is-&gt;audio_frame-&gt;sample_rate,</span><br><span class="line">                            wanted_nb_samples * is-&gt;audio_tgt_freq</span><br><span class="line">                                    / is-&gt;audio_frame-&gt;sample_rate) &lt; 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        fprintf(stderr, &quot;swr_set_compensation() failed\n&quot;);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                len2 = swr_convert(is-&gt;swr_ctx, out,</span><br><span class="line">                        sizeof(is-&gt;audio_buf2) / is-&gt;audio_tgt_channels</span><br><span class="line">                                / av_get_bytes_per_sample(is-&gt;audio_tgt_fmt),</span><br><span class="line">                        in, is-&gt;audio_frame-&gt;nb_samples);</span><br><span class="line"></span><br><span class="line">                if (len2 &lt; 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    fprintf(stderr, &quot;swr_convert() failed\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (len2 == sizeof(is-&gt;audio_buf2) / is-&gt;audio_tgt_channels</span><br><span class="line">                                / av_get_bytes_per_sample(is-&gt;audio_tgt_fmt))</span><br><span class="line">                &#123;</span><br><span class="line">                    fprintf(stderr,&quot;warning: audio buffer is probably too small\n&quot;);</span><br><span class="line">                    swr_init(is-&gt;swr_ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                is-&gt;audio_buf = is-&gt;audio_buf2;</span><br><span class="line">                resampled_data_size = len2 * is-&gt;audio_tgt_channels</span><br><span class="line">                        * av_get_bytes_per_sample(is-&gt;audio_tgt_fmt);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                resampled_data_size = decoded_data_size;</span><br><span class="line">                is-&gt;audio_buf = is-&gt;audio_frame-&gt;data[0];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pts = is-&gt;audio_clock;</span><br><span class="line">            *pts_ptr = pts;</span><br><span class="line">            n = 2 * is-&gt;audio_st-&gt;codec-&gt;channels;</span><br><span class="line">            is-&gt;audio_clock += (double) resampled_data_size / (double) (n * is-&gt;audio_st-&gt;codec-&gt;sample_rate);</span><br><span class="line"></span><br><span class="line">            // We have data, return it and come back for more later</span><br><span class="line">            return resampled_data_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pkt-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            av_free_packet(pkt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memset(pkt, 0, sizeof(*pkt));</span><br><span class="line">        if (is-&gt;quit)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (packet_queue_get(&amp;is-&gt;audioq, pkt, 1) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        is-&gt;audio_pkt_data = pkt-&gt;data;</span><br><span class="line">        is-&gt;audio_pkt_size = pkt-&gt;size;</span><br><span class="line"></span><br><span class="line">        /* if update, update the audio clock w/pts */</span><br><span class="line">        if (pkt-&gt;pts != AV_NOPTS_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            is-&gt;audio_clock = av_q2d(is-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void audio_callback(void *userdata, Uint8 *stream, int len)</span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    int len_temp, audio_data_size;</span><br><span class="line"></span><br><span class="line">    double pts;</span><br><span class="line"></span><br><span class="line">    /*   len是由SDL传入的SDL缓冲区的大小，如果这个缓冲未满，我们就一直往里填充数据 */</span><br><span class="line">    while (len &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        /*  audio_buf_index 和 audio_buf_size 标示我们自己用来放置解码出来的数据的缓冲区，*/</span><br><span class="line">        /*   这些数据待copy到SDL缓冲区， 当audio_buf_index &gt;= audio_buf_size的时候意味着我*/</span><br><span class="line">        /*   们的缓冲为空，没有数据可供copy，这时候需要调用audio_decode_frame来解码出更多的桢数据 */</span><br><span class="line"></span><br><span class="line">        if (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size)</span><br><span class="line">        &#123;</span><br><span class="line">            audio_data_size = audio_decode_frame(is, &amp;pts);</span><br><span class="line">            /* audio_data_size &lt; 0 标示没能解码出数据，我们默认播放静音 */</span><br><span class="line">            if (audio_data_size &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                /* silence */</span><br><span class="line">                is-&gt;audio_buf_size = 1024;</span><br><span class="line">                /* 清零，静音 */</span><br><span class="line">                memset(is-&gt;audio_buf, 0, is-&gt;audio_buf_size);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                audio_data_size = synchronize_audio(is, (int16_t *) is-&gt;audio_buf,audio_data_size, pts);</span><br><span class="line">                is-&gt;audio_buf_size = audio_data_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        /*  查看stream可用空间，决定一次copy多少数据，剩下的下次继续copy */</span><br><span class="line">        len_temp = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        if (len_temp &gt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            len_temp = len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        memcpy(stream, (uint8_t *) is-&gt;audio_buf + is-&gt;audio_buf_index, len_temp);</span><br><span class="line">        len -= len_temp;</span><br><span class="line">        stream += len_temp;</span><br><span class="line">        is-&gt;audio_buf_index += len_temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static Uint32 sdl_refresh_timer_cb(Uint32 interval, void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = FF_REFRESH_EVENT;</span><br><span class="line">    event.user.data1 = opaque;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void schedule_refresh(VideoState *is, int delay)</span><br><span class="line">&#123;</span><br><span class="line">    SDL_AddTimer(delay, sdl_refresh_timer_cb, is);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int decode_interrupt_cb(void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">    return (global_video_state &amp;&amp; global_video_state-&gt;quit);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void video_display(VideoState *is)</span><br><span class="line">&#123;</span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    float aspect_ratio;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line">    if (vp-&gt;bmp)</span><br><span class="line">    &#123;</span><br><span class="line">        if (is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio.num == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            aspect_ratio = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            aspect_ratio = av_q2d(is-&gt;video_st-&gt;codec-&gt;sample_aspect_ratio)</span><br><span class="line">                           * is-&gt;video_st-&gt;codec-&gt;width / is-&gt;video_st-&gt;codec-&gt;height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (aspect_ratio &lt;= 0.0)</span><br><span class="line">        &#123;</span><br><span class="line">            aspect_ratio = (float) is-&gt;video_st-&gt;codec-&gt;width / (float) is-&gt;video_st-&gt;codec-&gt;height;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rect.x = 0;</span><br><span class="line">        rect.y = 0;</span><br><span class="line">        rect.w = vp-&gt;width;</span><br><span class="line">        rect.h = vp-&gt;height;</span><br><span class="line"></span><br><span class="line">        SDL_UpdateYUVTexture(vp-&gt;bmp, &amp;rect, vp-&gt;rawdata-&gt;data[0],</span><br><span class="line">                vp-&gt;rawdata-&gt;linesize[0], vp-&gt;rawdata-&gt;data[1],</span><br><span class="line">                vp-&gt;rawdata-&gt;linesize[1], vp-&gt;rawdata-&gt;data[2],</span><br><span class="line">                vp-&gt;rawdata-&gt;linesize[2]);</span><br><span class="line"></span><br><span class="line">        SDL_RenderClear(vp-&gt;renderer);</span><br><span class="line">        SDL_RenderCopy(vp-&gt;renderer, vp-&gt;bmp, &amp;rect, &amp;rect);</span><br><span class="line">        SDL_RenderPresent(vp-&gt;renderer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void video_refresh_timer(void *userdata)</span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    double actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    if (is-&gt;video_st)</span><br><span class="line">    &#123;</span><br><span class="line">        if (is-&gt;pictq_size == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            schedule_refresh(is, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line"></span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts; /* the pts from last time */</span><br><span class="line">            if (delay &lt;= 0 || delay &gt;= 1.0)</span><br><span class="line">            &#123;</span><br><span class="line">                /* if incorrect delay, use previous one */</span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            /* save for next time */</span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            /* update delay to sync to audio */</span><br><span class="line">            if(is-&gt;file_type == AV_AUDIO_VIDEO_BOTH)</span><br><span class="line">            &#123;</span><br><span class="line">                ref_clock = get_audio_clock(is);</span><br><span class="line"></span><br><span class="line">                diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">                /* update delay to sync to audio if not master source */</span><br><span class="line">                if (is-&gt;av_sync_type != AV_SYNC_VIDEO_MASTER)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    ref_clock = get_master_clock(is);</span><br><span class="line">                    diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">                    /* Skip or repeat the frame. Take delay into account</span><br><span class="line">                     FFPlay still doesn&apos;t &quot;know if this is the best guess.&quot; */</span><br><span class="line">                    sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">                    if (fabs(diff) &lt; AV_NOSYNC_THRESHOLD)</span><br><span class="line">                    &#123;</span><br><span class="line">                        if (diff &lt;= -sync_threshold)</span><br><span class="line">                        &#123;</span><br><span class="line">                            delay = 0;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else if (diff &gt;= sync_threshold)</span><br><span class="line">                        &#123;</span><br><span class="line">                            delay = 2 * delay;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            /* computer the REAL delay */</span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / 1000000.0);</span><br><span class="line">            if (actual_delay &lt; 0.010)</span><br><span class="line">            &#123;</span><br><span class="line">                /* Really it should skip the picture instead */</span><br><span class="line">                actual_delay = 0.010;</span><br><span class="line">            &#125;</span><br><span class="line">            schedule_refresh(is, (int) (actual_delay * 1000 + 0.5));</span><br><span class="line"></span><br><span class="line">            /* show the picture! */</span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            /* update queue for next picture! */</span><br><span class="line">            if (++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE)</span><br><span class="line">            &#123;</span><br><span class="line">                is-&gt;pictq_rindex = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        schedule_refresh(is, 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//初始化sdl显示</span><br><span class="line">void alloc_picture(void *userdata)</span><br><span class="line">&#123;</span><br><span class="line">    LOGI(&quot;alloc_picture&quot;);</span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line"></span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line">    if (vp-&gt;bmp)</span><br><span class="line">    &#123;</span><br><span class="line">        // we already have one make another, bigger/smaller</span><br><span class="line">        SDL_DestroyTexture(vp-&gt;bmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(vp-&gt;rawdata)</span><br><span class="line">    &#123;</span><br><span class="line">        av_free(vp-&gt;rawdata);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Allocate a place to put our YUV image on that screen</span><br><span class="line">    vp-&gt;screen = SDL_CreateWindow(&quot;My Player Window&quot;, SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">            SDL_WINDOWPOS_UNDEFINED, is-&gt;video_st-&gt;codec-&gt;width,</span><br><span class="line">            is-&gt;video_st-&gt;codec-&gt;height,</span><br><span class="line">            SDL_WINDOW_FULLSCREEN | SDL_WINDOW_OPENGL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vp-&gt;renderer = SDL_CreateRenderer(vp-&gt;screen, -1, 0);</span><br><span class="line">    vp-&gt;bmp = SDL_CreateTexture(vp-&gt;renderer, SDL_PIXELFORMAT_YV12,</span><br><span class="line">                SDL_TEXTUREACCESS_STREAMING, is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height);</span><br><span class="line"></span><br><span class="line">    vp-&gt;width = is-&gt;video_st-&gt;codec-&gt;width;</span><br><span class="line">    vp-&gt;height = is-&gt;video_st-&gt;codec-&gt;height;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    AVFrame* pFrameYUV = avcodec_alloc_frame();</span><br><span class="line">    if (pFrameYUV == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int numBytes = avpicture_get_size(PIX_FMT_YUV420P, vp-&gt;width,</span><br><span class="line">            vp-&gt;height);</span><br><span class="line"></span><br><span class="line">    uint8_t* buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t));</span><br><span class="line"></span><br><span class="line">    avpicture_fill((AVPicture *) pFrameYUV, buffer, PIX_FMT_YUV420P,vp-&gt;width, vp-&gt;height);</span><br><span class="line"></span><br><span class="line">    vp-&gt;rawdata = pFrameYUV;</span><br><span class="line"></span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    vp-&gt;allocated = 1;</span><br><span class="line">    SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int queue_picture(VideoState *is, AVFrame *pFrame, double pts)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    //int dst_pic_fmt</span><br><span class="line">    AVPicture pict;</span><br><span class="line"></span><br><span class="line">    /* wait unitl we have space for a new pic */</span><br><span class="line">    SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">    while (is-&gt;pictq_size &gt;= VIDEO_PICTURE_QUEUE_SIZE &amp;&amp; !is-&gt;quit)</span><br><span class="line">    &#123;</span><br><span class="line">        SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line"></span><br><span class="line">    if (is-&gt;quit)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    // windex is set to 0 initially</span><br><span class="line">    vp = &amp;is-&gt;pictq[is-&gt;pictq_windex];</span><br><span class="line"></span><br><span class="line">    /* allocate or resize the buffer ! */</span><br><span class="line">    if (!vp-&gt;bmp || vp-&gt;width != is-&gt;video_st-&gt;codec-&gt;width</span><br><span class="line">            || vp-&gt;height != is-&gt;video_st-&gt;codec-&gt;height)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        SDL_Event event;</span><br><span class="line"></span><br><span class="line">        vp-&gt;allocated = 0;</span><br><span class="line">        /* we have to do it in the main thread */</span><br><span class="line">        event.type = FF_ALLOC_EVENT;</span><br><span class="line">        event.user.data1 = is;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">        /* wait until we have a picture allocated */</span><br><span class="line">        SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        while (!vp-&gt;allocated &amp;&amp; !is-&gt;quit)</span><br><span class="line">        &#123;</span><br><span class="line">            SDL_CondWait(is-&gt;pictq_cond, is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    if (is-&gt;quit)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* We have a place to put our picture on the queue */</span><br><span class="line">    if (vp-&gt;rawdata)</span><br><span class="line">    &#123;</span><br><span class="line">        // Convert the image into YUV format that SDL uses</span><br><span class="line">        sws_scale(is-&gt;sws_ctx, (uint8_t const * const *) pFrame-&gt;data,</span><br><span class="line">                pFrame-&gt;linesize, 0, is-&gt;video_st-&gt;codec-&gt;height,</span><br><span class="line">                vp-&gt;rawdata-&gt;data, vp-&gt;rawdata-&gt;linesize);</span><br><span class="line"></span><br><span class="line">        vp-&gt;pts = pts;</span><br><span class="line"></span><br><span class="line">        /* now we inform our display thread that we have a pic ready */</span><br><span class="line">        if (++is-&gt;pictq_windex == VIDEO_PICTURE_QUEUE_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            is-&gt;pictq_windex = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        is-&gt;pictq_size++;</span><br><span class="line">        SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double synchronize_video(VideoState *is, AVFrame *src_frame, double pts)</span><br><span class="line">&#123;</span><br><span class="line">    double frame_delay;</span><br><span class="line"></span><br><span class="line">    if (pts != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        /* if we have pts, set video clock to it */</span><br><span class="line">        is-&gt;video_clock = pts;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        /* if we aren&apos;t given a pts, set it to the clock */</span><br><span class="line">        pts = is-&gt;video_clock;</span><br><span class="line">    &#125;</span><br><span class="line">    /* update the video clock */</span><br><span class="line">    frame_delay = av_q2d(is-&gt;video_st-&gt;codec-&gt;time_base);</span><br><span class="line">    /* if we are repeating a frame, adjust clock accordingly */</span><br><span class="line">    frame_delay += src_frame-&gt;repeat_pict * (frame_delay * 0.5);</span><br><span class="line">    is-&gt;video_clock += frame_delay;</span><br><span class="line">    return pts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* These are called whenever we allocate a frame</span><br><span class="line"> * buffer. We use this to store the global_pts in</span><br><span class="line"> * a frame at the time it is allocated.</span><br><span class="line"> */</span><br><span class="line">int our_get_buffer(struct AVCodecContext *c, AVFrame *pic)</span><br><span class="line">&#123;</span><br><span class="line">    int ret = avcodec_default_get_buffer(c, pic);</span><br><span class="line">    uint64_t *pts = av_malloc(sizeof(uint64_t));</span><br><span class="line">    *pts = global_video_pkt_pts;</span><br><span class="line">    pic-&gt;opaque = pts;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void our_release_buffer(struct AVCodecContext *c, AVFrame *pic)</span><br><span class="line">&#123;</span><br><span class="line">    if (pic)</span><br><span class="line">    &#123;</span><br><span class="line">        av_freep(&amp;pic-&gt;opaque);</span><br><span class="line">    &#125;</span><br><span class="line">    avcodec_default_release_buffer(c, pic);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int video_thread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *) arg;</span><br><span class="line">    //AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    AVPacket *packet;</span><br><span class="line">    int frameFinished = -1;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    //AVCodecContext *pCodecCtx;</span><br><span class="line"></span><br><span class="line">    AVCodec *pCodec;</span><br><span class="line">    double pts;</span><br><span class="line">    int ret;</span><br><span class="line"></span><br><span class="line">    packet = (AVPacket *) malloc(sizeof(AVPacket));</span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (packet_queue_get(&amp;is-&gt;videoq, packet, 1) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            // means we quit getting packets</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pts = 0;</span><br><span class="line"></span><br><span class="line">        // Save global pts to be stored in pFrame in first call</span><br><span class="line">        global_video_pkt_pts = packet-&gt;pts;</span><br><span class="line"></span><br><span class="line">        // Decode video frame</span><br><span class="line">        if (packet-&gt;stream_index == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = avcodec_decode_video2(is-&gt;video_st-&gt;codec, pFrame, &amp;frameFinished,packet);</span><br><span class="line">            if(is-&gt;video_st-&gt;codec-&gt;width &gt; 1920)</span><br><span class="line">            &#123;</span><br><span class="line">                is-&gt;video_st-&gt;codec-&gt;width = 1920;</span><br><span class="line">            &#125;</span><br><span class="line">            if(is-&gt;video_st-&gt;codec-&gt;height &gt;1080 )</span><br><span class="line">            &#123;</span><br><span class="line">                is-&gt;video_st-&gt;codec-&gt;height = 1080;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (packet-&gt;dts == AV_NOPTS_VALUE &amp;&amp; pFrame-&gt;opaque</span><br><span class="line">                &amp;&amp; *(uint64_t*) pFrame-&gt;opaque != AV_NOPTS_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            pts = *(uint64_t *) pFrame-&gt;opaque;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (packet-&gt;dts != AV_NOPTS_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            pts = packet-&gt;dts;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            pts = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">        // Did we get a video frame?</span><br><span class="line">        if (frameFinished)</span><br><span class="line">        &#123;</span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            if (queue_picture(is, pFrame, pts) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_free_packet(packet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_free(pFrame);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int audio_stream_component_open(VideoState *is, int stream_index)</span><br><span class="line">&#123;</span><br><span class="line">    AVFormatContext *ic = is-&gt;ic;</span><br><span class="line">    AVCodecContext *codecCtx;</span><br><span class="line">    AVCodec *codec;</span><br><span class="line">    SDL_AudioSpec wanted_spec, spec;</span><br><span class="line">    int64_t wanted_channel_layout = 0;</span><br><span class="line">    int wanted_nb_channels;</span><br><span class="line">    /*  SDL支持的声道数为 1, 2, 4, 6 */</span><br><span class="line">    /*  后面我们会使用这个数组来纠正不支持的声道数目 */</span><br><span class="line">    const int next_nb_channels[] = &#123; 0, 0, 1, 6, 2, 6, 4, 6 &#125;;</span><br><span class="line"></span><br><span class="line">    if (stream_index &lt; 0 || stream_index &gt;= ic-&gt;nb_streams)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    codecCtx = ic-&gt;streams[stream_index]-&gt;codec;</span><br><span class="line">    wanted_nb_channels = codecCtx-&gt;channels;</span><br><span class="line">    if (!wanted_channel_layout || wanted_nb_channels != av_get_channel_layout_nb_channels(wanted_channel_layout))</span><br><span class="line">    &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_nb_channels);</span><br><span class="line"></span><br><span class="line">        wanted_channel_layout &amp;= ~AV_CH_LAYOUT_STEREO_DOWNMIX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wanted_spec.channels = av_get_channel_layout_nb_channels(wanted_channel_layout);</span><br><span class="line">    wanted_spec.freq = codecCtx-&gt;sample_rate;</span><br><span class="line">    if (wanted_spec.freq &lt;= 0 || wanted_spec.channels &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Invalid sample rate or channel count!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    wanted_spec.format = AUDIO_S16SYS;            // 具体含义请查看“SDL宏定义”部分</span><br><span class="line">    wanted_spec.silence = 0;                      // 0指示静音</span><br><span class="line">    wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;  // 自定义SDL缓冲区大小</span><br><span class="line">    wanted_spec.callback = audio_callback;          // 音频解码的关键回调函数,向SDL缓冲区填充数据</span><br><span class="line">    wanted_spec.userdata = is;                      // 传给上面回调函数的外带数据</span><br><span class="line">    /*  打开音频设备，这里使用一个while来循环尝试打开不同的声道数(由上面 */</span><br><span class="line">    /*  next_nb_channels数组指定）直到成功打开，或者全部失败 */</span><br><span class="line">    while (SDL_OpenAudio(&amp;wanted_spec, &amp;spec) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;SDL_OpenAudio (%d channels): %s\n&quot;,wanted_spec.channels, SDL_GetError());</span><br><span class="line">        wanted_spec.channels = next_nb_channels[FFMIN(7, wanted_spec.channels)];</span><br><span class="line">        if (!wanted_spec.channels)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr,&quot;No more channel combinations to tyu, audio open failed\n&quot;);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(wanted_spec.channels);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 检查实际使用的配置（保存在spec,由SDL_OpenAudio()填充） */</span><br><span class="line">    if (spec.format != AUDIO_S16SYS)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;SDL advised audio format %d is not supported!\n&quot;,spec.format);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (spec.channels != wanted_spec.channels)</span><br><span class="line">    &#123;</span><br><span class="line">        wanted_channel_layout = av_get_default_channel_layout(spec.channels);</span><br><span class="line">        if (!wanted_channel_layout)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, &quot;SDL advised channel count %d is not supported!\n&quot;,spec.channels);</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;audio_hw_buf_size = spec.size;</span><br><span class="line"></span><br><span class="line">    /* 把设置好的参数保存到大结构中 */</span><br><span class="line">    is-&gt;audio_src_fmt = is-&gt;audio_tgt_fmt = AV_SAMPLE_FMT_S16;</span><br><span class="line">    is-&gt;audio_src_freq = is-&gt;audio_tgt_freq = spec.freq;</span><br><span class="line">    is-&gt;audio_src_channel_layout = is-&gt;audio_tgt_channel_layout = wanted_channel_layout;</span><br><span class="line">    is-&gt;audio_src_channels = is-&gt;audio_tgt_channels = spec.channels;</span><br><span class="line"></span><br><span class="line">    codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line">    if (!codec || (avcodec_open2(codecCtx, codec, NULL) &lt; 0))</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Unsupported codec!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    ic-&gt;streams[stream_index]-&gt;discard = AVDISCARD_DEFAULT;</span><br><span class="line">    switch (codecCtx-&gt;codec_type)</span><br><span class="line">    &#123;</span><br><span class="line">        case AVMEDIA_TYPE_AUDIO:</span><br><span class="line">            is-&gt;audioStream = stream_index;</span><br><span class="line">            is-&gt;audio_st = ic-&gt;streams[stream_index];</span><br><span class="line">            is-&gt;audio_buf_size = 0;</span><br><span class="line">            is-&gt;audio_buf_index = 0;</span><br><span class="line"></span><br><span class="line">            /* averaging filter for audio sync */</span><br><span class="line">            is-&gt;audio_diff_avg_coef = exp(log(0.01 / AUDIO_DIFF_AVG_NB));</span><br><span class="line">            is-&gt;audio_diff_avg_count = 0;</span><br><span class="line">            /* Correct audio only if larger error than this */</span><br><span class="line">            is-&gt;audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / codecCtx-&gt;sample_rate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            memset(&amp;is-&gt;audio_pkt, 0, sizeof(is-&gt;audio_pkt));</span><br><span class="line">            packet_queue_init(&amp;is-&gt;audioq);</span><br><span class="line">            SDL_PauseAudio(0); // 开始播放静音</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int video_stream_component_open(VideoState *is, int stream_index)</span><br><span class="line">&#123;</span><br><span class="line">    AVFormatContext *pFormatCtx = is-&gt;ic;</span><br><span class="line">    AVCodecContext *codecCtx;</span><br><span class="line">    AVCodec *codec;</span><br><span class="line">    if (stream_index &lt; 0 || stream_index &gt;= pFormatCtx-&gt;nb_streams)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Get a pointer to the codec context for the video stream</span><br><span class="line">    codecCtx = pFormatCtx-&gt;streams[stream_index]-&gt;codec;</span><br><span class="line">    LOGI(&quot;codecCtx-&gt;time_base.num=%d den=%d &quot;,codecCtx-&gt;time_base.num,codecCtx-&gt;time_base.den);</span><br><span class="line">    codec = avcodec_find_decoder(codecCtx-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    if (!codec || (avcodec_open2(codecCtx, codec, NULL) &lt; 0))</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Unsupported codec!\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (codecCtx-&gt;codec_type)</span><br><span class="line">    &#123;</span><br><span class="line">    case AVMEDIA_TYPE_VIDEO:</span><br><span class="line">        is-&gt;videoStream = stream_index;</span><br><span class="line">        is-&gt;video_st = pFormatCtx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">        is-&gt;sws_ctx = sws_getContext(is-&gt;video_st-&gt;codec-&gt;width,</span><br><span class="line">                is-&gt;video_st-&gt;codec-&gt;height, is-&gt;video_st-&gt;codec-&gt;pix_fmt,</span><br><span class="line">                is-&gt;video_st-&gt;codec-&gt;width, is-&gt;video_st-&gt;codec-&gt;height,</span><br><span class="line">                AV_PIX_FMT_YUV420P, SWS_FAST_BILINEAR, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">        is-&gt;frame_timer = (double) av_gettime() / 1000000.0;</span><br><span class="line">        is-&gt;frame_last_delay = 40e-3;</span><br><span class="line">        is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line"></span><br><span class="line">        packet_queue_init(&amp;is-&gt;videoq);</span><br><span class="line">        is-&gt;video_tid = SDL_CreateThread(video_thread, &quot;video_thread&quot;, is);</span><br><span class="line"></span><br><span class="line">    //    codecCtx-&gt;get_buffer = our_get_buffer;</span><br><span class="line">    //    codecCtx-&gt;release_buffer = our_release_buffer;</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int decode_thread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    VideoState *is = (VideoState *) arg;</span><br><span class="line">    AVFormatContext *pFormatCtx = NULL;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line"></span><br><span class="line">    int video_index = -1;</span><br><span class="line">    int audio_index = -1;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    is-&gt;videoStream = -1;</span><br><span class="line">    is-&gt;audioStream = -1;</span><br><span class="line"></span><br><span class="line">    AVIOInterruptCB interupt_cb;</span><br><span class="line"></span><br><span class="line">    global_video_state = is;</span><br><span class="line"></span><br><span class="line">    // will interrup blocking functions if we quit!</span><br><span class="line">    interupt_cb.callback = decode_interrupt_cb;</span><br><span class="line">    interupt_cb.opaque = is;</span><br><span class="line"></span><br><span class="line">    if (avio_open2(&amp;is-&gt;io_ctx, is-&gt;filename, 0, &amp;interupt_cb, NULL))</span><br><span class="line">    &#123;</span><br><span class="line">        LOGI(&quot;Cannot open I/O for %s\n&quot;, is-&gt;filename);</span><br><span class="line">        fprintf(stderr, &quot;Cannot open I/O for %s\n&quot;, is-&gt;filename);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">    //Open video file</span><br><span class="line">    if (avformat_open_input(&amp;pFormatCtx, is-&gt;filename, NULL, NULL) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; //Couldn&apos;t open file</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    is-&gt;ic = pFormatCtx;</span><br><span class="line"></span><br><span class="line">    //Retrieve stream infomation</span><br><span class="line">    if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // Couldn&apos;t find stream information</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Dump information about file onto standard error</span><br><span class="line">    //av_dump_format(pFormatCtx, 0, is-&gt;filename, 0);</span><br><span class="line"></span><br><span class="line">    //Find the first video stream</span><br><span class="line">    for (i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;coder_type == AVMEDIA_TYPE_VIDEO</span><br><span class="line">                &amp;&amp; video_index &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            video_index = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO</span><br><span class="line">                &amp;&amp; audio_index &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            audio_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(audio_index &gt;= 0 &amp;&amp; video_index &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        is-&gt;av_sync_type = DEFAULT_AV_SYNC_TYPE;</span><br><span class="line">        LOGI(&quot;AV_AUDIO_VIDEO_BOTH&quot;);</span><br><span class="line">        is-&gt;file_type = AV_AUDIO_VIDEO_BOTH;</span><br><span class="line">        audio_stream_component_open(is, audio_index);</span><br><span class="line">        video_stream_component_open(is, video_index);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    else if(video_index &gt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        is-&gt;av_sync_type = AV_NO_SYNC_MASTER;</span><br><span class="line">        LOGI(&quot;AV_VIDEO_ONLY&quot;);</span><br><span class="line">        is-&gt;file_type = AV_VIDEO_ONLY;</span><br><span class="line">        video_stream_component_open(is, video_index);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        is-&gt;av_sync_type = AV_NO_SYNC_MASTER;</span><br><span class="line">        LOGI(&quot;AV_AUDIO_ONLY&quot;);</span><br><span class="line">        is-&gt;file_type = AV_AUDIO_ONLY;</span><br><span class="line">        audio_stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (is-&gt;videoStream &lt; 0 &amp;&amp; is-&gt;audioStream &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;%s: could not open codec\n&quot;, is-&gt;filename);</span><br><span class="line">        goto fail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //main decode loop</span><br><span class="line">    /* 读包的主循环， av_read_frame不停的从文件中读取数据包*/</span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (is-&gt;quit)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //seek  stuff goes here</span><br><span class="line">        /* 这里audioq.size是指队列中的所有数据包带的音频数据的总量或者视频数据总量，并不是包的数量 */</span><br><span class="line">        if (is-&gt;audioq.size &gt; MAX_AUDIOQ_SIZE || is-&gt;videoq.size &gt; MAX_VIDEOQ_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            SDL_Delay(10);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if (av_read_frame(is-&gt;ic, packet) &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            if (is-&gt;ic-&gt;pb-&gt;error == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                SDL_Delay(100); /* no error; wait for user input */</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Is this a packet from the video stream?</span><br><span class="line">        if (packet-&gt;stream_index == is-&gt;videoStream)</span><br><span class="line">        &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (packet-&gt;stream_index == is-&gt;audioStream)</span><br><span class="line">        &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            av_free_packet(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*all done - wait for it*/</span><br><span class="line">    while (!is-&gt;quit)</span><br><span class="line">    &#123;</span><br><span class="line">        SDL_Delay(100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fail: if (1)</span><br><span class="line">    &#123;</span><br><span class="line">        SDL_Event event;</span><br><span class="line">        event.type = FF_QUIT_EVENT;</span><br><span class="line">        event.user.data1 = is;</span><br><span class="line">        SDL_PushEvent(&amp;event);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char *filename = argv[1];</span><br><span class="line">    SDL_Event event;</span><br><span class="line"></span><br><span class="line">    VideoState *is;</span><br><span class="line">    is = av_malloc(sizeof(VideoState));</span><br><span class="line"></span><br><span class="line">    // Register all formats and codecs</span><br><span class="line">    av_register_all();</span><br><span class="line"></span><br><span class="line">    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER))</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_strlcpy(is-&gt;filename, filename, sizeof(is-&gt;filename));</span><br><span class="line"></span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    schedule_refresh(is, 40);</span><br><span class="line"></span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(decode_thread, &quot;parse_thread&quot;, is);</span><br><span class="line"></span><br><span class="line">    if (!is-&gt;parse_tid)</span><br><span class="line">    &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        switch (event.type)</span><br><span class="line">        &#123;</span><br><span class="line">            case FF_QUIT_EVENT:</span><br><span class="line">            case SDL_QUIT:</span><br><span class="line">                SDL_CondSignal(is-&gt;audioq.cond);</span><br><span class="line">                SDL_CondSignal(is-&gt;videoq.cond);</span><br><span class="line">                is-&gt;quit = 1;</span><br><span class="line">                SDL_Quit();</span><br><span class="line">                return 0;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case FF_ALLOC_EVENT:</span><br><span class="line">                alloc_picture(event.user.data1);</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case FF_REFRESH_EVENT:</span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                LOGI(&quot;event.type = %d&quot;,event.type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif /* __ANDROID__ */</span><br></pre></td></tr></table></figure><h4 id="ktDecodeDisplay-h"><a href="#ktDecodeDisplay-h" class="headerlink" title="ktDecodeDisplay.h"></a>ktDecodeDisplay.h</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">#ifndef _INCLUDED_KTDECODEDISPLAY_H_</span><br><span class="line">#define _INCLUDED_KTDECODEDISPLAY_H_</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;android/native_window_jni.h&gt;</span><br><span class="line">#include &quot;SDL.h&quot;</span><br><span class="line">#include &quot;SDL_thread.h&quot;</span><br><span class="line">#include &quot;SDL_events.h&quot;</span><br><span class="line">#include &quot;ktLog.h&quot;</span><br><span class="line">#include &quot;libavcodec/avcodec.h&quot;</span><br><span class="line">#include &quot;libavformat/avformat.h&quot;</span><br><span class="line">#include &quot;libavutil/pixfmt.h&quot;</span><br><span class="line">#include &quot;libswscale/swscale.h&quot;</span><br><span class="line">#include &quot;libavformat/avio.h&quot;</span><br><span class="line">#include &quot;libavutil/avstring.h&quot;</span><br><span class="line"></span><br><span class="line">#define FILE_PATH_LENGTH   1024</span><br><span class="line">#define SDL_AUDIO_BUFFER_SIZE 1024</span><br><span class="line"></span><br><span class="line">#define MAX_AUDIOQ_SIZE (5 * 16 * 1024)</span><br><span class="line">#define MAX_VIDEOQ_SIZE (5 * 256 * 1024)</span><br><span class="line"></span><br><span class="line">#define AV_SYNC_THRESHOLD 0.01</span><br><span class="line">#define AV_NOSYNC_THRESHOLD 10.0</span><br><span class="line"></span><br><span class="line">#define SAMPLE_CORRECTION_PERCENT_MAX 10</span><br><span class="line">#define AUDIO_DIFF_AVG_NB 20</span><br><span class="line"></span><br><span class="line">#define FF_ALLOC_EVENT   (SDL_USEREVENT)</span><br><span class="line">#define FF_REFRESH_EVENT (SDL_USEREVENT + 1)</span><br><span class="line">#define FF_QUIT_EVENT (SDL_USEREVENT + 2)</span><br><span class="line"></span><br><span class="line">#define VIDEO_PICTURE_QUEUE_SIZE 1</span><br><span class="line"></span><br><span class="line">#define DEFAULT_AV_SYNC_TYPE AV_SYNC_EXTERNAL_MASTER</span><br><span class="line">#define AVCODEC_MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audio</span><br><span class="line"></span><br><span class="line">typedef struct PacketQueue</span><br><span class="line">&#123;</span><br><span class="line">    AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    int nb_packets;</span><br><span class="line">    int size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br><span class="line"></span><br><span class="line">typedef struct VideoPicture  //保存解码出来的图像</span><br><span class="line">&#123;</span><br><span class="line">    SDL_Window *screen;</span><br><span class="line">    SDL_Renderer *renderer;</span><br><span class="line">    SDL_Texture *bmp;</span><br><span class="line"></span><br><span class="line">    AVFrame* rawdata;</span><br><span class="line">    int width, height; /*source height &amp; width*/</span><br><span class="line">    int allocated;</span><br><span class="line">    double pts;</span><br><span class="line">&#125; VideoPicture;</span><br><span class="line"></span><br><span class="line">typedef struct VideoState</span><br><span class="line">&#123;</span><br><span class="line">    char filename[FILE_PATH_LENGTH];</span><br><span class="line">    AVFormatContext *ic;</span><br><span class="line">    int videoStream, audioStream;</span><br><span class="line">    AVStream *audio_st;</span><br><span class="line">    AVFrame *audio_frame;</span><br><span class="line">    PacketQueue audioq;</span><br><span class="line">    unsigned int audio_buf_size;</span><br><span class="line">    unsigned int audio_buf_index;</span><br><span class="line">    AVPacket audio_pkt;</span><br><span class="line">    uint8_t *audio_pkt_data;</span><br><span class="line">    int audio_pkt_size;</span><br><span class="line">    uint8_t *audio_buf;</span><br><span class="line">    DECLARE_ALIGNED(16,uint8_t,audio_buf2) [AVCODEC_MAX_AUDIO_FRAME_SIZE * 4];</span><br><span class="line">    enum AVSampleFormat audio_src_fmt;</span><br><span class="line">    enum AVSampleFormat audio_tgt_fmt;</span><br><span class="line">    int audio_src_channels;</span><br><span class="line">    int audio_tgt_channels;</span><br><span class="line">    int64_t audio_src_channel_layout;</span><br><span class="line">    int64_t audio_tgt_channel_layout;</span><br><span class="line">    int audio_src_freq;</span><br><span class="line">    int audio_tgt_freq;</span><br><span class="line">    struct SwrContext *swr_ctx;</span><br><span class="line"></span><br><span class="line">    AVStream *video_st;</span><br><span class="line">    PacketQueue videoq;</span><br><span class="line"></span><br><span class="line">    VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE];</span><br><span class="line">    int pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex *pictq_mutex;</span><br><span class="line">    SDL_cond *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread *parse_tid;</span><br><span class="line">    SDL_Thread *audio_tid;</span><br><span class="line">    SDL_Thread *video_tid;</span><br><span class="line"></span><br><span class="line">    AVIOContext *io_ctx;</span><br><span class="line">    struct SwsContext *sws_ctx;</span><br><span class="line"></span><br><span class="line">    double audio_clock;</span><br><span class="line"></span><br><span class="line">    int av_sync_type;</span><br><span class="line">    double external_clock;/*external clock base*/</span><br><span class="line">    int64_t external_clock_time;</span><br><span class="line"></span><br><span class="line">    int audio_hw_buf_size;</span><br><span class="line">    double audio_diff_cum;/*used of AV difference average computation*/</span><br><span class="line">    double audio_diff_avg_coef;</span><br><span class="line">    double audio_diff_threshold;</span><br><span class="line">    int audio_diff_avg_count;</span><br><span class="line">    double frame_timer;</span><br><span class="line">    double frame_last_pts;</span><br><span class="line">    double frame_last_delay;</span><br><span class="line"></span><br><span class="line">    double video_current_pts; ///&lt;current displayed pts (different from video_clock if frame fifos are used)</span><br><span class="line">    int64_t video_current_pts_time; ///&lt;time (av_gettime) at which we updated video_current_pts - used to have running video pts</span><br><span class="line"></span><br><span class="line">    double video_clock; ///&lt;pts of last decoded frame / predicted pts of next decoded frame</span><br><span class="line"></span><br><span class="line">    int quit;</span><br><span class="line"></span><br><span class="line">    int file_type   //only video, only audio,both</span><br><span class="line">&#125; VideoState;</span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    AV_SYNC_AUDIO_MASTER,</span><br><span class="line">    AV_SYNC_VIDEO_MASTER,</span><br><span class="line">    AV_SYNC_EXTERNAL_MASTER,</span><br><span class="line">    AV_NO_SYNC_MASTER</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum</span><br><span class="line">&#123;</span><br><span class="line">    AV_AUDIO_ONLY,</span><br><span class="line">    AV_VIDEO_ONLY,</span><br><span class="line">    AV_AUDIO_VIDEO_BOTH</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">VideoState *global_video_state;</span><br><span class="line"></span><br><span class="line">uint64_t global_video_pkt_pts = AV_NOPTS_VALUE;</span><br><span class="line">#endif // _INCLUDED_KTDECODEDISPLAY_H_</span><br></pre></td></tr></table></figure><blockquote><p>为了保证更好的使用，代码做了一些小的修改，发现自己怎么解释代码都不会比原作者解释的清楚，所以最好还是看英文原版的解释吧。</p><p>英文原版的<a href="http://dranger.com/ffmpeg/tutorial01.html" target="_blank" rel="noopener">http://dranger.com/ffmpeg/tutorial01.html</a></p><p>ps：整体上来说，sdl+ffmepg效率是非常高的，在骁龙800的手机上都能实现h264，4k，高码率的软解。如果能深入优化，有希望能流程的播放，而且夸平台性非常好，适合新手了解播放器编解码显示的过程。后来b站开源了ijkplayer，成为了iOS和Android上最好开源跨平台播放器。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;播放器算是手机上用的最多的软件之一，vlc是其中的佼佼者，更是第一大开源软件，但是vlc实在是太重了，附带的几十个开源框架编译都很辛苦。&lt;/p&gt;
&lt;p&gt;其实我只想学习一下视频解码到显示的过程。&lt;/p&gt;
&lt;p&gt;所以我选的方案是ffmpeg解码，sdl
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="播放器" scheme="http://yoursite.com/tags/%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++回调java方法</title>
    <link href="http://yoursite.com/2014/02/09/C-%E5%9B%9E%E8%B0%83java%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2014/02/09/C-回调java方法/</id>
    <published>2014-02-09T09:21:33.000Z</published>
    <updated>2019-04-09T09:27:48.303Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为网上大部分是java调用c或者c++的文章较多，所以写一个留个念想。</p><p>还是直接上代码再来解释</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line">static JavaVM* g_JavaVM = NULL;</span><br><span class="line">static jobject g_InterfaceObject = 0;</span><br><span class="line">static const char *g_JavaClassName = &quot;xxx/xxx/xxxx/Provider&quot;;</span><br><span class="line"></span><br><span class="line">static void GetInterfaceObject(JNIEnv *env, const char *path, jobject *objptr)</span><br><span class="line">&#123;</span><br><span class="line">    jclass cls = env-&gt;FindClass(path);</span><br><span class="line">    if (!cls)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    jmethodID constr = env-&gt;GetMethodID(cls, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">    if (!constr)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    jobject obj = env-&gt;NewObject(cls, constr);</span><br><span class="line">    if (!obj)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    (*objptr) = env-&gt;NewGlobalRef(obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jint JNI_OnLoad(JavaVM *vm, void *reserved)</span><br><span class="line">&#123;</span><br><span class="line">    g_JavaVM = vm;</span><br><span class="line"></span><br><span class="line">    JNIEnv *env;</span><br><span class="line">    if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6) != JNI_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    GetInterfaceObject(env, g_JavaClassName, &amp;g_InterfaceObject);</span><br><span class="line"></span><br><span class="line">    return JNI_VERSION_1_6;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static jobject getInstance(JNIEnv *env, jclass obj_class)</span><br><span class="line">&#123;</span><br><span class="line">    jmethodID  c_id = env-&gt;GetMethodID(obj_class, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</span><br><span class="line">    jobject obj = env-&gt;NewObject(obj_class, c_id);</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ConnectSuccessNotice(const int nWidth, const int nHeight, const int nFps)</span><br><span class="line">&#123;</span><br><span class="line">    if (g_JavaVM == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int status;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    bool isAttached = false;</span><br><span class="line"></span><br><span class="line">    status = g_JavaVM-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line">    if (status &lt; 0)  //</span><br><span class="line">   &#123;</span><br><span class="line">        status = g_JavaVM-&gt;AttachCurrentThread(&amp;env, NULL);</span><br><span class="line">        if (status &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        isAttached = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isAttached)  // </span><br><span class="line">    &#123;</span><br><span class="line">        jclass cls = env-&gt;GetObjectClass(g_InterfaceObject);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            jmethodID mid = env-&gt;GetStaticMethodID(cls, &quot;ConnectSuccessNoticeJavaThread&quot;, &quot;(III)V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                env-&gt;CallStaticVoidMethod(cls, mid, nWidth, nHeight, nFps);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g_JavaVM-&gt;DetachCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    else  // </span><br><span class="line">    &#123;</span><br><span class="line">        jclass cls = env-&gt;FindClass(g_JavaClassName);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            jobject obj = getInstance(env, cls);</span><br><span class="line">            jmethodID mid = env-&gt;GetMethodID(cls, &quot;ConnectSuccessNoticeJava&quot;, &quot;(III)V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                env-&gt;CallVoidMethod(obj, mid, nWidth, nHeight, nFps);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void OnDisconnectedNotice()</span><br><span class="line">&#123;</span><br><span class="line">    if (g_JavaVM == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int status;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    bool isAttached = false;</span><br><span class="line"></span><br><span class="line">    status = g_JavaVM-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (status &lt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">        status = g_JavaVM-&gt;AttachCurrentThread(&amp;env, NULL);</span><br><span class="line">        if (status &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        isAttached = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isAttached)  // </span><br><span class="line">    &#123;</span><br><span class="line">        jclass cls = env-&gt;GetObjectClass(g_InterfaceObject);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            jmethodID mid = env-&gt;GetStaticMethodID(cls, &quot;OnDisconnectedJavaThread&quot;, &quot;()V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                env-&gt;CallStaticVoidMethod(cls, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g_JavaVM-&gt;DetachCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    else  // </span><br><span class="line">    &#123;</span><br><span class="line">        jclass cls = env-&gt;FindClass(g_JavaClassName);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            jobject obj = getInstance(env, cls);</span><br><span class="line">            jmethodID mid = env-&gt;GetMethodID(cls, &quot;OnDisconnectedJava&quot;, &quot;()V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                env-&gt;CallVoidMethod(obj, mid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ReceiveDataCallback(const char *nbuff,const int nLength,const int nKey, const int nTimeStamp, string sDeviceID)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (g_JavaVM == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int status;</span><br><span class="line">    JNIEnv *env = NULL;</span><br><span class="line">    bool isAttached = false;</span><br><span class="line"></span><br><span class="line">    status = g_JavaVM-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_6);</span><br><span class="line"></span><br><span class="line">    if (status &lt; 0)  //</span><br><span class="line">   &#123;</span><br><span class="line">        status = g_JavaVM-&gt;AttachCurrentThread(&amp;env, NULL);</span><br><span class="line">        if (status &lt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        isAttached = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (isAttached)  </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        jclass cls = env-&gt;GetObjectClass(g_InterfaceObject);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            jmethodID mid = env-&gt;GetStaticMethodID(cls, &quot;ReceiveDataCallbackJavaThread&quot;, &quot;(Ljava/lang/String;III[B)V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                jbyteArray jBufferArray = env-&gt;NewByteArray(nLength);</span><br><span class="line">                jbyte *jby =env-&gt;GetByteArrayElements(jBufferArray, 0);</span><br><span class="line"></span><br><span class="line">                memcpy(jby, nbuff, nLength);</span><br><span class="line"></span><br><span class="line">                env-&gt;SetByteArrayRegion(jBufferArray, 0, nLength, jby);</span><br><span class="line"></span><br><span class="line">                jstring jsDeviceID = env-&gt;NewStringUTF(sDeviceID.c_str());</span><br><span class="line"></span><br><span class="line">                env-&gt;CallStaticVoidMethod(cls, mid,jsDeviceID, nLength, nKey, nTimeStamp,jBufferArray);</span><br><span class="line"></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(jBufferArray,jby,0);</span><br><span class="line"></span><br><span class="line">                env-&gt;DeleteLocalRef(jBufferArray);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        g_JavaVM-&gt;DetachCurrentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    else  // PrintNdkLog不是在线程中被调用, 调用Java类成员API</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        jclass cls = env-&gt;FindClass(g_JavaClassName);</span><br><span class="line">        if (cls != 0)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            jobject obj = getInstance(env, cls);</span><br><span class="line">            jmethodID mid = env-&gt;GetMethodID(cls, &quot;ReceiveDataCallbackJava&quot;, &quot;(Ljava/lang/String;III[B)V&quot;);</span><br><span class="line">            if (mid != 0)</span><br><span class="line">            &#123;</span><br><span class="line">                jbyteArray jBufferArray = env-&gt;NewByteArray(nLength);</span><br><span class="line"></span><br><span class="line">                jbyte *jby =env-&gt;GetByteArrayElements(jBufferArray, 0);</span><br><span class="line"></span><br><span class="line">                memcpy(jby, nbuff, nLength);</span><br><span class="line"></span><br><span class="line">                env-&gt;SetByteArrayRegion(jBufferArray, 0, nLength, jby);</span><br><span class="line"></span><br><span class="line">                jstring jsDeviceID = env-&gt;NewStringUTF(sDeviceID.c_str());</span><br><span class="line"></span><br><span class="line">                env-&gt;CallVoidMethod(obj, mid,jsDeviceID, nLength, nKey, nTimeStamp,jBufferArray);</span><br><span class="line"></span><br><span class="line">                env-&gt;ReleaseByteArrayElements(jBufferArray,jby,0);</span><br><span class="line"></span><br><span class="line">                env-&gt;DeleteLocalRef(jBufferArray);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>唯一需要解释的只有两个地方</p><p>第一个就是在NDK中创建的线程中, 只允许调用静态的Java API，只能使CallStaticVoidMethod</p><p>第二个就是JNI_OnLoad，在这里把JavaVM指针保存下来</p><p>重新改方法时，java会先调用该组件的JNI_OnLoad()函数.其用途有二： </p><p>一是：告诉java VM此C组件使用那一个JNI版本。如果你没有提供JNI_OnLoad()函数，VM会默认使用最老的JNI 1.1版本。由于新版的JNI做了许多扩充，如果需要使用JNI的新版功能，例如JNI 1.4的java.nio.ByteBuffer,就必须藉由JNI_OnLoad()函数来告知VM。</p><p>二是：由于VM执行到System.loadLibrary()函数时，就会立即先呼叫JNI_OnLoad()，所以C组件的开发者可以藉由JNI_OnLoad()来进行C组件内的初期值之设定，也就是获取JavaVM接口。</p><p>唯一需注意的就是一定小心内存泄露的问题，java代码如果写多了，也许会不太适应</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;因为网上大部分是java调用c或者c++的文章较多，所以写一个留个念想。&lt;/p&gt;
&lt;p&gt;还是直接上代码再来解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/categories/C/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>stun流程理解</title>
    <link href="http://yoursite.com/2011/01/01/stun/"/>
    <id>http://yoursite.com/2011/01/01/stun/</id>
    <published>2011-01-01T00:59:58.000Z</published>
    <updated>2019-04-08T14:33:13.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><ol><li><p>A向S发出Allocate Request，请求S在自己的IP地址上为A分配一个端口。</p></li><li><p>S收到A的Allocate请求后，为A分配一个端口aport。并向A返回一个Allocate Response。</p></li><li><p>A向S发出Channel Bind请求，请求将B的（IP地址UDP端口）对绑定到一个Channel号ano上。</p></li></ol><p>4.S收到Channel Bind请求后，将Channel号ano和B的（IP地址UDP端口）对绑定，并向A返回一个Channel Bind Success回复。</p><p>5.之后A可以用Channel Data命令通过Channel号ano向B发消息。Channel Data命令实际上将消息发给了S，S再通过为A分配的端口aport向B转发。</p><ol start="6"><li>B收到的A的消息中，源地址显示的是S为A分配的中转地址（S的IP地址:aport），B可以直接向这个中转地址发消息，S会将其转发给A。</li></ol><p><strong>stun协议的缺点是服务器负载太高，容易成为性能瓶颈。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流程&quot;&gt;&lt;a href=&quot;#流程&quot; class=&quot;headerlink&quot; title=&quot;流程&quot;&gt;&lt;/a&gt;流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;A向S发出Allocate Request，请求S在自己的IP地址上为A分配一个端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="NAT" scheme="http://yoursite.com/tags/NAT/"/>
    
      <category term="ICE" scheme="http://yoursite.com/tags/ICE/"/>
    
  </entry>
  
</feed>
