<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>三余无梦生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chiqtv.cn/"/>
  <updated>2019-07-30T13:38:18.910Z</updated>
  <id>http://chiqtv.cn/</id>
  
  <author>
    <name>三鱼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一场没有硝烟的战争</title>
    <link href="http://chiqtv.cn/2019/07/30/%E4%B8%80%E5%9C%BA%E6%B2%A1%E6%9C%89%E7%A1%9D%E7%83%9F%E7%9A%84%E6%88%98%E4%BA%89/"/>
    <id>http://chiqtv.cn/2019/07/30/一场没有硝烟的战争/</id>
    <published>2019-07-30T13:36:06.000Z</published>
    <updated>2019-07-30T13:38:18.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一场没有硝烟的战争"><a href="#一场没有硝烟的战争" class="headerlink" title="一场没有硝烟的战争"></a>一场没有硝烟的战争</h1><p>2年前的一次饭局上艺儿童鞋告诉我，任老板内部讲话是要以全公司之力对抗某国科技界，所有的项目必须有可以实施的C版本的方案，技术完全和某国无关，压力之大可想而知。</p><p>2年后的5月战争开开启了，在某国认为，这也许是一次敲竹杠的好机会，但是在任老板的心中，这是一场战争，或者说这场战争在10年前，华为被美帝各种限制的时候就已经开启了。</p><p>菊厂的核心：圣无线，神终端，海思叼</p><p>某国能动到最大的应该就是菊厂消费者业务，手机，电脑，各种智能设备这些，占据了菊厂50%的收入，假设，某国不惜一切代价搞菊厂，极限情况就是菊厂损失掉这50%的业务，无法动摇菊厂的根基。如果真的这样做了，带来的是彻底在全世界面前撕破脸皮，伤敌1000，自损800，5年内限制菊厂在消费业务上的发展。真的要这样赌一把吗，能吓唬住肯定是最好的，可是唬不住呀。</p><p>关键是狠话已经放了，裤子都脱了，怎么下台的问题，敲竹杠是没戏了，最后还是只能回到谈判桌前，关键是面子问题，磨时间吧。</p><p>整个菊厂的腾飞是在无线业务上，整个无线业务准备这场战争已经多年了，能造成的伤害实在有限。</p><p>和奇怪某国的智囊团是怎么做的决定和选的时间点</p><ol><li><p>菊厂发年终奖，股票分红是5月左右，你选一个敌人刚刚发了子弹的时候开打，这个时间点选的真好。</p></li><li><p>对于这种树大根深的庞然大物，如果无法一击致命，如何收场</p></li><li><p>得道多助失道寡助，当敌人失去道德的底线，菊厂后面能玩的领域也不在受限制了</p></li><li><p>一开始就输了，这不是一场交易，是战争，不是你死就是我亡。</p></li></ol><p>也许当天看到这个消息的任老板心中是大喜的，幸福来的太及时了，准备了多年的战争也终于可以毫无保留的开启了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一场没有硝烟的战争&quot;&gt;&lt;a href=&quot;#一场没有硝烟的战争&quot; class=&quot;headerlink&quot; title=&quot;一场没有硝烟的战争&quot;&gt;&lt;/a&gt;一场没有硝烟的战争&lt;/h1&gt;&lt;p&gt;2年前的一次饭局上艺儿童鞋告诉我，任老板内部讲话是要以全公司之力对抗某国科技界，所有
      
    
    </summary>
    
    
      <category term="菊厂" scheme="http://chiqtv.cn/tags/%E8%8F%8A%E5%8E%82/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出channel/select</title>
    <link href="http://chiqtv.cn/2019/07/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAchannel-select/"/>
    <id>http://chiqtv.cn/2019/07/01/深入浅出channel-select/</id>
    <published>2019-07-01T06:48:37.000Z</published>
    <updated>2019-07-30T09:29:13.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入浅出channel-select"><a href="#深入浅出channel-select" class="headerlink" title="深入浅出channel/select"></a>深入浅出channel/select</h2><blockquote><p><strong>go的编程哲学：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存</strong></p></blockquote><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/zzz.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/xxx.png" alt></p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="优雅的关闭channel"><a href="#优雅的关闭channel" class="headerlink" title="优雅的关闭channel"></a>优雅的关闭channel</h3><ol><li>关闭一个已关闭的通道会引起Panic</li><li>将值发送到已关闭的通道会发生Panic</li></ol><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ch:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">fmt.Println(IsClosed(c)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">fmt.Println(IsClosed(c)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">API server listening at: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8248</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="问题-并发安全的问题"><a href="#问题-并发安全的问题" class="headerlink" title="问题:并发安全的问题"></a>问题:并发安全的问题</h3><h4 id="简单粗暴的方法"><a href="#简单粗暴的方法" class="headerlink" title="简单粗暴的方法"></a>简单粗暴的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// The return result can be altered</span></span><br><span class="line">            <span class="comment">// in a defer function call.</span></span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// assume ch != nil here.</span></span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    ch &lt;- value  <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><ol><li><p>recover性能影响，</p></li><li><p>使用场景有限</p></li></ol><h3 id="更多人采用的方式-sync-Once"><a href="#更多人采用的方式-sync-Once" class="headerlink" title="更多人采用的方式 sync.Once/"></a>更多人采用的方式 sync.Once/</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更优雅的方案"><a href="#更优雅的方案" class="headerlink" title="更优雅的方案"></a>更优雅的方案</h3><ol><li>N 个接收者，一个发送者，发送者通过关闭通道说不再发送</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100 缓冲 int</span></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// the sender</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// The only sender can close the channel safely.</span></span><br><span class="line"><span class="built_in">close</span>(dataCh)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dataCh &lt;- value</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// receivers</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"><span class="comment">// Receive values until dataCh is closed and</span></span><br><span class="line"><span class="comment">// the value buffer queue of dataCh is empty.</span></span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">log.Println(value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关闭原则：发送者处关闭</strong></p><ol start="2"><li><h5 id="一个接收者，N个发送者"><a href="#一个接收者，N个发送者" class="headerlink" title="一个接收者，N个发送者"></a>一个接收者，N个发送者</h5></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line"><span class="comment">// Its sender is the receiver of channel dataCh.</span></span><br><span class="line"><span class="comment">// Its reveivers are the senders of channel dataCh.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// senders</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// the receiver</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line"><span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭原则:</p><ol><li>dataCh可以不必关闭，让系统进行垃圾回收。</li><li>引入额外的信号通道，以通知发送者停止发送。</li></ol><ol start="3"><li><h5 id="M-个接收者，N-个发送者"><a href="#M-个接收者，N-个发送者" class="headerlink" title="M 个接收者，N 个发送者"></a>M 个接收者，N 个发送者</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"log"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line"><span class="string">"strconv"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line">log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line"><span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line"><span class="comment">// Its sender is the moderator goroutine shown below.</span></span><br><span class="line"><span class="comment">// Its reveivers are all senders and receivers of dataCh.</span></span><br><span class="line">toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// The channel toStop is used to notify the moderator</span></span><br><span class="line"><span class="comment">// to close the additional signal channel (stopCh).</span></span><br><span class="line"><span class="comment">// Its senders are any senders and receivers of dataCh.</span></span><br><span class="line"><span class="comment">// Its reveiver is the moderator goroutine shown below.</span></span><br><span class="line"><span class="comment">// It must be a buffered channel.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// moderator</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stoppedBy = &lt;-toStop</span><br><span class="line"><span class="built_in">close</span>(stopCh)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// senders</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">value := rand.Intn(MaxRandomNumber)</span><br><span class="line"><span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Here, the try-send operation is to notify the</span></span><br><span class="line"><span class="comment">// moderator to close the additional signal channel.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"sender#"</span> + id:</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The try-receive operation here is to try to exit the</span></span><br><span class="line"><span class="comment">// sender goroutine as early as possible. Try-receive</span></span><br><span class="line"><span class="comment">// try-send select blocks are specially optimized by the</span></span><br><span class="line"><span class="comment">// standard Go compiler, so they are very efficient.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Even if stopCh is closed, the first branch in this</span></span><br><span class="line"><span class="comment">// select block may be still not selected for some</span></span><br><span class="line"><span class="comment">// loops (and for ever in theory) if the send to dataCh</span></span><br><span class="line"><span class="comment">// is also non-blocking. If this is not acceptable,</span></span><br><span class="line"><span class="comment">// then the above try-receive operation is essential.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// receivers</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// Same as the sender goroutine, the try-receive</span></span><br><span class="line"><span class="comment">// operation here is to try to exit the receiver</span></span><br><span class="line"><span class="comment">// goroutine as early as possible.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Even if stopCh is closed, the first branch in this</span></span><br><span class="line"><span class="comment">// select block may be still not selected for some</span></span><br><span class="line"><span class="comment">// loops (and for ever in theory) if the receive from</span></span><br><span class="line"><span class="comment">// dataCh is also non-blocking. If this is not acceptable,</span></span><br><span class="line"><span class="comment">// then the above try-receive operation is essential.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line"><span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// The same trick is used to notify</span></span><br><span class="line"><span class="comment">// the moderator to close the</span></span><br><span class="line"><span class="comment">// additional signal channel.</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> toStop &lt;- <span class="string">"receiver#"</span> + id:</span><br><span class="line">log.Println(id)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//log.Println(value)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">wgReceivers.Wait()</span><br><span class="line">log.Println(<span class="string">"stopped by"</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关闭原则:</p><ol><li>引入哨兵来保障toStop，通道并非一定要关闭</li></ol></li></ol><blockquote><ol><li><p>不到在接收端关闭通道，发送者如果只有一个，就在发送端关闭，关闭之后并不影响通道消息的接收</p></li><li><p>不要关闭多个并发下的channel</p></li></ol></blockquote><p>###源码分析</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中的数据个数</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span>           <span class="comment">//缓冲期数据大小</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 指向缓冲期数据指针</span></span><br><span class="line">elemsize <span class="keyword">uint16</span>   <span class="comment">//channel大小</span></span><br><span class="line">closed   <span class="keyword">uint32</span>   <span class="comment">//状态</span></span><br><span class="line">elemtype *_type <span class="comment">// channel类型</span></span><br><span class="line">sendx    <span class="keyword">uint</span>   <span class="comment">// 标识当前 Channel 送的已经处理到了数组中的哪个位置。</span></span><br><span class="line">recvx    <span class="keyword">uint</span>   <span class="comment">// 标识当前 Channel 接收已经处理到了数组中的哪个位置。</span></span><br><span class="line">recvq    waitq  <span class="comment">// 存储当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line"><span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line"><span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line"><span class="comment">// with stack shrinking.</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sudog的双向链表</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog  <span class="comment">//表示一个在等待列表中的 Goroutine，对g的封装</span></span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">g *g</span><br><span class="line"></span><br><span class="line"><span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line"><span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">isSelect <span class="keyword">bool</span></span><br><span class="line">next     *sudog</span><br><span class="line">prev     *sudog</span><br><span class="line">elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line"><span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line"><span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line"><span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">acquiretime <span class="keyword">int64</span></span><br><span class="line">releasetime <span class="keyword">int64</span></span><br><span class="line">ticket      <span class="keyword">uint32</span></span><br><span class="line">parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/uuu.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ooo.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ppp.png" alt></p><blockquote><p>通过两个游标（其实就是读取、接收数据的位置）来确定数据的位置，对应sendx/recvx</p><p>速度快，预先读取，类型唯一，大小固定</p></blockquote><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/vvvvv.png" alt></p><blockquote><p>两个双向链表(sendq、recvq)和一个环状队列(buf 基于数组的指针存储)来实现的</p></blockquote><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/bbbbb.png" alt></p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typecheck.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span> <span class="title">case</span> <span class="title">OMAKE</span>:     <span class="title">n</span>.<span class="title">Op</span> = <span class="title">OMAKECHAN</span> </span></span><br><span class="line"><span class="function">//<span class="title">walk</span>.<span class="title">go</span>  </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span>    <span class="title">case</span> <span class="title">OMAKECHAN</span>:   <span class="title">makechan</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">    <span class="comment">//缓冲区大小为0</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">    <span class="comment">//连续内存空间</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"makechan: chan="</span>, c, <span class="string">"; elemsize="</span>, elem.size, <span class="string">"; elemalg="</span>, elem.alg, <span class="string">"; dataqsiz="</span>, size, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####发送ch &lt;- i(往channel写)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walk.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span>    <span class="title">case</span> <span class="title">OSEND</span>:   <span class="title">chansend</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">chan</span>.<span class="title">go</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是阻塞模式，就直接退出</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 情况1：当 chan 为 nil时, 阻塞,让出协程</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line"><span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line"><span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line"><span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line"><span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line"><span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line"><span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line"><span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line"><span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)  <span class="comment">//合法性检查完，锁住整个channel</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//向关闭的channel发送，抛出panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情况2：如果当有 G 在接受队列上等待时，直接将消息发送给 G，</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">    <span class="comment">// send中有个goready(gp, skip+1)可以唤醒 G</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//情况3缓存队列未满，则将消息复制到缓存队列上</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">   <span class="comment">// 通过sendx确定可放入数据的位置， qp其实就是当前这条数据放入的位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//底层依赖于内存屏障来进行数据的拷贝操作</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line">   <span class="comment">// 这里面就是环状队列实现的关键点， 当发送指针等于队列长度就移位到0</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不是阻塞模式，就直接退出，什么时候会走到这里？，感觉是打了一个补丁</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">  <span class="comment">// 获取当前的goroutine</span></span><br><span class="line"> <span class="comment">//情况4： 缓存队列已满，将 G 加入到 send队列中</span></span><br><span class="line">gp := getg()</span><br><span class="line">  <span class="comment">// 从当前m里面获取一个sudog,注意m里面如果不存在就会从当前m对应的p里面获取，如果还没有，就创建一个新的</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">  <span class="comment">// 将当前goroutine放入到sendq队列中，然后调用goparkunlock，通过gopark将当前goroutine暂停，然后释放锁</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line"><span class="comment">// stack tracer.</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line">  <span class="comment">// 被唤醒, 检查是否是被closechan唤醒，如果是就抛出异常,</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">//释放G</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/mmm.png" alt></p><p>同步情况下</p><p>查看Hchan结构体是否为空，步骤1，即是否有因为读该管道而阻塞的goroutine。</p><p>情况1，没有等待的g，阻塞，</p><p>情况2，又等待的g，直接走1.x流程，从目标带走目标，两种情况都是不带缓冲的channel</p><p>带缓冲的情况:</p><p>情况3，buf未满，丢如buf，走2.x</p><p>情况4，buf满的情况下阻塞，等待唤醒，唤醒之后检查状态，走3.x</p><h4 id="接收x-lt-ch-从channel读"><a href="#接收x-lt-ch-从channel读" class="headerlink" title="接收x &lt;- ch(从channel读)"></a>接收x &lt;- ch(从channel读)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line"><span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nil状态的chan，阻塞</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//阻塞，nil的chan，挂起goroutine</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">"unreachable"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line"><span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line"><span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line"><span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line"><span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line"><span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line"><span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">  <span class="comment">//带缓存，无数据，未关闭channel，直接返回(false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//同步锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">  </span><br><span class="line"><span class="comment">//向close且为空的chan中获取消息时，返回空值。</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//send 队列不为空,什么时候send队列不为空呢？ 只有两种可能 1. 无缓存chan  2. 缓存队列已满</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line"><span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line"><span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line"><span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    <span class="comment">// CASE 2.1: 无缓存chan,直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">    <span class="comment">// CASE 2.2: 缓存队列已满, 从队列获取头元素,唤醒send 将其消息加入队列尾部</span></span><br><span class="line">    <span class="comment">//（由于是环线队列，所以尾部和头部是同一位置）移动recvx</span></span><br><span class="line">    <span class="comment">// 同样在recv中有goready(gp, skip+1)可以唤醒G</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 缓存队列不会空，直接从队列获取元素，移动头索引</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Receive directly from queue</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  <span class="comment">// 缓存队列为空， 将当前 G 加入接收队列中， 休眠</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将当前 G 加入 接收队列中</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">  <span class="comment">// 休眠</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recv processes a receive operation on a full channel c.</span></span><br><span class="line"><span class="comment">// There are 2 parts:</span></span><br><span class="line"><span class="comment">// 1) The value sent by the sender sg is put into the channel</span></span><br><span class="line"><span class="comment">//    and the sender is woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// 2) The value received by the receiver (the current G) is</span></span><br><span class="line"><span class="comment">//    written to ep.</span></span><br><span class="line"><span class="comment">// For synchronous channels, both values are the same.</span></span><br><span class="line"><span class="comment">// For asynchronous channels, the receiver gets its data from</span></span><br><span class="line"><span class="comment">// the channel buffer and the sender's data is put in the</span></span><br><span class="line"><span class="comment">// channel buffer.</span></span><br><span class="line"><span class="comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// copy data from sender</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line"><span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line"><span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line"><span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">raceacquireg(sg.g, qp)</span><br><span class="line">racereleaseg(sg.g, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copy data from queue to receiver</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copy data from sender to queue</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5种不同的情况：</p><ol><li>nil状态的chan，阻塞，申明未初始化的状态，初始化内存后继续</li><li>带缓存，无数据，被关闭的channel，直接返回</li><li><p>send 队列不为空的情况，recv处理两者情况</p><ol><li><p>不带缓存的 ，send获取数据</p></li><li><p>带缓存 ，缓存已满 ，从队列获取头元素</p></li></ol></li><li>send为空，缓存队列不会空，直接从队列获取元素，移动头索引</li><li>sned为空，缓存队列为空，将当前 G 加入接收队列中， 休眠</li></ol><h4 id="关闭closed"><a href="#关闭closed" class="headerlink" title="关闭closed"></a>关闭closed</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个 nil channel，panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改状态</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line">   <span class="comment">// 将 channel 所有等待接收队列的里 sudog 释放</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">     <span class="comment">// 从接收队列里出队一个 sudog</span></span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 将 channel 等待发送队列里的 sudog 释放</span></span><br><span class="line">  <span class="comment">// 如果存在，这些 goroutine 将会 panic，想关闭的chan发送数据</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="comment">// 遍历链表,唤醒</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>上锁</p></li><li><p>设置状态，关闭状态</p></li><li><p>接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表</p></li><li><p>解锁</p></li><li><p>所有的 sudog 全都唤醒执行(发送的sender出panic，receiver正常)</p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/iii.png" alt></p></li></ol><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><h3 id="定义：监听多个channel的读写事件，只能和通道连用"><a href="#定义：监听多个channel的读写事件，只能和通道连用" class="headerlink" title="定义：监听多个channel的读写事件，只能和通道连用"></a>定义：监听多个channel的读写事件，只能和通道连用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 准备好几个通道。</span></span><br><span class="line">intChannels := [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line"><span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机选择一个通道，并向它发送元素值。</span></span><br><span class="line">index := rand.Intn(<span class="number">1</span>)</span><br><span class="line">fmt.Printf(<span class="string">"The index: %d\n"</span>, index)</span><br><span class="line">intChannels[index] &lt;- index</span><br><span class="line"><span class="comment">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"default"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">0</span>]:</span><br><span class="line">fmt.Println(<span class="string">"11111111111"</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-intChannels[<span class="number">1</span>]:</span><br><span class="line">fmt.Println(<span class="string">"2222222222"</span>)</span><br><span class="line"><span class="keyword">case</span> elem := &lt;-intChannels[<span class="number">2</span>]:</span><br><span class="line">fmt.Printf(<span class="string">"3333333"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用规则和注意点："><a href="#使用规则和注意点：" class="headerlink" title="使用规则和注意点："></a>使用规则和注意点：</h3><ol><li><p>如果select存在默认分支，select就不会被阻塞，默认分支只能有一个，默认分支可以任何位置。</p></li><li><p>没有默认分支，select被阻塞，直到有一个case表达式满足条件，这个时候select才会被唤醒执行；</p><p>Ps： 如果外层有for语句的，break是无法跳出的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func example2() &#123;</span><br><span class="line">intChan := make(chan int, 1)</span><br><span class="line">// 一秒后关闭通道。</span><br><span class="line">time.AfterFunc(time.Second, func() &#123;</span><br><span class="line">close(intChan)</span><br><span class="line">&#125;)</span><br><span class="line">select &#123;</span><br><span class="line">case _, ok := &lt;-intChan:</span><br><span class="line">if !ok &#123;</span><br><span class="line">fmt.Println(&quot;通道关闭&quot;)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>select语句里面的case表达式求值顺序是从上到下，从左到右</p></li><li>多个case满足条件的时候，是随机选一个，伪随机算法</li><li>要关注表达式和语句本身是否有并发安全的问题。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>src/runtime/select.go</p><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">  selectDir = iota  /// 0 ：表示case 为nil；在send 或者 recv 发生在一个 nil channel 上,通道如果已经关闭，屏蔽分支，设置为nil</span><br><span class="line">  selectSend              // case Chan &lt;- Send 接收通道</span><br><span class="line">  selectRecv              // case &lt;-Chan:  发送通道</span><br><span class="line">  selectDefault           // default</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//选择器的核心结构</span><br><span class="line">type runtimeSelect struct &#123;</span><br><span class="line">dir selectDir</span><br><span class="line">typ unsafe.Pointer // channel type (not used here)</span><br><span class="line">ch  *hchan         // 指向每个case里面的chan操作</span><br><span class="line">val unsafe.Pointer // 发送或者接收数据缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//select每一条case的描述</span><br><span class="line">type scase struct &#123;</span><br><span class="line">c           *hchan         // 当前case所对应的chan引用，一个case只对应一个chan</span><br><span class="line">elem        unsafe.Pointer // 读或者些的缓冲区数据指针</span><br><span class="line">kind        uint16 //类型读，写，默认</span><br><span class="line">pc          uintptr // 用于指示当前将要执行的下一条机器指令的内存地址</span><br><span class="line">releasetime int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码执行顺序"><a href="#源码执行顺序" class="headerlink" title="源码执行顺序"></a>源码执行顺序</h3><p>/refect/value.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select executes a select operation described by the list of cases.</span></span><br><span class="line"><span class="comment">// Like the Go select statement, it blocks until at least one of the cases</span></span><br><span class="line"><span class="comment">// can proceed, makes a uniform pseudo-random choice,</span></span><br><span class="line"><span class="comment">// and then executes that case. It returns the index of the chosen case</span></span><br><span class="line"><span class="comment">// and, if that case was a receive operation, the value received and a</span></span><br><span class="line"><span class="comment">// boolean indicating whether the value corresponds to a send on the channel</span></span><br><span class="line"><span class="comment">// (as opposed to a zero value received because the channel is closed).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">(cases []SelectCase)</span> <span class="params">(chosen <span class="keyword">int</span>, recv Value, recvOK <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Do not trust that caller is not modifying cases data underfoot.</span></span><br><span class="line"><span class="comment">// The range is safe because the caller cannot modify our copy of the len</span></span><br><span class="line"><span class="comment">// and each iteration makes its own copy of the value c.</span></span><br><span class="line">runcases := <span class="built_in">make</span>([]runtimeSelect, <span class="built_in">len</span>(cases))</span><br><span class="line">haveDefault := <span class="literal">false</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">rc := &amp;runcases[i]</span><br><span class="line">rc.dir = c.Dir</span><br><span class="line"><span class="keyword">switch</span> c.Dir &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: invalid Dir"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SelectDefault: <span class="comment">// default</span></span><br><span class="line"><span class="keyword">if</span> haveDefault &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: multiple default cases"</span>)</span><br><span class="line">&#125;</span><br><span class="line">haveDefault = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> c.Chan.IsValid() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: default case has Chan value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.Send.IsValid() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: default case has Send value"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SelectSend:</span><br><span class="line">ch := c.Chan</span><br><span class="line"><span class="keyword">if</span> !ch.IsValid() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch.mustBe(Chan)</span><br><span class="line">ch.mustBeExported()</span><br><span class="line">tt := (*chanType)(unsafe.Pointer(ch.typ))</span><br><span class="line"><span class="keyword">if</span> ChanDir(tt.dir)&amp;SendDir == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: SendDir case using recv-only channel"</span>)</span><br><span class="line">&#125;</span><br><span class="line">rc.ch = ch.pointer()</span><br><span class="line">rc.typ = &amp;tt.rtype</span><br><span class="line">v := c.Send</span><br><span class="line"><span class="keyword">if</span> !v.IsValid() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: SendDir case missing Send value"</span>)</span><br><span class="line">&#125;</span><br><span class="line">v.mustBeExported()</span><br><span class="line">v = v.assignTo(<span class="string">"reflect.Select"</span>, tt.elem, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> v.flag&amp;flagIndir != <span class="number">0</span> &#123;</span><br><span class="line">rc.val = v.ptr</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">rc.val = unsafe.Pointer(&amp;v.ptr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SelectRecv:</span><br><span class="line"><span class="keyword">if</span> c.Send.IsValid() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: RecvDir case has Send value"</span>)</span><br><span class="line">&#125;</span><br><span class="line">ch := c.Chan</span><br><span class="line"><span class="keyword">if</span> !ch.IsValid() &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">ch.mustBe(Chan)</span><br><span class="line">ch.mustBeExported()</span><br><span class="line">tt := (*chanType)(unsafe.Pointer(ch.typ))</span><br><span class="line"><span class="keyword">if</span> ChanDir(tt.dir)&amp;RecvDir == <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"reflect.Select: RecvDir case using send-only channel"</span>)</span><br><span class="line">&#125;</span><br><span class="line">rc.ch = ch.pointer()</span><br><span class="line">rc.typ = &amp;tt.rtype</span><br><span class="line">rc.val = unsafe_New(tt.elem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">chosen, recvOK = rselect(runcases)</span><br><span class="line"><span class="keyword">if</span> runcases[chosen].dir == SelectRecv &#123;</span><br><span class="line">tt := (*chanType)(unsafe.Pointer(runcases[chosen].typ))</span><br><span class="line">t := tt.elem</span><br><span class="line">p := runcases[chosen].val</span><br><span class="line">fl := flag(t.Kind())</span><br><span class="line"><span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">recv = Value&#123;t, p, fl | flagIndir&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">recv = Value&#123;t, *(*unsafe.Pointer)(p), fl&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> chosen, recv, recvOK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本处的初始化，调用调用rselect</span></span><br></pre></td></tr></table></figure><p>runtime/select.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rselect具体实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//没有case阻塞</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">block()</span><br><span class="line">&#125;</span><br><span class="line">sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">rc := &amp;cases[i]</span><br><span class="line"><span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line"><span class="keyword">case</span> selectDefault:</span><br><span class="line">sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line"><span class="keyword">case</span> selectSend:</span><br><span class="line">sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line"><span class="keyword">case</span> selectRecv:</span><br><span class="line">sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled || msanenabled &#123;</span><br><span class="line">selectsetpc(&amp;sel[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前两步基本上都是初始化之类的，核心实现在selectgo中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> debugSelect &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"select: cas0="</span>, cas0, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一步</span></span><br><span class="line"><span class="comment"> 1.初始化</span></span><br><span class="line"><span class="comment"> 2.随机生成一个遍历的轮询顺序 pollOrder 并根据 Channel 地址生成一个用于遍历的锁定顺序 lockOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">scases := cas1[:ncases:ncases]</span><br><span class="line">pollorder := order1[:ncases:ncases]</span><br><span class="line">lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line"><span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">cas := &amp;scases[i]</span><br><span class="line"><span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">*cas = scase&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">scases[i].releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line"><span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line"><span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line"><span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line"><span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line"><span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line"><span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generate permuted order</span></span><br><span class="line">  <span class="comment">//打乱随机</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">pollorder[i] = pollorder[j]</span><br><span class="line">pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line"><span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">  <span class="comment">// 按 hchan 的地址来进行排序，以生成加锁顺序</span></span><br><span class="line">  <span class="comment">// 用堆排序来保证 nLog(n) 的时间复杂度</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">    <span class="comment">// 初始化 lockorder 数组</span></span><br><span class="line">j := i</span><br><span class="line"><span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">c := scases[pollorder[i]].c</span><br><span class="line"><span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">lockorder[j] = lockorder[k]</span><br><span class="line">j = k</span><br><span class="line">&#125;</span><br><span class="line">lockorder[j] = pollorder[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">o := lockorder[i]</span><br><span class="line">c := scases[o].c</span><br><span class="line">lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">k++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">lockorder[j] = lockorder[k]</span><br><span class="line">j = k</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">lockorder[j] = o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugSelect &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"i="</span>, i, <span class="string">" x="</span>, lockorder[i], <span class="string">" y="</span>, lockorder[i+<span class="number">1</span>], <span class="string">"\n"</span>)</span><br><span class="line">throw(<span class="string">"select: broken sort"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">  <span class="comment">//对所有的channel枷锁</span></span><br><span class="line">sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">gp     *g</span><br><span class="line">sg     *sudog</span><br><span class="line">c      *hchan</span><br><span class="line">k      *scase</span><br><span class="line">sglist *sudog</span><br><span class="line">sgnext *sudog</span><br><span class="line">qp     unsafe.Pointer</span><br><span class="line">nextp  **sudog</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line"><span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line"><span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> dfl *scase</span><br><span class="line"><span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> cas *scase</span><br><span class="line"><span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">//for遍历，ready的直接goto跳出去</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">cas = &amp;scases[casi]</span><br><span class="line">c = cas.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line"><span class="keyword">case</span> caseNil:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseRecv:</span><br><span class="line">      <span class="comment">// &lt;- ch</span></span><br><span class="line">sg = c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> recv</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> bufrecv</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> rclose</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseSend:</span><br><span class="line">      <span class="comment">//ch &lt;- 1</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> sclose</span><br><span class="line">&#125;</span><br><span class="line">sg = c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> send</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="keyword">goto</span> bufsend</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseDefault:</span><br><span class="line">dfli = casi</span><br><span class="line">dfl = cas</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">//进了 caseDefault 才会走到</span></span><br><span class="line"><span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">casi = dfli</span><br><span class="line">cas = dfl</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">  <span class="comment">//没有任何一个 case 满足，且没有 default</span></span><br><span class="line">gp = getg()</span><br><span class="line"><span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">&#125;</span><br><span class="line">nextp = &amp;gp.waiting</span><br><span class="line">  <span class="comment">//按照加锁的顺序把 gorutine 入每一个 channel 的等待队列</span></span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">casi = <span class="keyword">int</span>(casei)</span><br><span class="line">cas = &amp;scases[casi]</span><br><span class="line"><span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">c = cas.c</span><br><span class="line">sg := acquireSudog()</span><br><span class="line">sg.g = gp</span><br><span class="line">sg.isSelect = <span class="literal">true</span></span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line"><span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">sg.elem = cas.elem</span><br><span class="line">sg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">sg.c = c</span><br><span class="line"><span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">*nextp = sg</span><br><span class="line">nextp = &amp;sg.waitlink</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//不同的类型进入不同的队列</span></span><br><span class="line"><span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line"><span class="keyword">case</span> caseRecv:</span><br><span class="line">c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> caseSend:</span><br><span class="line">c.sendq.enqueue(sg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for someone to wake us up</span></span><br><span class="line">  <span class="comment">//当前 goroutine 进入休眠，等待被唤醒</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">gp.selectDone = <span class="number">0</span></span><br><span class="line">sg = (*sudog)(gp.param)</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line"><span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line"><span class="comment">// record the successful case, if any.</span></span><br><span class="line"><span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">  <span class="comment">//被唤醒</span></span><br><span class="line">casi = <span class="number">-1</span></span><br><span class="line">cas = <span class="literal">nil</span></span><br><span class="line">sglist = gp.waiting</span><br><span class="line"><span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line"><span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">sg1.isSelect = <span class="literal">false</span></span><br><span class="line">sg1.elem = <span class="literal">nil</span></span><br><span class="line">sg1.c = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">k = &amp;scases[casei]</span><br><span class="line"><span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">k.releasetime = sglist.releasetime</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line"><span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">casi = <span class="keyword">int</span>(casei)</span><br><span class="line">cas = k</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c = k.c</span><br><span class="line"><span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">c.sendq.dequeueSudoG(sglist)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.recvq.dequeueSudoG(sglist)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sgnext = sglist.waitlink</span><br><span class="line">sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">releaseSudog(sglist)</span><br><span class="line">sglist = sgnext</span><br><span class="line">&#125;</span><br><span class="line">   <span class="comment">//唤醒的时候，param = nil 没有合适的再次loop</span></span><br><span class="line"><span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line"><span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line"><span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line"><span class="comment">// we'll see that it's now closed.</span></span><br><span class="line"><span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line"><span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line"><span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class="line"><span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line"><span class="comment">// so we won't block again.</span></span><br><span class="line"><span class="keyword">goto</span> loop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c = cas.c</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugSelect &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"wait-return: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">" cas="</span>, cas, <span class="string">" kind="</span>, cas.kind, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line"><span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">msanread(cas.elem, c.elemtype.size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line"><span class="comment">// can receive from buffer</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">&#125;</span><br><span class="line">raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">racerelease(chanbuf(c, c.recvx))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">&#125;</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line">qp = chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line"><span class="comment">// can send to buffer</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">racerelease(chanbuf(c, c.sendx))</span><br><span class="line">raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(cas.elem, c.elemtype.size)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line"><span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> debugSelect &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">recvOK = <span class="literal">true</span></span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line"><span class="comment">// read at end of closed channel</span></span><br><span class="line">  <span class="comment">//读取关闭的channel</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line">recvOK = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line"><span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(cas.elem, c.elemtype.size)</span><br><span class="line">&#125;</span><br><span class="line">send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span> debugSelect &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line"><span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line"><span class="comment">// send on closed channel</span></span><br><span class="line">  <span class="comment">//向关闭的channel发送数据，触发panic</span></span><br><span class="line">selunlock(scases, lockorder)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>初始化，核心就是把case实例打乱</p></li><li><p>锁住所有的channel</p></li><li><p>循环，查找准备就绪的channel，四种不同的情况处理 <code>select</code> 中的多个 <code>case</code>：</p><ol><li><code>caseNil</code> — 当前 <code>case</code> 不包含任何的 Channel，就直接会被跳过；</li><li><code>caseRecv</code> — 当前 <code>case</code> 会从 Channel 中接收数据；<ul><li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine 就会直接跳到 <code>recv</code> 标签所在的代码段，从 Goroutine 中获取最新发送的数据；</li><li>如果当前 Channel 的缓冲区不为空就会跳到 ` 标签处从缓冲区中获取数据；</li><li>如果当前 Channel 已经被关闭就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li></ul></li><li>caseSend — 当前 case 会向 Channel 发送数据；<ul><li>如果当前 Channel 已经被关闭就会直接跳到 <code>sclose</code> 代码段；</li><li>如果当前 Channel 的 <code>recvq</code> 上有等待的 Goroutine 就会跳到 <code>send</code> 代码段向 Channel 直接发送数据；</li></ul></li></ol></li><li><p>caseDefault  如果循环执行到了这种情况就表示前面的所有 <code>case</code> 都没有被执行，所以这里会直接解锁所有的 Channel 并退出 <code>selectgo</code> 函数，这时也就意味着当前 <code>select</code> 结构中的其他收发语句都是非阻塞的。</p></li></ol><p>   <img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/111111.png" alt></p><ol start="5"><li><p>阻塞状态，进入下一个循环，加入c.sendq.dequeueSudoG(sglist)/c.recvq.dequeueSudoG(sglist)</p></li><li><p><code>sudog</code> 结构体都会被串成链表附着在当前 Goroutine 上，在入队之后会调用 <code>gopark</code> 函数挂起当前的 Goroutine 等待调度器的唤醒。</p><p>gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)</p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/22222222.png" alt></p></li><li><p>根据 lockOrder 遍历全部 case 的过程中，我们会先获取 Goroutine 接收到的参数 param，这个参数其实就是被唤醒的 sudog 结构，其他的全部释放掉releaseSudog(sglist)</p></li><li><p>跳到不同的状态执行</p></li></ol><h4 id="回顾整个过程："><a href="#回顾整个过程：" class="headerlink" title="回顾整个过程："></a>回顾整个过程：</h4><h3 id><a href="#" class="headerlink" title></a><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/aaa.png" alt></h3><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/bbb.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ccc.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ddd.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/fff.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ggg.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/hhh.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/jjj.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/kkk.png" alt></p><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/lll.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入浅出channel-select&quot;&gt;&lt;a href=&quot;#深入浅出channel-select&quot; class=&quot;headerlink&quot; title=&quot;深入浅出channel/select&quot;&gt;&lt;/a&gt;深入浅出channel/select&lt;/h2&gt;&lt;blockquo
      
    
    </summary>
    
      <category term="go" scheme="http://chiqtv.cn/categories/go/"/>
    
    
      <category term="协程" scheme="http://chiqtv.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出goroutine</title>
    <link href="http://chiqtv.cn/2019/06/01/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAgoroutine/"/>
    <id>http://chiqtv.cn/2019/06/01/深入浅出goroutine/</id>
    <published>2019-06-01T06:48:37.000Z</published>
    <updated>2019-07-30T12:13:36.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深入浅出goroutine"><a href="#深入浅出goroutine" class="headerlink" title="深入浅出goroutine"></a>深入浅出goroutine</h2><h3 id="并发和并行理解"><a href="#并发和并行理解" class="headerlink" title="并发和并行理解"></a>并发和并行理解</h3><blockquote><p>并发是同一时间应对（dealing with）多件事情的能力。<br>并行是同一时间动手（doing）做多件事情的能力。</p></blockquote><h3 id="栗子：打印0-9的数字"><a href="#栗子：打印0-9的数字" class="headerlink" title="栗子：打印0-9的数字"></a>栗子：打印0-9的数字</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用goroutine，增加一个go关键字</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Go 程序在运行时也总会有一个主 goroutine。这个主goroutine会在程序运行的时候启动</p></li><li><p>语法 go func()，函数做为goroutine入口函数</p></li><li><p>goroutine函数执行的时间，顺序默认是不可控的，实际上是放入goroutine队列中</p></li><li><p>低成本，不需要操作系统参与</p></li><li><p>异步并发</p></li></ol><p>go 主程序程序执行完goroutine没有获得运行的机会，程序就结束了，解决办法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line">sign := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, num) <span class="comment">//初始化Channel,并且可以设置容量:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">sign &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">//发送struct到sign中</span></span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 办法1。</span></span><br><span class="line"><span class="comment">//time.Sleep(time.Millisecond * 500)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 办法2。</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; num; j++ &#123;</span><br><span class="line">&lt;-sign <span class="comment">//从sign中接收数据，这个表达式会一直被block,直到有数据可以接收。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更好的解决办法，sync.WaitGroup，Add(), Done(), Wait()</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">wg.Add(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待执行结束</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="理解线程模型-线程与内核调度实体（KSE，Kernel-Scheduling-Entity）之间的对应关系"><a href="#理解线程模型-线程与内核调度实体（KSE，Kernel-Scheduling-Entity）之间的对应关系" class="headerlink" title="理解线程模型(线程与内核调度实体（KSE，Kernel Scheduling Entity）之间的对应关系)"></a>理解线程模型(线程与内核调度实体（KSE，Kernel Scheduling Entity）之间的对应关系)</h3><p>用户态和内核态</p><ol><li><p>简单理解：当一个进程在执行用户自己的代码时处于用户运行态（用户态）；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），简单点理解就是控制计算机的硬件资源。</p></li><li><p>权限不同，x86架构的cpu一共有四个级别，0-3级，0级特权级最高，3级特权级最低，用户态为3，内核为0，访问的地址空间也有限制</p></li><li>切换：1.系统调用， 2.异常  3.外围设备的中断</li><li>内核线程是一种只运行在内核地址空间的线程，共享同一份内核页表，32位系统3-4g虚拟地址空间，所以也共享同一份内核页表。<strong>这也是为什么叫内核线程，而不叫内核进程的原因</strong>。</li></ol><h4 id="用户级线程模型"><a href="#用户级线程模型" class="headerlink" title="用户级线程模型"></a>用户级线程模型</h4><ol><li>用户线程与内核线程KSE是多对一（N : 1）的映射模型</li><li>操作系统只管理用户进程，对线程无感知，内核的所有调度都是基于用户进程，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责</li><li><p>一个进程中所有创建的线程都只和同一个KSE在运行时动态绑定</p></li><li><p>大部分的协程库都属于这种方式（比如python的gevent），libco(阻塞让出,hook系统函数)</p></li><li><p>问题：并不能做到真正意义上的并发，假设在某个用户进程上的某个用户线程因为一个阻塞调用（比如I/O阻塞）而被CPU给中断（抢占式调度）了，那么该进程内的所有线程都被阻塞（因为单个用户进程内的线程自调度是没有CPU时钟中断的，从而没有轮转调度），整个进程被挂起。即便是多CPU的机器，也无济于事，因为在用户级线程模型下，一个CPU关联运行的是整个用户进程，进程内的子线程绑定到CPU执行是由用户进程调度的，内部线程对CPU是不可见的，此时可以理解为CPU的调度单位是用户进程。</p><p>解决办法：很多的协程库会把自己一些阻塞的操作重新封装为完全的非阻塞形式，然后在以前要阻塞的点上，主动让出自己，并通过某种方式通知或唤醒其他待执行的用户线程在该KSE上运行，从而避免了内核调度器由于KSE阻塞而做上下文切换，这样整个进程也不会被阻塞了</p></li></ol><h4 id="内核级线程模型"><a href="#内核级线程模型" class="headerlink" title="内核级线程模型"></a>内核级线程模型</h4><ol><li>用户线程与内核线程KSE是一对一（1 : 1）的映射模型，也就是每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成</li><li>大部分编程语言的线程库(比如Java的java.lang.Thread、C++11的std::thread等等)都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的KSE静态绑定，因此其调度完全由操作系统内核调度器去做。</li><li>优点：，直接借助操作系统内核的线程以及调度器，所以CPU可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理</li><li>缺点：由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，对性能影响很大</li></ol><h4 id="两级线程模型（也称混合型线程模型）"><a href="#两级线程模型（也称混合型线程模型）" class="headerlink" title="两级线程模型（也称混合型线程模型）"></a>两级线程模型（也称混合型线程模型）</h4><ol><li>用户线程与内核KSE是多对多（N : M）的映射模型，并非绑定</li><li>一个进程可以与多个内核线程KSE关联，于是进程内的多个线程可以动态绑定不同的KSE</li><li>某个KSE因为其绑定的线程的阻塞操作被内核调度出CPU时，其关联的进程中其余用户线程可以重新与其他KSE绑定运行</li><li>用户调度器实现用户线程到KSE的调度，内核调度器实现KSE到CPU上的调度</li><li>Go语言中的runtime调度器就是采用的这种实现方案，实现了Goroutine与KSE之间的动态关联</li></ol><h3 id="go语言的goroutine实现"><a href="#go语言的goroutine实现" class="headerlink" title="go语言的goroutine实现"></a>go语言的goroutine实现</h3><h4 id="G-P-M-模型"><a href="#G-P-M-模型" class="headerlink" title="G-P-M 模型"></a>G-P-M 模型</h4><ol><li><p>G ：goroutine合集</p></li><li><p>P：processor，线程上下文，虚拟运算环境资源，P的数量决定了系统内最大可并行的G的数量（前提：物理CPU核数 &gt;= P的数量），P的数量由用户设置的GOMAXPROCS决定，但是不论GOMAXPROCS设置为多大，P的数量最大为256，P提供了相关的执行环境(Context)，如内存分配状态(mcache)，任务队列(G)等，更多的是为了方便在不同的M切换。</p></li><li><p>M：Machine，OS线程抽象，代表着真正执行计算的资源，在绑定有效的P后，进入schedule循环，M的数量是不定的，由Go Runtime调整，为了防止创建过多OS线程导致系统调度不过来，目前默认最大限制为10000个。</p></li></ol><ul><li><p>每个P维护一个G的本地队列；</p></li><li><p>当一个G被创建出来，或者变为可执行状态时，就把他放到P的可执行队列中；</p></li><li><p>当一个G在M里执行结束后，P会从队列中把该G取出；如果此时P的队列为空，即没有其他G可以执行， M就随机选择另外一个P，从其可执行的G队列中取走一半。</p></li></ul><p><img src="//chiqtv.cn/2019/06/01/深入浅出goroutine/33.png" alt></p><p><img src="//chiqtv.cn/2019/06/01/深入浅出goroutine/4.png" alt></p><h5 id="正常流程："><a href="#正常流程：" class="headerlink" title="正常流程："></a>正常流程：</h5><ol><li><p>通过<code>go</code>关键字创建一个新的goroutine</p></li><li><p>被放入一个全局的p队列</p></li><li><p>被放入一个本地的p队列</p></li><li><p>m和p映射绑定，为了运行g</p></li><li><p>运行g</p></li><li><p>m查看本地的p队列里面还有g没有</p></li><li><p>p会去全局的p队列中查找</p></li><li><p><code>work-stealing</code>调度算法</p></li><li><p>去其他的p（随机）中偷窃g运行</p></li></ol><h5 id="阻塞的情况下，两种状态，系统阻塞，用户阻塞"><a href="#阻塞的情况下，两种状态，系统阻塞，用户阻塞" class="headerlink" title="阻塞的情况下，两种状态，系统阻塞，用户阻塞"></a>阻塞的情况下，两种状态，系统阻塞，用户阻塞</h5><h5 id="系统调用阻塞"><a href="#系统调用阻塞" class="headerlink" title="系统调用阻塞"></a>系统调用阻塞</h5><ol><li>运行的G0阻塞的时候（可以需要IO），</li><li>G会阻塞在<code>_Gsyscall</code>状态，M也处于 block on syscall 状态</li><li>执行该G的M会与P解绑，而P则尝试与其它idle的M绑定。</li><li>执行其它G</li><li>没有其它idle的M，但P的Local队列中仍然有G需要执行，则创建一个新的M</li></ol><h5 id="用户调用阻塞"><a href="#用户调用阻塞" class="headerlink" title="用户调用阻塞"></a>用户调用阻塞</h5><ol><li>对应的G会被放置到某个wait队列，</li><li>该G的状态由<code>_Gruning</code>变为<code>_Gwaitting</code></li><li>M会跳过该G尝试获取并执行下一个G</li><li>此时没有runnable的G供M运行，那么M将解绑P，并进入sleep状态</li><li>当阻塞的G被另一端的G2唤醒时</li><li>G被标记为runnable，尝试加入G2所在P的runnext</li></ol><p><img src="//chiqtv.cn/2019/06/01/深入浅出goroutine/2.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps：在Go 1.0发布的时候，它的调度器其实G-M模型，也就是没有P的，调度过程全由G和M完成，全局锁的问题，带来性能很低。，后续版本裁引入p，印证一句哈，所有的计算机问题都可以通过一个中间层来解决。</span><br></pre></td></tr></table></figure><p><strong>G-P-M模型的定义放在src/runtime/runtime2.go里面，调度过程则放在了src/runtime/proc.go</strong></p><h3 id="优化：协程池"><a href="#优化：协程池" class="headerlink" title="优化：协程池"></a>优化：协程池</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><ol><li>pool 是一个通用的协程池，支持不同类型的任务，亦即每一个任务绑定一个函数提交到池中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">pool.<span class="keyword">go</span></span><br><span class="line"><span class="comment">//协程池数据结构</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">//Pool的容量，也就是开启worker数量的上限，每一个worker绑定一个goroutine</span></span><br><span class="line"> capacity <span class="keyword">int32</span></span><br><span class="line">   <span class="comment">//当前正在执行任务的worker数量</span></span><br><span class="line"> running <span class="keyword">int32</span></span><br><span class="line"><span class="comment">// worker的过期时长</span></span><br><span class="line">expiryDuration time.Duration</span><br><span class="line"><span class="comment">//存放空闲worker</span></span><br><span class="line">workers []*Worker</span><br><span class="line"><span class="comment">//当关闭该Pool支持通知所有worker退出运行以防goroutine泄露</span></span><br><span class="line">release <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lock for synchronous operation.</span></span><br><span class="line">lock sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="comment">// cond for waiting to get a idle worker.</span></span><br><span class="line">cond *sync.Cond</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保Pool关闭操作只会执行一次。</span></span><br><span class="line">once sync.Once</span><br><span class="line"></span><br><span class="line">  <span class="comment">//worker临时对象池，在复用worker时减少新对象的创建并加速worker从pool中的获取速度</span></span><br><span class="line">workerCache sync.Pool</span><br><span class="line"></span><br><span class="line"><span class="comment">//pool引发panic时的执行函数</span></span><br><span class="line">PanicHandler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">pool</span>初始化</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">NewPool</span><span class="params">(size <span class="keyword">int</span>)</span> <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> NewTimingPool(size, DEFAULT_CLEAN_INTERVAL_TIME)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimingPool</span><span class="params">(size, expiry <span class="keyword">int</span>)</span> <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//检查参数</span></span><br><span class="line"><span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidPoolSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//清理时间间隔，DEFAULT_CLEAN_INTERVAL_TIME = 1</span></span><br><span class="line"><span class="keyword">if</span> expiry &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ErrInvalidPoolExpiry</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := &amp;Pool&#123;</span><br><span class="line">capacity:       <span class="keyword">int32</span>(size),</span><br><span class="line">expiryDuration: time.Duration(expiry) * time.Second,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p.cond = sync.NewCond(&amp;p.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独开始协程，启动定期清理过期worker任务</span></span><br><span class="line"><span class="keyword">go</span> p.periodicallyPurge()</span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务到pool中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Submit</span><span class="params">(task <span class="keyword">func</span>()</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//关闭pool时候将release值设置为1</span></span><br><span class="line"><span class="keyword">if</span> CLOSED == atomic.LoadInt32(&amp;p.release) &#123;</span><br><span class="line"><span class="keyword">return</span> ErrPoolClosed</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取一个可用的worker，并加入</span></span><br><span class="line">p.retrieveWorker().task &lt;- task</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回可用执行task的work</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">retrieveWorker</span><span class="params">()</span> *<span class="title">Worker</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> w *Worker</span><br><span class="line"></span><br><span class="line">p.lock.Lock()</span><br><span class="line">idleWorkers := p.workers</span><br><span class="line">n := <span class="built_in">len</span>(idleWorkers) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//有空闲worker，从队列尾部取出一个使用</span></span><br><span class="line">w = idleWorkers[n]</span><br><span class="line">idleWorkers[n] = <span class="literal">nil</span></span><br><span class="line">p.workers = idleWorkers[:n]</span><br><span class="line">p.lock.Unlock()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> p.Running() &lt; p.Cap() &#123; <span class="comment">//判断是否达到上限没有</span></span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="comment">// 当前pool中无空闲worker,且pool数量未达到上线</span></span><br><span class="line">   <span class="comment">// pool会先从临时对象池中寻找是否有已完成任务的worker,</span></span><br><span class="line">   <span class="comment">// 若临时对象池中不存在，则重新创建一个worker并将其启动</span></span><br><span class="line"><span class="keyword">if</span> cacheWorker := p.workerCache.Get(); cacheWorker != <span class="literal">nil</span> &#123;</span><br><span class="line">w = cacheWorker.(*Worker)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">w = &amp;Worker&#123;</span><br><span class="line">pool: p,</span><br><span class="line">task: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span>, <span class="title">workerChanCap</span>),</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">w</span>.<span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">&#125; <span class="title">else</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">//阻塞等待直到有空闲worker,防止无节制地创建goroutine,大量创建g，导致系统无法复用g</span></span><br><span class="line">p.cond.Wait()</span><br><span class="line">l := <span class="built_in">len</span>(p.workers) - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> l &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">w = p.workers[l]</span><br><span class="line">p.workers[l] = <span class="literal">nil</span></span><br><span class="line">p.workers = p.workers[:l]</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//worker 执行完任务后放回Pool </span></span><br><span class="line"><span class="comment">//使得其余正在阻塞的任务可以获取worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">revertWorker</span><span class="params">(worker *Worker)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> CLOSED == atomic.LoadInt32(&amp;p.release) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">worker.recycleTime = time.Now()</span><br><span class="line">p.lock.Lock()</span><br><span class="line">p.workers = <span class="built_in">append</span>(p.workers, worker)</span><br><span class="line"><span class="comment">//释放worker回pool</span></span><br><span class="line">p.cond.Signal()</span><br><span class="line">p.lock.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//过期清理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">periodicallyPurge</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//心跳定时器1秒</span></span><br><span class="line">heartbeat := time.NewTicker(p.expiryDuration)</span><br><span class="line"><span class="keyword">defer</span> heartbeat.Stop()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> heartbeat.C &#123;</span><br><span class="line"><span class="keyword">if</span> CLOSED == atomic.LoadInt32(&amp;p.release) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">currentTime := time.Now()</span><br><span class="line">p.lock.Lock()</span><br><span class="line">idleWorkers := p.workers</span><br><span class="line">n := <span class="number">-1</span></span><br><span class="line"><span class="comment">//遍历可用worker时前面的往往里当前时间越久</span></span><br><span class="line"><span class="keyword">for</span> i, w := <span class="keyword">range</span> idleWorkers &#123;</span><br><span class="line"><span class="keyword">if</span> currentTime.Sub(w.recycleTime) &lt;= p.expiryDuration &#123;</span><br><span class="line"><span class="comment">//计算当前时间减去该worker的最后运行时间之差是否符合过期时长,实为过期，</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">n = i</span><br><span class="line">w.task &lt;- <span class="literal">nil</span></span><br><span class="line">idleWorkers[i] = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &gt;= <span class="built_in">len</span>(idleWorkers)<span class="number">-1</span> &#123;</span><br><span class="line"><span class="comment">// 全部过期</span></span><br><span class="line">p.workers = idleWorkers[:<span class="number">0</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 部分过期</span></span><br><span class="line">p.workers = idleWorkers[n+<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">p.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">work.<span class="keyword">go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">struct</span> &#123;</span><br><span class="line"> pool *Pool</span><br><span class="line">   task <span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> <span class="title">recycleTime</span> <span class="title">time</span>.<span class="title">Time</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//执行任务</span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(w *Worker)</span> <span class="title">run</span><span class="params">()</span></span> &#123;</span><br><span class="line">w.pool.incRunning()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//处理各种各种问题引发panic</span></span><br><span class="line">w.pool.decRunning()</span><br><span class="line">w.pool.workerCache.Put(w)</span><br><span class="line"><span class="keyword">if</span> w.pool.PanicHandler != <span class="literal">nil</span> &#123;</span><br><span class="line">w.pool.PanicHandler(p)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"worker exits from a panic: %v"</span>, p)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> f := <span class="keyword">range</span> w.task &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="literal">nil</span> == f &#123;</span><br><span class="line"><span class="comment">//任务队列中的函数全部被执行完后，</span></span><br><span class="line"><span class="comment">//pool中正在执行的worker数 -1，</span></span><br><span class="line"><span class="comment">//将worker 放回对象池</span></span><br><span class="line">w.pool.decRunning()</span><br><span class="line">w.pool.workerCache.Put(w)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line"><span class="comment">//回收复用,执行完后放回pool</span></span><br><span class="line"><span class="comment">//使得其余正在阻塞的任务可以获取worker</span></span><br><span class="line"><span class="keyword">if</span> ok := w.pool.revertWorker(w); !ok &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="//chiqtv.cn/2019/06/01/深入浅出goroutine/33333.png" alt> </p><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><table><thead><tr><th style="text-align:center">协程数量=100000000</th><th>NoPool</th><th>AntsPool(AntsSize = 2000000)</th><th>AntsPool（AntsSize = int32(size)）</th></tr></thead><tbody><tr><td style="text-align:center">go 1.8.2</td><td>600s(ran too long)</td><td>149.56s(12125 MB)</td><td>149.56s(9450 MB)</td></tr><tr><td style="text-align:center">go1.12.5</td><td>33.07s(6183 MB)</td><td>62.70s(1866 MB)</td><td>59.46s（1564 MB）</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAntsPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> ants.Release()</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">ants.Submit(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">demoFunc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNoPool</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">demoFunc()</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li><p>go语言的协程太强了，对比libco之类的协程库来说，单机千万级的并发</p></li><li><p>go语言新版本协程优化性能提升明显，数量级上的提升</p></li><li>协程池对go语言来说带来的好处就是内存的可控，对于新版本来说并不会秒杀原生并发的goroutine。</li></ol><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h4><ol><li>go 中 runtime 包的一个函数。</li><li><p>它设置了 P 的最多的个数，1.5之后默认为runtime.GOMAXPROCS(runtime.NumCPU())，最大256。</p></li><li><p>GOMAXPROCS可以控制并发或者是并行，并行必须cpu大于1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"runtime"</span></span><br><span class="line"><span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trace</span><span class="params">(start, end <span class="keyword">int8</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> i := start; i &lt;= end; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c "</span>, i)</span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">runtime.GOMAXPROCS(<span class="number">1</span>) <span class="comment">//限制只有一个逻辑处理器</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup <span class="comment">//用于等待所有协程都完成</span></span><br><span class="line">wg.Add(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">//程序退出的时候执行</span></span><br><span class="line">trace(<span class="string">'a'</span>, <span class="string">'z'</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done() <span class="comment">//程序退出的时候执行</span></span><br><span class="line">trace(<span class="string">'A'</span>, <span class="string">'Z'</span>)</span><br><span class="line">&#125;()</span><br><span class="line">wg.Wait() <span class="comment">//等待所有协程的完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="竞争状态处理方式"><a href="#竞争状态处理方式" class="headerlink" title="竞争状态处理方式"></a>竞争状态处理方式</h3><ul><li><p>使用原子函数操作  </p><p>atomic</p></li><li><p>使用互斥锁锁住临界区</p><p> mutex.Lock()/mutex.Unlock()</p></li><li><p>使用通道<code>chan</code></p><p>不要通过共享内存来通信，而应该通过通信来共享内存。</p></li></ul><ol><li><p>channel 提供了一种通信机制</p></li><li><p>channel 本身还需关联了一个类型，也就是 channel 可以发送数据的类型</p></li><li><p>channel创建，读写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int)</span><br><span class="line">close(ch)</span><br><span class="line">/*</span><br><span class="line">channel有两种，带缓冲的和不带缓冲的，默认不带缓冲的channel中，每一个发送者与接收者都会阻塞当前线程，</span><br><span class="line">带缓冲的如果超过容量大小，也会导致阻塞，导致死锁。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//往channel写</span><br><span class="line">ch &lt;- x</span><br><span class="line"></span><br><span class="line">//从channel读</span><br><span class="line">x &lt;- ch</span><br></pre></td></tr></table></figure></li><li><p>channel可进行<code>3种操作</code>：读，写，关闭，组合3种channel状态可以组合出9钟情况</p><p>ps:<strong>有1个特殊场景</strong>：当<code>nil</code>的通道在<code>select</code>的某个<code>case</code>中时，这个case会阻塞，但不会造成死锁</p><p>| 操作      | nil的channel | 正常channel | 已关闭channel |<br>| ——— | ———— | ———– | ————- |<br>| &lt;- ch     | 阻塞         | 成功或阻塞  | 读到零值      |<br>| ch &lt;-     | 阻塞         | 成功或阻塞  | panic         |<br>| close(ch) | panic        | 成功        | panic         |</p></li><li><p>struct{}类型channel </p><p>使用channel传递信号</p><p>channel struct{}是可以带缓冲</p></li><li><p>select</p><p>监听channel数据流动，select默认是阻塞的，只有当监听的channel中有发送或接收可以进行时才会运行，当多个channel都准备好的时候，select是随机的选择一个执行的</p><p>处理timeout超时</p></li></ol><h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><blockquote><p>compile: version “go1.9” does not match go tool version “go1.9.1”<br> 参考：<a href="https://stackoverflow.com/questions/46693653/compile-version-go1-9-does-not-match-go-tool-version-go1-9-1" target="_blank" rel="noopener">https://stackoverflow.com/questions/46693653/compile-version-go1-9-does-not-match-go-tool-version-go1-9-1</a></p></blockquote><p>解决办法 </p><p>open -e .bash_profile </p><p> export GOROOT=/usr/local/opt/go/libexec</p><p>source ~/.bash_profile</p><h3 id="go语言版本切换"><a href="#go语言版本切换" class="headerlink" title="go语言版本切换"></a>go语言版本切换</h3><h2 id="安装GVM"><a href="#安装GVM" class="headerlink" title="安装GVM"></a>安装GVM</h2><blockquote><p>bash &lt; &lt;(curl -s -S -L <a href="https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer" target="_blank" rel="noopener">https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer</a>)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装指定版本gvm install go1.4.1 -B  </span><br><span class="line">查看所有版本gvm list</span><br><span class="line">切换版本 gvm use go1.9.7</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深入浅出goroutine&quot;&gt;&lt;a href=&quot;#深入浅出goroutine&quot; class=&quot;headerlink&quot; title=&quot;深入浅出goroutine&quot;&gt;&lt;/a&gt;深入浅出goroutine&lt;/h2&gt;&lt;h3 id=&quot;并发和并行理解&quot;&gt;&lt;a href=&quot;#并发
      
    
    </summary>
    
      <category term="go" scheme="http://chiqtv.cn/categories/go/"/>
    
    
      <category term="协程" scheme="http://chiqtv.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>从一道最常见的面试题聊起-浏览器输入网址后发生的故事</title>
    <link href="http://chiqtv.cn/2019/05/01/%E4%BB%8E%E4%B8%80%E9%81%93%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98%E8%81%8A%E8%B5%B7-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E6%95%85%E4%BA%8B/"/>
    <id>http://chiqtv.cn/2019/05/01/从一道最常见的面试题聊起-浏览器输入网址后发生的故事/</id>
    <published>2019-05-01T00:59:58.000Z</published>
    <updated>2019-06-18T12:45:46.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="从一道最常见的面试题聊起-浏览器输入网址后发生的故事"><a href="#从一道最常见的面试题聊起-浏览器输入网址后发生的故事" class="headerlink" title="从一道最常见的面试题聊起-浏览器输入网址后发生的故事"></a>从一道最常见的面试题聊起-浏览器输入网址后发生的故事</h1><h3 id="dns解析"><a href="#dns解析" class="headerlink" title="dns解析"></a>dns解析</h3><ol><li><p>dns解析的完整流程 ，本地缓存，域名服务器，udp协议</p></li><li><p>dns解析各种问题,dns劫持，dns设计缺陷，安全隐患，易被攻击等</p></li><li><p>互联网产品解决方案，HttpDNS，大厂基于HttpDNS的优化，全局精确流量调度等。</p></li><li><p>大致的流程，结合wireshark抓包分析，应该可以看的非常清楚</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.本机向local dns请求www.baidu.com</span><br><span class="line">2.local dns向根域请求www.baidu.com，根域返回com.域的服务器IP</span><br><span class="line">3.向com.域请求www.baidu.com，com.域返回baidu.com域的服务器IP</span><br><span class="line">4.向baidu.com请求www.baidu.com，返回cname www.a.shifen.com和a.shifen.com域的服务器IP</span><br><span class="line">5.向root域请求www.a.shifen.com</span><br><span class="line">6.向com.域请求www.a.shife.com</span><br><span class="line">7.向shifen.com请求</span><br><span class="line">8.向a.shifen.com域请求</span><br><span class="line">9.拿到www.a.shifen.com的IP</span><br><span class="line">10.localdns返回本机www.baidu.com cname www.a.shifen.com 以及 www.a.shifen.com的IP</span><br></pre></td></tr></table></figure></li></ol><h3 id="发送http请求报文，第一部https证书过程"><a href="#发送http请求报文，第一部https证书过程" class="headerlink" title="发送http请求报文，第一部https证书过程"></a>发送http请求报文，第一部https证书过程</h3><ol><li>https整个加密流程，</li><li>中间人攻击，</li><li>解决方案，证书验证模式（AFSSLPinningModeCertificate）</li></ol><h3 id="传输层：tcp的三次握手四次挥手过程"><a href="#传输层：tcp的三次握手四次挥手过程" class="headerlink" title="传输层：tcp的三次握手四次挥手过程"></a>传输层：tcp的三次握手四次挥手过程</h3><h3 id="应用层：http协议相关"><a href="#应用层：http协议相关" class="headerlink" title="应用层：http协议相关"></a>应用层：http协议相关</h3><ol><li><p>发送http请求报文</p><p><img src="//chiqtv.cn/2019/05/01/从一道最常见的面试题聊起-浏览器输入网址后发生的故事/2222.png" alt></p></li></ol><p>8种http请求方法，http各个版本，每个版本之间的差异，常见的状态码，5种referrer策略</p><p>响应头各种信息，<a href="https://www.runoob.com/http/http-header-fields.html" target="_blank" rel="noopener">详情说明见</a></p><h3 id="浏览器显示"><a href="#浏览器显示" class="headerlink" title="浏览器显示"></a>浏览器显示</h3><ol><li><p>处理HTML标记并构建DOM树</p></li><li><p>处理CSS标记并构建CSSOM树</p></li><li><p>将DOM和CSSOM合并成一个渲染树</p></li><li><p>根据渲染树来布局，以计算每个节点的几何信息</p></li><li><p>绘制到屏幕上</p></li></ol><p>不同的浏览器内核处理方式还有一些差异，详情可以见：<a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">介绍 WebKit 和 Gecko 内部操作的入门文章</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;从一道最常见的面试题聊起-浏览器输入网址后发生的故事&quot;&gt;&lt;a href=&quot;#从一道最常见的面试题聊起-浏览器输入网址后发生的故事&quot; class=&quot;headerlink&quot; title=&quot;从一道最常见的面试题聊起-浏览器输入网址后发生的故事&quot;&gt;&lt;/a&gt;从一道最常见的面
      
    
    </summary>
    
      <category term="面试" scheme="http://chiqtv.cn/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="浏览器" scheme="http://chiqtv.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="面试" scheme="http://chiqtv.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>nginx编译参数</title>
    <link href="http://chiqtv.cn/2019/04/29/nginx%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0/"/>
    <id>http://chiqtv.cn/2019/04/29/nginx编译参数/</id>
    <published>2019-04-29T10:10:11.000Z</published>
    <updated>2019-04-29T12:55:35.223Z</updated>
    
    <content type="html"><![CDATA[<h4 id="nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。"><a href="#nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。" class="headerlink" title="nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。"></a>nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">--help                             print this message</span><br><span class="line"></span><br><span class="line">--prefix=PATH                      set installation prefix</span><br><span class="line">--sbin-path=PATH                   set nginx binary pathname</span><br><span class="line">--modules-path=PATH                set modules path</span><br><span class="line">--conf-path=PATH                   set nginx.conf pathname</span><br><span class="line">--error-log-path=PATH              set error log pathname</span><br><span class="line">--pid-path=PATH                    set nginx.pid pathname</span><br><span class="line">--lock-path=PATH                   set nginx.lock pathname</span><br><span class="line"></span><br><span class="line">--user=USER                        set non-privileged user for</span><br><span class="line">                                   worker processes</span><br><span class="line">--group=GROUP                      set non-privileged group for</span><br><span class="line">                                   worker processes</span><br><span class="line"></span><br><span class="line">--build=NAME                       set build name</span><br><span class="line">--builddir=DIR                     set build directory</span><br><span class="line"></span><br><span class="line">--with-select_module               enable select module</span><br><span class="line">--without-select_module            disable select module</span><br><span class="line">--with-poll_module                 enable poll module</span><br><span class="line">--without-poll_module              disable poll module //select poll epoll kqueue（freebsd）,io多路复用</span><br><span class="line"></span><br><span class="line">--with-threads                     enable thread pool support//  针对长耗时操作丢线程池，避免阻塞，基准测试9倍的提升</span><br><span class="line"></span><br><span class="line">--with-file-aio                    enable file AIO support//多个io请求给内核，内核进行io请求合并优化，2.6.22以上</span><br><span class="line">--with-http_ssl_module             enable ngx_http_ssl_module</span><br><span class="line">--with-http_v2_module              enable ngx_http_v2_module</span><br><span class="line">--with-http_realip_module          enable ngx_http_realip_module</span><br><span class="line">--with-http_addition_module        enable ngx_http_addition_module //响应之后追加文本内容</span><br><span class="line">--with-http_xslt_module            enable ngx_http_xslt_module//XSLT模板转换XML应答，依赖libxml2和libxslt库</span><br><span class="line">--with-http_xslt_module=dynamic    enable dynamic ngx_http_xslt_module //支持动态加载，创建一个modules的子目录中</span><br><span class="line">--with-http_image_filter_module    enable ngx_http_image_filter_module  //针对图片处理，缩放图片，旋转图片，验证图片，影响性能</span><br><span class="line">--with-http_image_filter_module=dynamic</span><br><span class="line">                                   enable dynamic ngx_http_image_filter_module</span><br><span class="line">--with-http_geoip_module           enable ngx_http_geoip_module //ip获取位置</span><br><span class="line">--with-http_geoip_module=dynamic   enable dynamic ngx_http_geoip_module</span><br><span class="line">--with-http_sub_module             enable ngx_http_sub_module//过滤器，通过将一个指定的字符串替换为另一个字符串来修改响应</span><br><span class="line">--with-http_dav_module             enable ngx_http_dav_module//http扩展协议dav，增加一些方法</span><br><span class="line">--with-http_flv_module             enable ngx_http_flv_module flv流媒体文件支持,flv.js</span><br><span class="line">--with-http_mp4_module             enable ngx_http_mp4_module mp4流媒体文件支持</span><br><span class="line">--with-http_gunzip_module          enable ngx_http_gunzip_module  对不支持gzip的客户端返回解压后的数据</span><br><span class="line">--with-http_gzip_static_module     enable ngx_http_gzip_static_module  //静态文件</span><br><span class="line">--with-http_auth_request_module    enable ngx_http_auth_request_module 鉴权</span><br><span class="line">--with-http_random_index_module    enable ngx_http_random_index_module  //随机页面</span><br><span class="line">--with-http_secure_link_module     enable ngx_http_secure_link_module  //比较简单防止盗链下载</span><br><span class="line">--with-http_degradation_module     enable ngx_http_degradation_module  //内存不足的时候返回204，444</span><br><span class="line">--with-http_slice_module           enable ngx_http_slice_module     //文件切片</span><br><span class="line">--with-http_stub_status_module     enable ngx_http_stub_status_module  //ng运行状态监控</span><br><span class="line"></span><br><span class="line">--without-http_charset_module      disable ngx_http_charset_module  //数据进行字符集转换等</span><br><span class="line">--without-http_gzip_module         disable ngx_http_gzip_module //gzip_comp_level设置</span><br><span class="line">--without-http_ssi_module          disable ngx_http_ssi_module //网页制作技术，在页面内容发送到客户端之前，使用SSI指令将文本、图片或代码信息包含到网页中</span><br><span class="line">--without-http_userid_module       disable ngx_http_userid_module  //cookie</span><br><span class="line">--without-http_access_module       disable ngx_http_access_module   //设置ip访问段</span><br><span class="line">--without-http_auth_basic_module   disable ngx_http_auth_basic_module//访问网页鉴权</span><br><span class="line">--without-http_mirror_module       disable ngx_http_mirror_module   //流量镜像</span><br><span class="line">--without-http_autoindex_module    disable ngx_http_autoindex_module //打开目录浏览功能，下载</span><br><span class="line">--without-http_geo_module          disable ngx_http_geo_module //负载均衡，白名单限速</span><br><span class="line">--without-http_map_module          disable ngx_http_map_module //创建映射表，配合其他模块</span><br><span class="line">--without-http_split_clients_module disable ngx_http_split_clients_module  //A/B测试</span><br><span class="line">--without-http_referer_module      disable ngx_http_referer_module  //防盗链</span><br><span class="line">--without-http_rewrite_module      disable ngx_http_rewrite_module //使用正则表达式（PCRE）改变请求的URI，返回重定向</span><br><span class="line">--without-http_proxy_module        disable ngx_http_proxy_module  //反向代理</span><br><span class="line">--without-http_fastcgi_module      disable ngx_http_fastcgi_module //集成cgi</span><br><span class="line">--without-http_uwsgi_module        disable ngx_http_uwsgi_module  //uwsgi协议Django</span><br><span class="line">--without-http_scgi_module         disable ngx_http_scgi_module//允许将请求传递给SCGI服务器</span><br><span class="line">--without-http_grpc_module         disable ngx_http_grpc_module //gRPC支持</span><br><span class="line">--without-http_memcached_module    disable ngx_http_memcached_module //memcached访问支持</span><br><span class="line">--without-http_limit_conn_module   disable ngx_http_limit_conn_module //同一ip连接数限制</span><br><span class="line">--without-http_limit_req_module    disable ngx_http_limit_req_module //每个ip每秒请求数</span><br><span class="line">--without-http_empty_gif_module    disable ngx_http_empty_gif_module //返回空白gif，解决浏览器访问网站favicon，缺少，导致404错误警告</span><br><span class="line">--without-http_browser_module      disable ngx_http_browser_module//解析User-Agent</span><br><span class="line">--without-http_upstream_hash_module</span><br><span class="line">                                   disable ngx_http_upstream_hash_module//几种hash算法负载均衡</span><br><span class="line">--without-http_upstream_ip_hash_module</span><br><span class="line">                                   disable ngx_http_upstream_ip_hash_module//IP哈希策略，同一ip分配同一服务器</span><br><span class="line">--without-http_upstream_least_conn_module</span><br><span class="line">                                   disable ngx_http_upstream_least_conn_module//最少连接数的负载均衡</span><br><span class="line">                                   disable ngx_http_upstream_random_module</span><br><span class="line">--without-http_upstream_keepalive_module</span><br><span class="line">                                   disable ngx_http_upstream_keepalive_module//客户端和服务器连接超时时间</span><br><span class="line">--without-http_upstream_zone_module</span><br><span class="line">                                   disable ngx_http_upstream_zone_module //zone指令。定义共享内存zone的名称和大小， 共享内存zone用于保存集群配置和运行时状态</span><br><span class="line"></span><br><span class="line">--with-http_perl_module            enable ngx_http_perl_module //实现Perl的location和变量处理</span><br><span class="line">--with-http_perl_module=dynamic    enable dynamic ngx_http_perl_module</span><br><span class="line">--with-perl_modules_path=PATH      set Perl modules path</span><br><span class="line">--with-perl=PATH                   set perl binary pathname</span><br><span class="line"></span><br><span class="line">--http-log-path=PATH               set http access log pathname</span><br><span class="line">--http-client-body-temp-path=PATH  set path to store</span><br><span class="line">                                   http client request body temporary files</span><br><span class="line">--http-proxy-temp-path=PATH        set path to store</span><br><span class="line">                                   http proxy temporary files</span><br><span class="line">--http-fastcgi-temp-path=PATH      set path to store</span><br><span class="line">                                   http fastcgi temporary files</span><br><span class="line">--http-uwsgi-temp-path=PATH        set path to store</span><br><span class="line">                                   http uwsgi temporary files</span><br><span class="line">--http-scgi-temp-path=PATH         set path to store</span><br><span class="line">                                   http scgi temporary files</span><br><span class="line"></span><br><span class="line">--without-http                     disable HTTP server</span><br><span class="line">--without-http-cache               disable HTTP cache</span><br><span class="line"></span><br><span class="line">--with-mail                        enable POP3/IMAP4/SMTP proxy module</span><br><span class="line">--with-mail=dynamic                enable dynamic POP3/IMAP4/SMTP proxy module</span><br><span class="line">--with-mail_ssl_module             enable ngx_mail_ssl_module</span><br><span class="line">--without-mail_pop3_module         disable ngx_mail_pop3_module</span><br><span class="line">--without-mail_imap_module         disable ngx_mail_imap_module</span><br><span class="line">--without-mail_smtp_module         disable ngx_mail_smtp_module</span><br><span class="line"></span><br><span class="line">--with-stream                      enable TCP/UDP proxy module  //模拟反代基于tcp或udp的服务连接，即工作于传输层的反代或调度器</span><br><span class="line">--with-stream=dynamic              enable dynamic TCP/UDP proxy module</span><br><span class="line">--with-stream_ssl_module           enable ngx_stream_ssl_module</span><br><span class="line">--with-stream_realip_module        enable ngx_stream_realip_module</span><br><span class="line">--with-stream_geoip_module         enable ngx_stream_geoip_module</span><br><span class="line">--with-stream_geoip_module=dynamic enable dynamic ngx_stream_geoip_module</span><br><span class="line">--with-stream_ssl_preread_module   enable ngx_stream_ssl_preread_module</span><br><span class="line">--without-stream_limit_conn_module disable ngx_stream_limit_conn_module</span><br><span class="line">--without-stream_access_module     disable ngx_stream_access_module</span><br><span class="line">--without-stream_geo_module        disable ngx_stream_geo_module</span><br><span class="line">--without-stream_map_module        disable ngx_stream_map_module</span><br><span class="line">--without-stream_split_clients_module</span><br><span class="line">                                   disable ngx_stream_split_clients_module</span><br><span class="line">--without-stream_return_module     disable ngx_stream_return_module</span><br><span class="line">--without-stream_upstream_hash_module</span><br><span class="line">                                   disable ngx_stream_upstream_hash_module</span><br><span class="line">--without-stream_upstream_least_conn_module</span><br><span class="line">                                   disable ngx_stream_upstream_least_conn_module</span><br><span class="line">--without-stream_upstream_random_module</span><br><span class="line">                                   disable ngx_stream_upstream_random_module</span><br><span class="line">--without-stream_upstream_zone_module</span><br><span class="line">                                   disable ngx_stream_upstream_zone_module</span><br><span class="line"></span><br><span class="line">--with-google_perftools_module     enable ngx_google_perftools_module  //google perftool优化性能</span><br><span class="line">--with-cpp_test_module             enable ngx_cpp_test_module</span><br><span class="line"></span><br><span class="line">--add-module=PATH                  enable external module</span><br><span class="line">--add-dynamic-module=PATH          enable dynamic external module</span><br><span class="line"></span><br><span class="line">--with-compat                      dynamic modules compatibility</span><br><span class="line"></span><br><span class="line">--with-cc=PATH                     set C compiler pathname</span><br><span class="line">--with-cpp=PATH                    set C preprocessor pathname</span><br><span class="line">--with-cc-opt=OPTIONS              set additional C compiler options</span><br><span class="line">--with-ld-opt=OPTIONS              set additional linker options</span><br><span class="line">--with-cpu-opt=CPU                 build for the specified CPU, valid values:</span><br><span class="line">                                   pentium, pentiumpro, pentium3, pentium4,</span><br><span class="line">                                   athlon, opteron, sparc32, sparc64, ppc64</span><br><span class="line"></span><br><span class="line">--without-pcre                     disable PCRE library usage</span><br><span class="line">--with-pcre                        force PCRE library usage</span><br><span class="line">--with-pcre=DIR                    set path to PCRE library sources</span><br><span class="line">--with-pcre-opt=OPTIONS            set additional build options for PCRE</span><br><span class="line">--with-pcre-jit                    build PCRE with JIT compilation support</span><br><span class="line"></span><br><span class="line">--with-zlib=DIR                    set path to zlib library sources</span><br><span class="line">--with-zlib-opt=OPTIONS            set additional build options for zlib</span><br><span class="line">--with-zlib-asm=CPU                use zlib assembler sources optimized</span><br><span class="line">                                   for the specified CPU, valid values:</span><br><span class="line">                                   pentium, pentiumpro</span><br><span class="line"></span><br><span class="line">--with-libatomic                   force libatomic_ops library usage</span><br><span class="line">--with-libatomic=DIR               set path to libatomic_ops library sources</span><br><span class="line"></span><br><span class="line">--with-openssl=DIR                 set path to OpenSSL library sources</span><br><span class="line">--with-openssl-opt=OPTIONS         set additional build options for OpenSSL</span><br><span class="line"></span><br><span class="line">--with-debug                       enable debug logging</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。&quot;&gt;&lt;a href=&quot;#nginx的编译参数认真看一遍还是收获颇丰，做个笔记算是留个念想。&quot; class=&quot;headerlink&quot; title=&quot;nginx的编译参数认真看一遍还是收获颇丰，做个笔记
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="nginx" scheme="http://chiqtv.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>流媒体服务器</title>
    <link href="http://chiqtv.cn/2019/04/29/%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://chiqtv.cn/2019/04/29/流媒体服务器/</id>
    <published>2019-04-29T06:48:37.000Z</published>
    <updated>2019-04-29T09:31:49.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nginx（nginx-rtmp-module）-obs-实现直播"><a href="#nginx（nginx-rtmp-module）-obs-实现直播" class="headerlink" title="nginx（nginx-rtmp-module）+ obs 实现直播"></a>nginx（nginx-rtmp-module）+ obs 实现直播</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>obs的跨平台性非常好，代码质量也非常高，功能非常完善和强大，基本上大部分的pc端的直播产品都是基于obs开发来的。</li><li>nginx + obs这套环境搭载非常简单，加上代码编译基本上一天之类怎么都弄完了</li><li>nginx-rtmp-module 代码可读性非常强。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ol><li>延迟太高了，局域网测试基本上都是10s的延迟</li><li>nginx-rtmp-module还是只能是demo级的解决方案，如果要做成产品，必须要改修改很多地方，网上也有比较好的基于nginx-rtmp-module的开源方案，个人比较推荐<a href="https://github.com/winshining/nginx-http-flv-module" target="_blank" rel="noopener">nginx-http-flv-module</a>。</li></ol><h3 id="整体的架构"><a href="#整体的架构" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="//chiqtv.cn/2019/04/29/流媒体服务器/11111.png" alt></p><ol><li>一些非流媒体数据，比如传输一些二进制文件，所以会需要自定义媒体服务转发服务。</li><li>第三方的流媒体服务更多是做cdn，解决延迟和并发的问题，阿里，百度，网易都有提供，百度的延迟很高，不推荐。</li></ol><h3 id="发现的问题："><a href="#发现的问题：" class="headerlink" title="发现的问题："></a>发现的问题：</h3><ol><li><p>nginx-rtmp-module导致cpu 100%</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static ngx_int_t</span><br><span class="line">ngx_rtmp_mp4_parse(ngx_rtmp_session_t *s, u_char *pos, u_char *last)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t                   *hdr, tag;</span><br><span class="line">    size_t                      size, nboxes;</span><br><span class="line">    ngx_uint_t                  n;</span><br><span class="line">    ngx_rtmp_mp4_box_t         *b;</span><br><span class="line"></span><br><span class="line">    while (pos != last) &#123;</span><br><span class="line">        if (pos + 8 &gt; last) &#123;</span><br><span class="line">            ngx_log_debug1(NGX_LOG_DEBUG_RTMP, s-&gt;connection-&gt;log, 0,</span><br><span class="line">                           &quot;mp4: too small box: size=%i&quot;, last - pos);</span><br><span class="line">            return NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hdr = (uint32_t *) pos;</span><br><span class="line">        size = ngx_rtmp_r32(hdr[0]);</span><br><span class="line">        </span><br><span class="line">        //部分视频的size可能为0，只有视频没有音频流</span><br><span class="line">        if(0 == size) return NGX_ERROR; </span><br><span class="line">        //导致while死循环，添加这行代码解决</span><br><span class="line"></span><br><span class="line">        tag  = hdr[1];</span><br><span class="line"></span><br><span class="line">        if (pos + size &gt; last) &#123;</span><br><span class="line">            ngx_log_error(NGX_LOG_ERR, s-&gt;connection-&gt;log, ngx_errno,</span><br><span class="line">                          &quot;mp4: too big box &apos;%*s&apos;: size=%uz&quot;,</span><br><span class="line">                          4, &amp;tag, size);</span><br><span class="line">            return NGX_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        b = ngx_rtmp_mp4_boxes;</span><br><span class="line">        nboxes = sizeof(ngx_rtmp_mp4_boxes) / sizeof(ngx_rtmp_mp4_boxes[0]);</span><br><span class="line"></span><br><span class="line">        for (n = 0; n &lt; nboxes &amp;&amp; b-&gt;tag != tag; ++n, ++b);</span><br><span class="line"></span><br><span class="line">        if (n == nboxes) &#123;</span><br><span class="line">            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s-&gt;connection-&gt;log, 0,</span><br><span class="line">                           &quot;mp4: box unhandled &apos;%*s&apos;&quot;, 4, &amp;tag);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ngx_log_debug2(NGX_LOG_DEBUG_RTMP, s-&gt;connection-&gt;log, 0,</span><br><span class="line">                           &quot;mp4: box &apos;%*s&apos;&quot;, 4, &amp;tag);</span><br><span class="line">            b-&gt;handler(s, pos + 8, pos + size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pos += size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>找问题的方法，perf可以找到占用cpu的函数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#原来不是内置的程序，之前有安装过，使用yum安装</span><br><span class="line">yum -y install perf</span><br><span class="line">#使用方法</span><br><span class="line">perf top -p &quot;nginx work process的pid&quot;</span><br></pre></td></tr></table></figure><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rtmp &#123;    </span><br><span class="line">    server &#123;    </span><br><span class="line">            listen 1935;           </span><br><span class="line">            application live &#123;    </span><br><span class="line">                live on;    </span><br><span class="line">            &#125;  </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br></pre></td></tr></table></figure><h4 id="开源方案存在的问题主要是，延迟，和稳定性，点播对各种稀奇古怪媒体文件的兼容性处理，并发，cdn的问题可以选一家好点的云主机厂商解决。"><a href="#开源方案存在的问题主要是，延迟，和稳定性，点播对各种稀奇古怪媒体文件的兼容性处理，并发，cdn的问题可以选一家好点的云主机厂商解决。" class="headerlink" title="开源方案存在的问题主要是，延迟，和稳定性，点播对各种稀奇古怪媒体文件的兼容性处理，并发，cdn的问题可以选一家好点的云主机厂商解决。"></a>开源方案存在的问题主要是，延迟，和稳定性，点播对各种稀奇古怪媒体文件的兼容性处理，并发，cdn的问题可以选一家好点的云主机厂商解决。</h4><h2 id="easydarwin-EasyPusher"><a href="#easydarwin-EasyPusher" class="headerlink" title="easydarwin + EasyPusher"></a>easydarwin + EasyPusher</h2><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ol><li>easydarwin 支持Windows、Linux、macOS平台,代码质量很高，本身是基于苹果开源的 Darwin Streaming Server的go语言重写版本，算是把  Darwin Streaming Server重新又维护了起来，并增加了非常多的实用功能，分为商业版本和开源版本</li><li>EasyPusher也提供了Android，iOS，PC客户端，并且开源</li><li>局域网延迟比起ng要小很多，大概就1-2s</li><li>有web端的管理后台</li><li>商用产品非常多，最开始是基于摄像头，监控项目发展而来的，稳定性方面没什么问题。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>商业版本功能强大，但是要收费。</li></ol><h3 id="整体的架构-1"><a href="#整体的架构-1" class="headerlink" title="整体的架构"></a>整体的架构</h3><p><img src="//chiqtv.cn/2019/04/29/流媒体服务器/2222.png" alt></p><h2 id="甲方要求"><a href="#甲方要求" class="headerlink" title="甲方要求"></a>甲方要求</h2><ol><li><p>局域网内pc端画面同步到移动端，延迟100毫秒内，他们现有产品我实测只有20毫秒，不知道他们自己测试过没有，我自己搭建的开源方案简单优化只有要1.4s</p></li><li><p>甲方现有方案已经没有人维护了，要找人继续搞起走。</p><p><img src="//chiqtv.cn/2019/04/29/流媒体服务器/3333.jpeg" alt></p></li><li><p>如果这个外包能成功接下来，我再来分析一把他们的源码，感觉真心写的不错，把延迟控制的这么小，单从安装包来看，应该是用c/c++写的，没有用c#，qt这些框架。</p></li><li>最初我很武断的认为延迟在100ms内是很难的事情，虽然是局域网，结果就是啪啪打脸，对技术还是不够严谨。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nginx（nginx-rtmp-module）-obs-实现直播&quot;&gt;&lt;a href=&quot;#nginx（nginx-rtmp-module）-obs-实现直播&quot; class=&quot;headerlink&quot; title=&quot;nginx（nginx-rtmp-module）+ 
      
    
    </summary>
    
      <category term="流媒体服务器" scheme="http://chiqtv.cn/categories/%E6%B5%81%E5%AA%92%E4%BD%93%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="nginx" scheme="http://chiqtv.cn/tags/nginx/"/>
    
      <category term="直播" scheme="http://chiqtv.cn/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="EasyDarwin" scheme="http://chiqtv.cn/tags/EasyDarwin/"/>
    
      <category term="obs" scheme="http://chiqtv.cn/tags/obs/"/>
    
  </entry>
  
  <entry>
    <title>redis知识点思维导图</title>
    <link href="http://chiqtv.cn/2019/04/28/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://chiqtv.cn/2019/04/28/redis知识点思维导图/</id>
    <published>2019-04-28T00:22:45.000Z</published>
    <updated>2019-04-28T00:26:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="根据最近学习redis相关内容总结的一个redis知识点思维导图"><a href="#根据最近学习redis相关内容总结的一个redis知识点思维导图" class="headerlink" title="根据最近学习redis相关内容总结的一个redis知识点思维导图"></a>根据最近学习redis相关内容总结的一个redis知识点思维导图</h2><p><img src="//chiqtv.cn/2019/04/28/redis知识点思维导图/redis知识点思维导图.png" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;根据最近学习redis相关内容总结的一个redis知识点思维导图&quot;&gt;&lt;a href=&quot;#根据最近学习redis相关内容总结的一个redis知识点思维导图&quot; class=&quot;headerlink&quot; title=&quot;根据最近学习redis相关内容总结的一个redis知识点
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://chiqtv.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>三场有趣的发布会</title>
    <link href="http://chiqtv.cn/2019/04/23/%E4%B8%89%E5%9C%BA%E6%9C%89%E8%B6%A3%E7%9A%84%E5%8F%91%E5%B8%83%E4%BC%9A/"/>
    <id>http://chiqtv.cn/2019/04/23/三场有趣的发布会/</id>
    <published>2019-04-23T12:59:58.000Z</published>
    <updated>2019-04-29T02:06:47.734Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019小米电视新品"><a href="#2019小米电视新品" class="headerlink" title="2019小米电视新品"></a>2019小米电视新品</h2><ol><li><p>不变的性价比 3999的65寸首发价格就可以看出来，双11妥妥的2999，性价比对小米来说是毒药也是解药。</p></li><li><p>不断强化AIoT，小米肯定希望自家的AIoT能成为强有力的护城河，小米的杂货铺也是顺势推出各种新品。</p></li><li><p>适当的时间点推出壁画电视，壁画电视首发应该是tcl，三星等，但是价格基本都在2万左右，肯定是无法走量的，小米6999的价格不高不低，很容易切入消费者的购买点，颜值即正义，同样颜值即购买欲，小米这波操作还是很强的，最合适的时间点做最合适的事情。</p></li><li><p>产品的创新点几乎没有，加入了视频通话，这个需求算是2年前小米社区呼声很高的需求，同时也被小米社区官方采纳了，还好的是终于被加入了，大部分公司，产品的需求应该来自用户，而不是来自产品经理，除非有苹果那么强的创新能力，实际情况是需求来自领导。</p></li><li><p>电视寡头格局基本上已经形成了，前几名2019年应该都会过1k万台，唯一的看点就是华为如何入局，破局，低端电视已经完全没有利润空间了，65寸今年双11杀到2k内都是有可能的，每家都想做高端电视，但是高端电视的创新点又在哪里，显示效果肯定是做不过三星，sony，lg等一线大厂，剩下来的就只能拼软实力了，所以这几年，ai，iot，视频数量成为了各家宣传亮点，再剩下来就只有杀红眼的价格，压缩渠道费，走线上。</p></li><li><p>从华为手机上的成功来看，消费者是非常愿意为差异化买单，前提是真的有差异化。</p></li><li><p>体验了各家的电视系统，小米无疑整合运营的最好的，同样他能获取到的利润也是最多的。</p></li><li><p>线下销售的流量还没有被压缩到极限值，而线上第一的小米还应该会有很大的增长，个人推测2019年小米电视销量能达到1100-1200万之间。</p></li><li><p>纯粹的低价是玩不下去的，前车之鉴太多了，暴风，风行，微鲸，低价入局变得哀鸿遍野，小米不同在于，它在不断尝试性价比的高端产品，虽然得屌丝者得天下，但是小米同样希望能拥有屌丝之王。</p><p><img src="//chiqtv.cn/2019/04/23/三场有趣的发布会/111.jpg" alt="index-14"></p><p><img src="//chiqtv.cn/2019/04/23/三场有趣的发布会/333.jpg" alt="index-11-1"></p></li></ol><h2 id="魅族16s"><a href="#魅族16s" class="headerlink" title="魅族16s"></a>魅族16s</h2><ol><li><p>小而美的魅族16s终于发布了，绝对是最好的非异性屏幕手机，手感，反馈，各方面绝对是Android的第一梯队，走上斜路的魅族终于在黄章的再次复出之后走上征途。</p></li><li><p>如果几年前黄章没有退隐，没有拿阿里的投资，没有一通瞎折腾，坚持小而美的哲学，也许今天手机行业格局又不一样，魅族绝对有一战的能力。</p></li><li><p>16s算是补齐了魅族16的各种短板，至少看起来是真香，剩下只是残酷的市场竞争，发布会的同时小米9已经全系列现货了。</p></li><li><p>黄章没什么文化，但是有工匠精神。</p></li><li><p>从三场发布会，小米9，魅族16s，华为p30来看，华为的营销，供应链，市场能力和另外两家完全就不是一个数量级上的差距，所以华为最强的永远都不是研发。</p></li><li><p>单从手机硬件，Android系统优化，几家大厂已经做得已经非常接近苹果，差距还是第三方应用的，整个生态，这个才是苹果最大的护城河，对用户粘黏性最强的地方。第三方应用的不约束，各种擦边球app，广告满天飞，带来极糟糕的体验，用户只会认为还是苹果就是好。</p><p><img src="//chiqtv.cn/2019/04/23/三场有趣的发布会/222.jpg" alt></p></li></ol><h2 id="联想Z6-pro"><a href="#联想Z6-pro" class="headerlink" title="联想Z6 pro"></a>联想Z6 pro</h2><ol><li><p>重新掌权的常程打算在哪里摔倒哪里爬起来，各种拼命刷手机热点，个人觉得已经没什么机会了，同样的前几年联想没有瞎折腾，放弃zuk，一堆昏招，也不至于今天的被动，关键是联想没有黄章那样的工匠。</p></li><li><p>看似超越小米的性价比，一定是无法盈利的，因为量不够，带来的高成本，ov，华为，小米，魅族，没有哪家会给你一丝喘机。</p></li><li><p>联想更大的危机不在手机，而在于笔记本电脑这种核心业务，华为太猛了。</p></li><li><p>手机这个大坑坑，到底能坑死多少英雄豪杰。</p><p><img src="//chiqtv.cn/2019/04/23/三场有趣的发布会/444.png" alt></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019小米电视新品&quot;&gt;&lt;a href=&quot;#2019小米电视新品&quot; class=&quot;headerlink&quot; title=&quot;2019小米电视新品&quot;&gt;&lt;/a&gt;2019小米电视新品&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不变的性价比 3999的65寸首发价格就可以看出来，双11
      
    
    </summary>
    
      <category term="科技资讯" scheme="http://chiqtv.cn/categories/%E7%A7%91%E6%8A%80%E8%B5%84%E8%AE%AF/"/>
    
    
      <category term="魅族" scheme="http://chiqtv.cn/tags/%E9%AD%85%E6%97%8F/"/>
    
      <category term="小米" scheme="http://chiqtv.cn/tags/%E5%B0%8F%E7%B1%B3/"/>
    
      <category term="联想" scheme="http://chiqtv.cn/tags/%E8%81%94%E6%83%B3/"/>
    
      <category term="手机" scheme="http://chiqtv.cn/tags/%E6%89%8B%E6%9C%BA/"/>
    
      <category term="电视" scheme="http://chiqtv.cn/tags/%E7%94%B5%E8%A7%86/"/>
    
  </entry>
  
  <entry>
    <title>redis配置及优化总结</title>
    <link href="http://chiqtv.cn/2019/04/21/redis5%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://chiqtv.cn/2019/04/21/redis5配置及优化总结/</id>
    <published>2019-04-21T00:59:58.000Z</published>
    <updated>2019-04-23T07:11:14.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis5-0配置说明"><a href="#redis5-0配置说明" class="headerlink" title="redis5.0配置说明"></a>redis5.0配置说明</h2><ol><li><p>配置文件中单元大小的解释，不区分大小写</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># Note on units: when memory size is needed, it is possible to specify</span><br><span class="line"># it in the usual form of 1k 5GB 4M and so forth:</span><br><span class="line">#</span><br><span class="line"># 1k =&gt; 1000 bytes</span><br><span class="line"># 1kb =&gt; 1024 bytes</span><br><span class="line"># 1m =&gt; 1000000 bytes</span><br><span class="line"># 1mb =&gt; 1024*1024 bytes</span><br><span class="line"># 1g =&gt; 1000000000 bytes</span><br><span class="line"># 1gb =&gt; 1024*1024*1024 bytes</span><br><span class="line">#</span><br><span class="line"># units are case insensitive so 1GB 1Gb 1gB are all the same.</span><br></pre></td></tr></table></figure></li><li><p>配置模板，针对个性化配置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 假如说你有一个可用于所有的 redis server 的标准配置模板，</span><br><span class="line"># 但针对某些 server 又需要一些个性化的设置，</span><br><span class="line"># 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。</span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> /path/to/local.conf</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> /path/to/other.conf</span></span><br></pre></td></tr></table></figure></li><li><p>加载模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">模块有两种加载方式，</span><br><span class="line">一是在配置文件redis.conf中使用loadmodule /path/to/mymodule.so在Redis启动时加载。</span><br><span class="line">另一种方式在运行时使用命令MODULE LOAD /path/to/mymodule.so加载。加载的模块可以使用命令MODULE LIST查看，使用MODULE UNLOAD mymodule卸载。</span><br><span class="line"></span><br><span class="line">在载入的模块的时候可以传入参数，如：loadmodule mymodule.so foo bar 123456，参数会被传入模块的OnLoad方法中。</span><br><span class="line"># loadmodule /path/to/my_module.so</span><br><span class="line"># loadmodule /path/to/other_module.so</span><br></pre></td></tr></table></figure></li><li><p>安全相关bind/protected-mode   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">默认设置yes， 禁止公网访问redis cache，加强redis安全</span><br><span class="line">它启用的条件，有两个：</span><br><span class="line">1） 没有bind IP</span><br><span class="line">2） 没有设置访问密码</span><br><span class="line">配置redis的sentinel集群时，哨兵之间不能通信，不能进行主结节客观下线的判断，以及failover，解决呢办法sentinel.conf中加入了protected-mode no</span><br><span class="line">详情说明可以见：acceptCommonHandler源码说明</span><br><span class="line"></span><br><span class="line">关于bind设置说明</span><br><span class="line">bind配置了什么ip，别人就得访问bind里面配置的ip才访问到redis服务。</span><br><span class="line">bind配置的ip必须是本机的ip，一台机器可以对应多个ip地址，配置非本机的ip地址会报错，如果配置为</span><br><span class="line">bind 127.0.0.1 表明只能本机访问，</span><br><span class="line">bind 0.0.0.0等价于 不配置 bind 即注释掉bind</span><br><span class="line"></span><br><span class="line">想限制只有指定的主机可以连接到redis中，我们只能通过防火墙来控制，而不能通过redis中的bind参数来限制</span><br><span class="line">很容易让人误解的一个配置</span><br></pre></td></tr></table></figure></li><li><p>访问端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">port 6379 默认值 选择这个端口号完全就是作者为了diss一个妹子，程序员真的是一个很屌丝的职业。。。</span><br><span class="line">详情可见：http://oldblog.antirez.com/post/redis-as-LRU-cache.html</span><br></pre></td></tr></table></figure></li><li><p>TCP 监听的最大容纳数量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tcp-backlog 511</span><br><span class="line">//在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。</span><br><span class="line">//值的大小是受somaxconn影响，调大需要修改内核的somaxconn值，实际应该是tcp过程中accept queue队列的最大值</span><br></pre></td></tr></table></figure></li><li><p>unix socket方式来接收请求</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># unixsocket /tmp/redis.sock</span><br><span class="line"># unixsocketperm 700</span><br><span class="line">//通过unixsocket配置项来指定unix socket文件的路径，并通过unixsocketperm来指定文件的权限</span><br></pre></td></tr></table></figure></li><li><p>redis-client连接断开时间</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timeout 0</span><br><span class="line">redis-client一直没有请求发向server端，那么server端有权主动关闭这个连接，可以通过timeout来设置“空闲超时时限”，0表示永不关闭，推荐配置为300</span><br></pre></td></tr></table></figure></li><li><p>tcp-keepalive 300  //tcp保持连接的时长</p></li><li><p>守护进程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize no 默认为no  <span class="comment">//进程pid号写入至redis.conf选项pidfile设置的文件中</span></span><br></pre></td></tr></table></figure></li><li><p>supervised no</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过其他的守护进程upstart和systemd管理Redis守护进程，这个参数是和具体的操作系统相关的。</span><br></pre></td></tr></table></figure></li><li><p>pidfile /var/run/redis_6379.pid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置pid文件路径。当redis以守护模式启动时，如果没有配置pidfile，pidfile默认值是/var/run/redis.pid</span><br></pre></td></tr></table></figure></li><li><p>日志等级/路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">debug（记录大量日志信息，适用于开发、测试阶段）；  verbose（较多日志信息）；  notice（适量日志信息，使用于生产环境）；warning（仅有部分重要、关键信息才会被记录）。</span><br><span class="line">日志文件的位置，当指定为空字符串时，为标准输出，如果redis已守护进程模式运行，那么日志将会输出到  /dev/null</span><br><span class="line">#syslog-enabled设置为yes会把日志输出到系统日志，默认是no</span><br><span class="line">#syslog-enabled no</span><br><span class="line">#指定syslog的标示符，如果syslog-enabled是no，则这个选项无效。</span><br><span class="line"># syslog-ident redis</span><br><span class="line">syslog-facility local0 若启用日志记录，则需要设置日志facility，可取值范围为local0~local7，表示不同的日志级别</span><br></pre></td></tr></table></figure></li><li><p>databases 16 //默认数据库的数量</p></li><li><p>always-show-logo yes //设置是否在控制台显示redis logo图标</p></li><li><p>快照备份相关设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">//指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</span><br><span class="line">stop-writes-on-bgsave-error yes //后台存储存储发生错误时禁止写入，默认为yes</span><br><span class="line">rdbcompression yes //启动rdb文件压缩，耗费CPU资源，默认为yes，建议开启，压缩率高</span><br><span class="line">rdbchecksum yes  //对rdb数据进行校验，耗费CPU资源，默认为yes</span><br><span class="line">dbfilename dump.rdb //rdb文件名称</span><br><span class="line">dir ./  //路径</span><br></pre></td></tr></table></figure></li></ol><ol start="17"><li><p>主从复制相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt; 主节点ip和端口</span><br><span class="line"># masterauth &lt;master-password&gt;  访问密码</span><br><span class="line">replica-serve-stale-data yes</span><br><span class="line">replica-serve-stale-data yes，即使主从断了，从依然响应客户端的请求。</span><br><span class="line">replica-serve-stale-data no，主从断开了，则从会提示客户端&quot;SYNC with master in progress&quot;，但有些指令还可以使用 INFO, replicaOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH, PUBSUB, COMMAND, POST, HOST: and LATENCY</span><br><span class="line">replica-read-only yes //配置从节点是否只读</span><br><span class="line">repl-diskless-sync no //以往主从复制是生成rdb文件,然后传输给从节点,配置成yes后可以不进行写磁盘直接进行复制,适用于磁盘慢网络带宽大的场景</span><br><span class="line">repl-diskless-sync-delay 5//让主节点等待更多从节点来同时复制,设置过小,复制时来的从节点必须等待下一次rdb transfer 单位秒,如果小于0则启动失败</span><br><span class="line"># repl-ping-replica-period 10 //从发给主的心跳周期,如果小于0则启动失败</span><br><span class="line"># repl-timeout 60  多少秒没收到心跳的响应认为超时,最好设置的比 repl-ping-slave-period/repl-ping-replica-period大如果小于0则启动失败</span><br><span class="line">repl-disable-tcp-nodelay no  //如果设置yes,会导致主从同步有40ms滞后(linux默认),如果no,则主从同步更及时</span><br><span class="line"># repl-backlog-size 1mb 复制积压大小,解决复制过程中从节点重连后不需要full sync,这个值越大,那么从节点断开到重连的时间就可以更长</span><br><span class="line"># repl-backlog-ttl 3600 //复制积压的生命期,超过多长时间从节点还没重连,则释放内存</span><br><span class="line">replica-priority 100 //给众多的从Redis设置优先级，在主Redis持续工作不正常的情况，优先级高的从Redis将会升级为主Redis。而编号越小，优先级越高。 比如一个主Redis有三个从Redis，优先级编号分别为10、100、25，那么编号为10的从Redis将会被首先选中升级为主Redis。 当优先级被设置为0时，这个从Redis将永远也不会被选中,默认的优先级为100</span><br><span class="line"># min-replicas-to-write 3</span><br><span class="line"># min-replicas-max-lag 10</span><br><span class="line">//假如有大于等于3个从Redis的连接延迟大于10秒，那么主Redis就不再接受外部的写请求。 上述两个配置中有一个被置为0，则这个特性将被关闭。默认情况下min-slaves-to-write为0，而min-slaves-max-lag为10</span><br><span class="line"></span><br><span class="line"># replica-announce-ip 5.5.5.5</span><br><span class="line"># replica-announce-port 1234</span><br><span class="line">Redis master 可以通过不同方式列出连接上来的 replicas 节点的地址和端口。 如 Redis Sentinel 等会使用 “INFO replication” 命令来获取 replica 实例信息。 master 的 “ROLE“ 命令也会提供此信息。</span><br><span class="line"></span><br><span class="line">这个信息一般来说是通过 replica 节点通过一下方式获取然后报告上来的：</span><br><span class="line"></span><br><span class="line">IP：通过自动识别连接到 Socket 的信息自动获取</span><br><span class="line">Port：一般来说这个值就是 replicas 节点用来接受客户端的连接的监听端口</span><br><span class="line">但是，若启用了端口转发或者 NAT，可能需要其他地址和端口才能连接到 replicas 节点。 这种情况下，需要设置这两个选项，这样 replicas 就会用这两个选项设置的值覆盖默认行为获取的值，然后报告给 master 节点。 根据实际情况，你可以只设置其中某个选项，而不用两个选项都设置。</span><br></pre></td></tr></table></figure></li></ol><ol start="18"><li><p>安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># requirepass foobared</span><br><span class="line">设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭</span><br><span class="line">ps：由于 Redis 非常快，外部用户若进行暴力破解，每秒能尝试超过 150k 个密码。因此你需要使用强度非常高的密码才能保证密码不容易被暴力破解掉。</span><br><span class="line">rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><br><span class="line">在共享环境下，可以通过 rename-command 命令将一些危险的命令进行重命名。 如上所示将 CONFIG 命令重命名为难以猜测的命令。</span><br><span class="line">可以通过将命令重命名为空字符串从而将其完全 ”kill“ 掉，如</span><br><span class="line">rename-command CONFIG &quot;&quot;</span><br><span class="line">rename-command 命令会被记录到日志和 AOF 文件中或者传输到 replicas 节点，而这可能会是一个安全问题。</span><br></pre></td></tr></table></figure></li></ol><ol start="19"><li><p>客户端数量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># maxclients 10000</span><br><span class="line"> 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息，上限值和系统的句柄连接数相关。</span><br></pre></td></tr></table></figure></li><li><p>内存设置相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> # maxmemory &lt;bytes&gt;</span><br><span class="line"> // 指定Redis最大内存限制，Redis新的vm机制，会把Key存放内存，Value会存放在swap区,意义不大。</span><br><span class="line"> redis内存管理策略，默认为noeviction</span><br><span class="line">         1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键中选择空转时间最长的键值对清除掉；</span><br><span class="line"></span><br><span class="line">        2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</span><br><span class="line"></span><br><span class="line">        3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；</span><br><span class="line"></span><br><span class="line">        4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；</span><br><span class="line"></span><br><span class="line">        5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；</span><br><span class="line"></span><br><span class="line">        6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；</span><br><span class="line"></span><br><span class="line">        7.allkeys-random:所有的键中，随机选择键进行删除；</span><br><span class="line"></span><br><span class="line">        8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;</span><br><span class="line">        </span><br><span class="line"># maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">maxmemory-samples   5个key作为样本池进行抽样清理，默认值5为最优</span><br><span class="line"># replica-ignore-maxmemory yes replica 节点会忽略 maxmemory 设置</span><br></pre></td></tr></table></figure></li></ol><ol start="21"><li><p>惰性删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">replica-lazy-flush no</span><br><span class="line">默认设置为no，个人感觉应该全部设置yes，代码会根据实际情况进行判断，是否进行惰性删除。</span><br></pre></td></tr></table></figure></li><li><p>aof持久化配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">appendonly no</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># appendfsync always</span><br><span class="line">appendfsync everysec</span><br><span class="line"># appendfsync no</span><br><span class="line"></span><br><span class="line">1、appendfsync no </span><br><span class="line">当设置appendfsync为no的时候，Redis不会主动调用fsync去将AOF日志内容同步到磁盘，所以这一切就完全依赖于操作系统的调试了。对大多数Linux操作系统，是每30秒进行一次fsync，将缓冲区中的数据写到磁盘上。 </span><br><span class="line">2、appendfsync everysec </span><br><span class="line">当设置appendfsync为everysec的时候，Redis会默认每隔一秒进行一次fsync调用，将缓冲区中的数据写到磁盘。但是当这一 次的fsync调用时长超过1秒时。Redis会采取延迟fsync的策略，再等一秒钟。也就是在两秒后再进行fsync，这一次的fsync就不管会执行多长时间都会进行。这时候由于在fsync时文件描述符会被阻塞，所以当前的写操作就会阻塞。 </span><br><span class="line">所以，结论就是：在绝大多数情况下，Redis会每隔一秒进行一次fsync。在最坏的情况下，两秒钟会进行一次fsync操作，掉数据也就1-2秒</span><br><span class="line">这一操作在大多数数据库系统中被称为group commit，就是组合多次写操作的数据，一次性将日志写到磁盘。 </span><br><span class="line">3、appednfsync always </span><br><span class="line">当设置appendfsync为always时，每一次写操作都会调用一次fsync，这时数据是最安全的，当然，由于每次都会执行fsync，所以其性能也会受到影响。</span><br><span class="line">///////////////////////////////</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line">bgrewriteaof机制，在一个子进程中进行aof的重写，从而不阻塞主进程对其余命令的处理，同时解决了aof文件过大问题。</span><br><span class="line">现在问题出现了，同时在执行bgrewriteaof操作和主进程写aof文件的操作，两者都会操作磁盘，而bgrewriteaof往往会涉及大量磁盘操作，这样就会造成主进程在写aof文件的时候出现阻塞的情形，现在no-appendfsync-on-rewrite参数出场了。如果该参数设置为no，是最安全的方式，不会丢失数据，但是要忍受阻塞的问题。如果设置为yes呢？这就相当于将appendfsync设置为no，这说明并没有执行磁盘操作，只是写入了缓冲区，因此这样并不会造成阻塞（因为没有竞争磁盘），但是如果这个时候redis挂掉，就会丢失数据。丢失多少数据呢？在linux的操作系统的默认设置下，最多会丢失30s的数据。</span><br><span class="line"></span><br><span class="line">因此，如果应用系统无法忍受延迟，而可以容忍少量的数据丢失，则设置为yes。如果应用系统无法忍受数据丢失，则设置为no。</span><br><span class="line"></span><br><span class="line">/////////////// rewrite执行临界值</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">自动重写 append only file 选项。 当 AOF 文件增长到一定比例后，Redis 可以自动通过隐式调用 BGREWRITEAOF 命令来重写 AOF 文件。</span><br><span class="line">Redis 会记录上一次 rewrite 的 AOF 文件大小（若从未进行 rewrite，Redis 会使用启动时的 AOF 文件大小）作为基准大小。</span><br><span class="line">Redis 会比较当前大小和基准大小，若当前大小大于一定比例则触发 rewrite。 为了防止增长比例到了但是总数据量还是非常小的情况就触发 rewrite，你还需要指定一个 AOF rewritten 的最小大小。</span><br><span class="line">通过将 auto-aof-rewrite-percentage 设置为 0 可以禁用此功能。</span><br><span class="line"></span><br><span class="line">/////////aof文件不完整</span><br><span class="line">aof-load-truncated yes</span><br><span class="line">当 Redis 启动时可能会发现 AOF 文件被截断了（不完整），这可能是由于系统崩溃了， 特别是 ext4 没有以 data=ordered 选项挂载的情况（在 Redis 崩溃而系统正常的情况下不会发生截断）。</span><br><span class="line">当这种情况发生时，Redis 可以选择终止进程，或者加载 AOF 文件上尽可能多的数据（目前的默认行为）。</span><br><span class="line">当 aof-load-truncated 设置为 yes， Redis 服务端在启动的时候发现加载的 AOF 文件是被截断的会发送一条日志来通知客户。 若 aof-load-truncated 设置为 no，服务端会以错误形式终止进程并拒绝启动。 这是需要用户在重启服务前使用 &quot;redis-check-aof&quot; 工具来修复 AOF 文件。</span><br><span class="line"></span><br><span class="line">aof-use-rdb-preamble yes //aof,rdb混合持久化</span><br></pre></td></tr></table></figure></li></ol><ol start="16"><li><p>lua脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lua-time-limit 5000</span><br><span class="line">此选项用于控制 Lua 脚本的最长执行时间，单位为毫秒。</span><br><span class="line">当 Lua 脚本的执行时间超出限制后，Redis 会在写入相关日志，并且向客户端返回出错。</span><br></pre></td></tr></table></figure></li></ol><ol start="17"><li><p>redis cluster配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># cluster-enabled yes</span><br><span class="line">如果配置yes则开启集群功能，此redis实例作为集群的一个节点，否则，它是一个普通的单一的redis实例。</span><br><span class="line"></span><br><span class="line"># cluster-config-file nodes-6379.conf</span><br><span class="line">集群配置文件，但是此配置文件不能人工编辑，它是集群节点自动维护的文件，主要用于记录集群中有哪些节点、他们的状态以及一些持久化参数等，方便在重启时恢复这些状态。通常是在收到请求之后这个文件就会被更新。</span><br><span class="line"></span><br><span class="line"># cluster-node-timeout 15000</span><br><span class="line">这是集群中的节点能够失联的最大时间，超过这个时间，该节点就会被认为故障。如果主节点超过这个时间还是不可达，则用它的从节点将启动故障迁移，升级成主节点。注意，任何一个节点在这个时间之内如果还是没有连上大部分的主节点，则此节点将停止接收任何请求。一般设置为15秒即可。</span><br><span class="line"></span><br><span class="line"># cluster-replica-validity-factor 10</span><br><span class="line">如果数据太旧，集群中的不可用master的slave节点会避免成为备用master。如果slave和master失联时间超过:(node-timeout * slave-validity-factor) + repl-ping-slave-period则不会被提升为master。</span><br><span class="line">如node-timeout为30秒，slave-validity-factor为10, 默认default repl-ping-slave-period为10秒,失联时间超过310秒slave就不会成为master。</span><br><span class="line">较大的slave-validity-factor值可能允许包含过旧数据的slave成为master，同时较小的值可能会阻止集群选举出新master。</span><br><span class="line">为了达到最大限度的高可用性，可以设置为0，即slave不管和master失联多久都可以提升为master</span><br><span class="line"></span><br><span class="line">#cluster-migration-barrier</span><br><span class="line">只有在之前master有其它指定数量的工作状态下的slave节点时，slave节点才能提升为master。默认为1（即该集群至少有3个节点，1 master＋2 slaves，master宕机，仍有另外1个slave的情况下其中1个slave可以提升）</span><br><span class="line">测试环境可设置为0，生成环境中至少设置为1</span><br><span class="line"></span><br><span class="line">#cluster-require-full-coverage yes</span><br><span class="line">默认情况下如果redis集群如果检测到至少有1个hash slot不可用，集群将停止查询数据。</span><br><span class="line">如果所有slot恢复则集群自动恢复。</span><br><span class="line">如果需要集群部分可用情况下仍可提供查询服务，设置为no。</span><br><span class="line"></span><br><span class="line">#cluster-migration-barrier 1</span><br><span class="line">只有在之前master有其它指定数量的工作状态下的slave节点时，slave节点才能提升为master。默认为1（即该集群至少有3个节点，1 master＋2 slaves，master宕机，仍有另外1个slave的情况下其中1个slave可以提升）</span><br><span class="line">测试环境可设置为0，生成环境中至少设置为1</span><br><span class="line"></span><br><span class="line">#cluster-require-full-coverage yes</span><br><span class="line">默认情况下如果redis集群如果检测到至少有1个hash slot不可用，集群将停止查询数据。</span><br><span class="line">如果所有slot恢复则集群自动恢复。</span><br><span class="line">如果需要集群部分可用情况下仍可提供查询服务，设置为no。</span><br><span class="line"></span><br><span class="line">#cluster-replica-no-failover no</span><br><span class="line">选项设置为yes时，会阻止replicas尝试对其master在主故障期间进行故障转移</span><br><span class="line">然而，master仍然可以执行手动故障转移,如果强制这样做的话。</span><br></pre></td></tr></table></figure></li></ol><ol start="18"><li><p>DOCKER下的集群配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># * cluster-announce-ip //实际为各节点网卡分配ip </span><br><span class="line"># * cluster-announce-port  //节点映射端口</span><br><span class="line"># * cluster-announce-bus-port //集群总线端口</span><br><span class="line"></span><br><span class="line">在Docker环境中，如果使用的不是host网络模式，在容器内部的IP和PORT都是隔离的，那么客户端和其他节点无法通过节点公布的IP和PORT建立连接，增加这三个配置，Redis节点会将配置中的这些IP和PORT告知客户端或其他节点。而这些IP和PORT是通过Docker转发到容器内的临时IP和PORT的。</span><br></pre></td></tr></table></figure><p><img src="//chiqtv.cn/2019/04/21/redis5配置及优化总结/1111.png" alt="1111"></p></li><li><p>慢查询</p><p>slowlog-log-slower-than 10000</p><p>慢查询日志，记录超过多少微秒的查询命令。查询的执行时间不包括客户端的IO执行和网络通信时间，只是查询命令执行时间。</p><p>1000000等于1秒，设置为0则记录所有命令</p></li></ol><pre><code>slowlog-max-len 128记录大小，可通过SLOWLOG RESET命令重置</code></pre><ol start="20"><li><p>监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">latency-monitor-threshold 0</span><br><span class="line">redis延时监控系统在运行时会采样一些操作，以便收集可能导致延时的数据根源。</span><br><span class="line">通过 LATENCY命令 可以打印一些图样和获取一些报告，方便监控</span><br><span class="line">这个系统仅仅记录那个执行时间大于或等于预定时间（毫秒）的操作,</span><br><span class="line">这个预定时间是通过latency-monitor-threshold配置来指定的，</span><br><span class="line">当设置为0时，这个监控系统处于停止状态</span><br></pre></td></tr></table></figure></li></ol><ol start="21"><li><p>过期事件通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notify-keyspace-events Ex  // 打开此配置，其中Ex表示键事件通知里面的key过期事件，每当有过期键被删除时，会发送通知</span><br></pre></td></tr></table></figure></li></ol><ol start="22"><li><p>数据结构相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash类型的数据结构在编码上可以使用ziplist和hashtable。ziplist的特点就是文件存储(以及内存存储)所需的空间较小,在内容较小时,性能和hashtable几乎一样.因此redis对hash类型默认采取ziplist。如果hash中条目的条目个数或者value长度达到阀值,将会被重构为hashtable。</span><br><span class="line">这个参数指的是ziplist中允许存储的最大条目个数，，默认为512，建议为128</span><br><span class="line"></span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line">ziplist中允许条目value值最大字节数，默认为64，建议为1024</span><br><span class="line"></span><br><span class="line">当取正值的时候，表示按照数据项个数来限定每个quicklist节点上的ziplist长度。比如，当这个参数配置</span><br><span class="line">成5的时候，表示每个quicklist节点的ziplist最多包含5个数据项。</span><br><span class="line">当取负值的时候，表示按照占用字节数来限定每个quicklist节点上的ziplist长度。这时，它只能取-1到-5</span><br><span class="line">这五个值，每个值含义如下：</span><br><span class="line">-5: 每个quicklist节点上的ziplist大小不能超过64 Kb。（注：1kb =&gt; 1024 bytes）</span><br><span class="line">-4: 每个quicklist节点上的ziplist大小不能超过32 Kb。</span><br><span class="line">-3: 每个quicklist节点上的ziplist大小不能超过16 Kb。</span><br><span class="line">-2: 每个quicklist节点上的ziplist大小不能超过8 Kb。（-2是Redis给出的默认值）</span><br><span class="line">-1: 每个quicklist节点上的ziplist大小不能超过4 Kb。</span><br><span class="line">list-max-ziplist-size -2</span><br><span class="line"></span><br><span class="line">这个参数表示一个quicklist两端不被压缩的节点个数。</span><br><span class="line">注：这里的节点个数是指quicklist双向链表的节点个数，而不是指ziplist里面的数据项个数。</span><br><span class="line">实际上，一个quicklist节点上的ziplist，如果被压缩，就是整体被压缩的。</span><br><span class="line">参数list-compress-depth的取值含义如下：</span><br><span class="line">0: 是个特殊值，表示都不压缩。这是Redis的默认值。</span><br><span class="line">1: 表示quicklist两端各有1个节点不压缩，中间的节点压缩。</span><br><span class="line">2: 表示quicklist两端各有2个节点不压缩，中间的节点压缩。</span><br><span class="line">3: 表示quicklist两端各有3个节点不压缩，中间的节点压缩。</span><br><span class="line">由于0是个特殊值，很容易看出quicklist的头节点和尾节点总是不被压缩的，以便于在表的两端进行快速存取。</span><br><span class="line">list-compress-depth 0</span><br><span class="line"></span><br><span class="line">set-max-intset-entries 512</span><br><span class="line">intset中允许保存的最大条目个数,如果达到阀值,intset将会被重构为hashtable</span><br><span class="line"></span><br><span class="line">与hash和list相似，有序集合也可以用一种特别的编码方式来节省大量空间。</span><br><span class="line">这种编码只适合长度和元素都小于下面限制的有序集合</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line">hll-sparse-max-bytes 3000 </span><br><span class="line">HyperLogLogs算法相关的，3000为最优值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Streams宏节点最大大小/项目。 流数据结构是基数编码内部多个项目的大节点树。</span><br><span class="line">使用此配置可以配置单个节点的字节数，以及切换到新节点之前可能包含的最大项目数</span><br><span class="line">追加新的流条目。 如果以下任何设置设置为0，忽略限制，因此例如可以设置一个</span><br><span class="line">大入口限制将max-bytes设置为0，将max-entries设置为所需的值</span><br><span class="line">stream-node-max-bytes 4096</span><br><span class="line">stream-node-max-entries 100</span><br><span class="line"> </span><br><span class="line">redis所用的哈希表实现(见dict.c)采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新操作就越频繁；</span><br><span class="line">反之，如果服务器非常不活跃那么也就是用点内存保存哈希表而已。</span><br><span class="line">默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。</span><br><span class="line">建议：如果你对延迟比较在意的话就用 &quot;activerehashing no&quot;，</span><br><span class="line">如果你不太在意延迟而希望尽快释放内存的话就设置 &quot;activerehashing yes&quot;。</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line">客户端buffer控制。在客户端与server进行的交互中,每个连接都会与一个buffer关联,此buffer用来队列化等待被client接受的响应信息。如果client不能及时的消费响应信息,那么buffer将会被不断积压而给server带来内存压力.如果buffer中积压的数据达到阀值,将会导致连接被关闭,buffer被移除。</span><br><span class="line"></span><br><span class="line">buffer控制类型包括:normal -&gt; 普通连接；slave -&gt;与slave之间的连接；pubsub -&gt;pub/sub类型连接，此类型的连接，往往会产生此种问题;因为pub端会密集的发布消息,但是sub端可能消费不足.</span><br><span class="line">指令格式:client-output-buffer-limit &lt;class&gt; &lt;hard&gt; &lt;soft&gt; &lt;seconds&gt;&quot;,其中hard表示buffer最大值,一旦达到阀值将立即关闭连接;</span><br><span class="line">soft表示&quot;容忍值&quot;,它和seconds配合,如果buffer值超过soft且持续时间达到了seconds,也将立即关闭连接,如果超过了soft但是在seconds之后，buffer数据小于了soft,连接将会被保留.</span><br><span class="line">其中hard和soft都设置为0,则表示禁用buffer控制.通常hard值大于soft.</span><br><span class="line"></span><br><span class="line">client-query-buffer-limit 1gb</span><br><span class="line">客户端查询缓存大小限制</span><br><span class="line"></span><br><span class="line">proto-max-bulk-len 512mb</span><br><span class="line">批量请求的大小限制</span><br><span class="line"></span><br><span class="line">44 hz 10</span><br><span class="line"></span><br><span class="line">Redis server执行后台任务的频率,默认为10,此值越大表示redis对&quot;间歇性task&quot;的执行次数越频繁(次数/秒)。&quot;间歇性task&quot;包括&quot;过期集合&quot;检测、关闭&quot;空闲超时&quot;的连接等,此值必须大于0且小于500。此值过小就意味着更多的cpu周期消耗,后台task被轮询的次数更频繁。此值过大意味着&quot;内存敏感&quot;性较差。建议采用默认值</span><br><span class="line"></span><br><span class="line">dynamic-hz yes</span><br><span class="line">设置yes,则根据客户端连接数可以自动调节hz</span><br><span class="line"></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br><span class="line">设置yes,则每32mb 执行fsync一次(增量式,避免一次性大写入导致的延时)</span><br><span class="line">设置no,则一次性fsync</span><br><span class="line"></span><br><span class="line">rdb-save-incremental-fsync   yes</span><br><span class="line">设置yes,则每32mb 执行fsync一次(增量式,避免一次性大写入导致的延时)</span><br><span class="line">设置no,则一次性fsync</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># lfu-log-factor 10</span><br><span class="line"># lfu-decay-time 1</span><br><span class="line">lfu算法相关，默认配置为最优配置，详情可以见之前的文章说明</span><br></pre></td></tr></table></figure></li><li><p>内存碎片整理相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># activedefrag yes</span><br><span class="line">碎片整理总开关</span><br><span class="line"></span><br><span class="line"># active-defrag-ignore-bytes 100mb</span><br><span class="line"># 内存碎片达到多少的时候开启整理</span><br><span class="line"></span><br><span class="line"># active-defrag-threshold-lower 10</span><br><span class="line"># 碎片率达到百分之多少开启整理</span><br><span class="line"></span><br><span class="line"># active-defrag-threshold-upper 100</span><br><span class="line"># 碎片率小余多少百分比开启整理</span><br><span class="line"></span><br><span class="line"># active-defrag-cycle-min 5</span><br><span class="line"># 在CPU百分比中进行碎片整理的最小工作量</span><br><span class="line"></span><br><span class="line"># active-defrag-cycle-max 75</span><br><span class="line"># 整理磁盘碎片占cpu百分比的最大值</span><br><span class="line"></span><br><span class="line"># active-defrag-max-scan-fields 1000</span><br><span class="line">#从主字典扫描能够处理的set/hash/zset/list字段的最大数量</span><br><span class="line"></span><br><span class="line">4.0开始的实验性功能，经过1轮大版本的测试迭代，默认关闭。</span><br></pre></td></tr></table></figure></li></ol><h2 id="优化及安全"><a href="#优化及安全" class="headerlink" title="优化及安全"></a>优化及安全</h2><ol><li>尽量使用pipeline提升吞吐量，提升非常明显</li><li>设置内存上限值maxmemory，根据业务配置优先释放方式</li><li>控制键和值得长度，长键可以考虑hash后存储，值过大，考虑压缩再存储，snappy</li><li>集合短结构，细节见配置，短结构的数量限制在500～2000个以内，单个元素的长度限制在128个字节以内，其性能一般都会处于合理的范围之内。《Redis in Action》中推荐的配置为：数量限制为1024个，长度限制为64字节，这样可以同时兼顾低内存占用与高性能。</li><li>业务相关与持久化策略</li><li>禁止大面积的数据同一时间失效</li><li>rename禁止永不分命令flushall flushdb等</li><li>monitor对性能消耗过大，禁止长期开启</li><li>bind/protected-mode 配置一定</li><li>密码，ssl传输数据</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;redis5-0配置说明&quot;&gt;&lt;a href=&quot;#redis5-0配置说明&quot; class=&quot;headerlink&quot; title=&quot;redis5.0配置说明&quot;&gt;&lt;/a&gt;redis5.0配置说明&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;配置文件中单元大小的解释，不区分大小写&lt;/
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://chiqtv.cn/tags/redis/"/>
    
      <category term="缓存" scheme="http://chiqtv.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>涠洲岛旅游</title>
    <link href="http://chiqtv.cn/2019/04/20/%E6%B6%A0%E6%B4%B2%E5%B2%9B/"/>
    <id>http://chiqtv.cn/2019/04/20/涠洲岛/</id>
    <published>2019-04-20T00:59:58.000Z</published>
    <updated>2019-04-22T05:27:22.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吃"><a href="#吃" class="headerlink" title="吃"></a>吃</h2><ol><li><p>海选市场买，买了找个店加工，基本上重庆人开的加工店都还不错，价格不贵，涠洲岛的特长是皮皮虾和生蚝</p></li><li><p>南湾晚上退朝可以捉螃蟹，运气好下来可以炖一锅螃蟹粥问题不大</p></li><li>岛上香蕉便宜，味道好</li></ol><h2 id="住"><a href="#住" class="headerlink" title="住"></a>住</h2><ol><li><p>一定要选一个好点的名宿，个人推荐仙本那民宿，600-1200，价格贵，位置太好了，周围很安静，沙滩离开住的地方就5米，没有任何商业的设施，适合老年人或者带小孩的家庭，年轻人还是应该选晚上周边酒吧多的地方。</p></li><li><p>21海里酒店也不错，价格也不便宜，总得来说涠洲岛上酒店的性价比比较低。</p></li></ol><h2 id="行"><a href="#行" class="headerlink" title="行"></a>行</h2><ol><li><p>上岛的船一定要选vip头等舱，体验和看到的风景会完全不一样</p></li><li><p>岛上可以租电瓶车，电动车，或者打旅游观光车都很方便</p></li></ol><h2 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h2><ol><li>岛上的珍珠戒子就不要买了。。。。</li></ol><h2 id="景点"><a href="#景点" class="headerlink" title="景点"></a>景点</h2><ol><li>鳄鱼山，教堂，几个海滩都可以去看看</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>适合带娃或者去岛上发呆，一定要淡季去，旺季去完全没得任何用户体验了。</p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/1.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/2.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/3.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/5.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/6.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/7.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/4.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/8.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/9.jpg" alt></p><p><img src="//chiqtv.cn/2019/04/20/涠洲岛/10.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;吃&quot;&gt;&lt;a href=&quot;#吃&quot; class=&quot;headerlink&quot; title=&quot;吃&quot;&gt;&lt;/a&gt;吃&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;海选市场买，买了找个店加工，基本上重庆人开的加工店都还不错，价格不贵，涠洲岛的特长是皮皮虾和生蚝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p
      
    
    </summary>
    
      <category term="旅游" scheme="http://chiqtv.cn/categories/%E6%97%85%E6%B8%B8/"/>
    
    
      <category term="涠洲岛" scheme="http://chiqtv.cn/tags/%E6%B6%A0%E6%B4%B2%E5%B2%9B/"/>
    
      <category term="广西北海" scheme="http://chiqtv.cn/tags/%E5%B9%BF%E8%A5%BF%E5%8C%97%E6%B5%B7/"/>
    
  </entry>
  
  <entry>
    <title>缺舟</title>
    <link href="http://chiqtv.cn/2019/04/01/begin/"/>
    <id>http://chiqtv.cn/2019/04/01/begin/</id>
    <published>2019-04-01T10:00:00.000Z</published>
    <updated>2019-04-24T05:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"><a href="#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。" class="headerlink" title="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"></a>思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot;&gt;&lt;a href=&quot;#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot; class=&quot;headerlink&quot; title=&quot;思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。&quot;&gt;&lt;/a&gt;思绪
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redis4源码阅读学习-2</title>
    <link href="http://chiqtv.cn/2019/02/09/Redis4%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0-2/"/>
    <id>http://chiqtv.cn/2019/02/09/Redis4源码阅读学习-2/</id>
    <published>2019-02-09T10:02:37.000Z</published>
    <updated>2019-04-09T11:30:20.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis客户端和服务器的相关代码"><a href="#redis客户端和服务器的相关代码" class="headerlink" title="redis客户端和服务器的相关代码"></a>redis客户端和服务器的相关代码</h1><h2 id="ae-c（Redis-的事件处理器实现（基于-Reactor-模式））"><a href="#ae-c（Redis-的事件处理器实现（基于-Reactor-模式））" class="headerlink" title="ae.c（Redis 的事件处理器实现（基于 Reactor 模式））"></a>ae.c（Redis 的事件处理器实现（基于 Reactor 模式））</h2><p><img src="//chiqtv.cn/2019/02/09/Redis4源码阅读学习-2/1.png" alt></p><p>handle_events()</p><p>在Redis中，对于文件事件，相应的处理函数为Ae.c/aeProcessEvents</p><p>register_handler/remove_handler 对应Redis中，相关的处理函数也在Ae.c文件中方法</p><p>select对应不同平台的io复用的函数库</p><p>handle对应fd资源，文件描述符</p><p>event handler  事件处理器的接口</p><p>Concrete Event Handler 事件处理器的实际实现，绑定handle，比如acceptTcpHandler  这些</p><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="aeFileEvent"><a href="#aeFileEvent" class="headerlink" title="aeFileEvent"></a>aeFileEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件事件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    aeFileProc *rfileProc;  <span class="comment">//读文件事件回调</span></span><br><span class="line">    aeFileProc *wfileProc;  <span class="comment">//写文件事件回调</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure><h5 id="aeTimeEvent"><a href="#aeTimeEvent" class="headerlink" title="aeTimeEvent"></a>aeTimeEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间事件结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;<span class="comment">//定时回调函数指针</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;<span class="comment">// 定时事件清理函数，当删除定时事件的时候会被调用</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span><span class="comment">//时间事件表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure><h5 id="aeFiredEvent"><a href="#aeFiredEvent" class="headerlink" title="aeFiredEvent"></a>aeFiredEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//表示事件发生在哪个文件描述符上面</span></span><br><span class="line">    <span class="keyword">int</span> mask;<span class="comment">//被触发事件的类型</span></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure><h5 id="aeEventLoop"><a href="#aeEventLoop" class="headerlink" title="aeEventLoop"></a>aeEventLoop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件循环结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">//记录最大的定时事件 id </span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; </span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">//用于系统时间的矫正</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">//文件表</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">//触发事件表</span></span><br><span class="line">    aeTimeEvent *timeEventHead;<span class="comment">//定时事件表</span></span><br><span class="line">    <span class="keyword">int</span> stop; <span class="comment">//事件循环停止标志</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">//统一接口，屏蔽不同平台io服用机制，</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">//进入poll之前需要处理的事情</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">//进入poll之后需要处理的事情</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    aeCreateEventLoop    <span class="comment">/* 创建总的事件管理结构 */</span></span><br><span class="line">    aeCreateTimeEvent    <span class="comment">/* 创建定时器事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> inet socket    <span class="comment">/* 创建网络事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> unix socket    <span class="comment">/* 内部通信事件的管理结构 */</span></span><br><span class="line">    aeSetBeforeSleepProc    <span class="comment">/* 设置beforeSleep处理函数 */</span></span><br><span class="line">    aeSetAfterSleepProc    <span class="comment">/* 设置afterSleep处理函数 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!stop)  <span class="comment">//aeMain</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//aeProcessEvents</span></span><br><span class="line">        beforeSleep                <span class="comment">/* 调用beforeSleep处理函数 */</span></span><br><span class="line">        aeApiPoll                <span class="comment">/* 进入poll函数 */</span></span><br><span class="line">        afterSleep                <span class="comment">/* 调用afterSleep处理函数 */</span></span><br><span class="line">        process file events    <span class="comment">/* 处理file events */</span></span><br><span class="line">        process time events    <span class="comment">/* 处理time events */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="aeCreateEventLoop-initServer调用初始化"><a href="#aeCreateEventLoop-initServer调用初始化" class="headerlink" title="aeCreateEventLoop  //initServer调用初始化"></a>aeCreateEventLoop  //initServer调用初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *aeCreateEventLoop(int setsize) &#123; </span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);</span><br><span class="line">    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(NULL);</span><br><span class="line">    eventLoop-&gt;timeEventHead = NULL;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = 0;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    eventLoop-&gt;maxfd = -1;</span><br><span class="line">    eventLoop-&gt;beforesleep = NULL;</span><br><span class="line">    eventLoop-&gt;aftersleep = NULL;</span><br><span class="line">    if (aeApiCreate(eventLoop) == -1) goto err;</span><br><span class="line">    /* Events with mask == AE_NONE are not set. So let&apos;s initialize the</span><br><span class="line">     * vector with it. */</span><br><span class="line">    for (i = 0; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    return eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h6><p>server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</p><p>setsize = server.maxclients+CONFIG_FDSET_INCR = 10000 + CONFIG_MIN_RESERVED_FDS+96</p><p>CONFIG_MIN_RESERVED_FDS = 32 是Sentinel保留的用于额外的的操作，如listening sockets, log files 等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max 查看系统级别的能够打开的文件句柄的数量</span><br><span class="line">ulimit -a 1024 查看用户进程级的能够打开文件句柄的数量</span><br></pre></td></tr></table></figure><h6 id="相关的案例事件……"><a href="#相关的案例事件……" class="headerlink" title="相关的案例事件……"></a>相关的案例事件……</h6><p>9554:M 24 Mar 10:40:25.869 # Error registering fd event for the new client: Numerical result out of range (fd=10128)</p><p>系统内存不足以fork子进程时，AOF重写就无法启动，而此之前已打开的pipe也永远不会关闭，并在下一次尝试AOF重写时又创建新的pipe，从而造成fd泄漏。</p><p>具体代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">// 创建pipe</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">//子进程启动出错处理</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Can't rewrite append only file in background: fork: %s"</span>,</span><br><span class="line">                strerror(errno)); <span class="comment">// 最初内存不足正是这里打出的错误log</span></span><br><span class="line">            aofClosePipes();<span class="comment">//fix bug issues/2857</span></span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><h5 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h5><p>在一般情况下，<code>aeProcessEvents</code> 都会先<strong>计算最近的时间事件发生所需要等待的时间</strong>，然后调用 <code>aeApiPoll</code> 方法在这段时间中等待事件的发生，在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发：</p><pre><code>numevents = aeApiPoll(eventLoop, tvp);/* After sleep callback. */if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)    eventLoop-&gt;aftersleep(eventLoop);for (j = 0; j &lt; numevents; j++) {    aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];    int mask = eventLoop-&gt;fired[j].mask;    int fd = eventLoop-&gt;fired[j].fd;    int fired = 0; /* Number of events fired for current fd. */    int invert = fe-&gt;mask &amp; AE_BARRIER;</code></pre><p>​           </p><h2 id="文件事件注册-aeCreateFileEvent"><a href="#文件事件注册-aeCreateFileEvent" class="headerlink" title="文件事件注册  aeCreateFileEvent"></a>文件事件注册  aeCreateFileEvent</h2><h2 id="监听实现"><a href="#监听实现" class="headerlink" title="监听实现"></a>监听实现</h2><p>1.<code>initServer()</code>中完成了对事件循环的初始化操作</p><p>listenToPort</p><p>2.完成了监听套接字的初始化，<code>initServer()</code>还需要为所有监听套接字注册读事件</p><p>acceptTcpHandler/acceptUnixHandler  //回调监听到新连接请求时</p><p>acceptTcpHandler()-&gt;acceptCommonHandler  </p><p>在与客户端成功建立连接之后，调用了<code>acceptCommonHandler()</code>函数，其作用为：<br> 1、 建立并保存服务器与客户端的连接信息，将信息保存到一个struct redisClient 中；<br> 2、为客户端的cfd（已连接的socket）注册读事件，相应的回调函数为<code>readQueryFromClient()</code>，其作用是从socket读取数据，执行相应操作，并回复给客户端(而acceptCommonHandler是为监听socket的读事件回调函数)</p><h2 id="事件循环aeMain"><a href="#事件循环aeMain" class="headerlink" title="事件循环aeMain"></a>事件循环aeMain</h2><p>1、根据时间事件链表计算需要等待的最短事件；<br>2、调用<code>redis aeApiPoll()</code> 进入监听轮询，如果没有事件发生就进入睡眠状态，其实就是进行I/O多路复用函数调用。<br>3、如果有事件发生，处理事件。</p><h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>aeApiPoll //多路复用函数阻塞监听</p><h5 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2.时间事件"></a>2.时间事件</h5><p>在 Redis 中会发生两种时间事件：</p><ul><li>一种是定时事件，每隔一段时间会执行一次；</li><li>另一种是非定时事件，只会在某个时间点执行一次；</li></ul><p>aeProcessEvents -&gt;processTimeEvents</p><p><img src="//chiqtv.cn/2019/02/09/Redis4源码阅读学习-2/2.png" alt></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1时间事件分为定时时间和周期事件，周期事件serverCron  100毫秒</p><p>2时间事件和文件事件合并到一起处理，分开；</p><p>3.时间事件晚于预设</p><p><img src="//chiqtv.cn/2019/02/09/Redis4源码阅读学习-2/aeEventLoop.png" alt></p><h4 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h4><p>readQueryFromClient   processCommand</p><p>clientsCronHandleTimeout //keep_alive，ping,异常处理</p><p>三类方法</p><p>1.addReply API  往数据结构里面写东西</p><p>2.Client API 客户端创建释放</p><p>3.工具方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listMatchObjects</span><br><span class="line">disconnectSlaves</span><br><span class="line">flushSlavesOutputBuffers</span><br><span class="line">acceptTcpHandler</span><br><span class="line">copyClientOutputBuffer</span><br></pre></td></tr></table></figure><h4 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h4><p>1.Globals</p><p>2.Utility functions</p><p>3.Hash table</p><p>4.Cron</p><p>trackInstantaneousMetric  bug</p><p>writeToClient    server.stat_net_output_bytes += totwritten;</p><pre><code>5.0//缓冲区大于32K，且远大于查询缓冲区数据峰值//询缓冲区大于32K，且客户端当前处于非活跃状态int clientsCronResizeQueryBuffer(client *c)if (querybuf_size &gt; PROTO_MBULK_BIG_ARG &amp;&amp;     ((querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2 ||      idletime &gt; 2)){    /* Only resize the query buffer if it is actually wasting     * at least a few kbytes. */    if (sdsavail(c-&gt;querybuf) &gt; 1024*4) {        c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);    }}4.0// 查询缓冲区大于32K，且远大于查询缓冲区数据峰值// 查询缓冲区大于1K，且客户端当前处于非活跃状态if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;    (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||    (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2)){        /* Only resize the query buffer if it is actually wasting space. */        if (sdsavail(c-&gt;querybuf) &gt; 1024) {            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);        } }//c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);初始化默认分配的大小就是32k如果客户端数量比较多，且刚好比较空闲，需要一次处理很多客户端的输入缓冲区，阻塞或者崩溃</code></pre><p>5.serverCron 相关的知识点</p><p>1）.信息更新，统计</p><p>2).  XXXXCron</p><p>3). 持久化</p><p>4). 集群</p><p>6.Server initialization</p><p>7.Redis OP Array API  持久化复制的时候命令数组</p><p>8.Commands lookup and execution</p><p>9.Shutdown</p><p>10.Commands</p><ol start="11"><li><strong>linux</strong></li></ol><p>12.main</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis客户端和服务器的相关代码&quot;&gt;&lt;a href=&quot;#redis客户端和服务器的相关代码&quot; class=&quot;headerlink&quot; title=&quot;redis客户端和服务器的相关代码&quot;&gt;&lt;/a&gt;redis客户端和服务器的相关代码&lt;/h1&gt;&lt;h2 id=&quot;ae-c（
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c，数据库，缓存，redis" scheme="http://chiqtv.cn/tags/c%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>redis4源码阅读学习-1</title>
    <link href="http://chiqtv.cn/2018/11/09/Redis4%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%AD%A6%E4%B9%A0-1/"/>
    <id>http://chiqtv.cn/2018/11/09/Redis4源码阅读学习-1/</id>
    <published>2018-11-09T10:02:37.000Z</published>
    <updated>2019-04-09T11:29:36.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h2><h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">tcmalloc</a></h2><h2 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a><a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><h3 id="详情可以参考GCC官方文档链接"><a href="#详情可以参考GCC官方文档链接" class="headerlink" title="详情可以参考GCC官方文档链接"></a>详情可以参考GCC官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">链接</a></h3><ol><li>分配内存大小为size+PREFIX_SIZE的大小，zmalloc实际分配比需要多一些的内存，这一部分用于存储size信息。</li><li>zmalloc_oom_handler用来处理内存申请异常</li><li>(_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); = if(_n&amp;7) _n += 8 - (_n&amp;7);  32位4字节对齐，64位下8字节对齐</li></ol><h1 id="数据结构：objcet"><a href="#数据结构：objcet" class="headerlink" title="数据结构：objcet"></a>数据结构：objcet</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time).  </span></span><br><span class="line"><span class="comment">              16 bits      8 bits</span></span><br><span class="line"><span class="comment">      +------------------+--------+</span></span><br><span class="line"><span class="comment">      + Last access time | LOG_C  |</span></span><br><span class="line"><span class="comment">      +------------------+--------+*/</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">//通过引用计数的方式来管理内存，c++11，oc</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指向具体实现的具体区域和数据结构</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type字段表示数据类型，有以下几种定义：</span><br><span class="line">OBJ_STRING   <span class="comment">// 字符串</span></span><br><span class="line">OBJ_LIST  <span class="comment">// 链表</span></span><br><span class="line">OBJ_SET  <span class="comment">// 集合</span></span><br><span class="line">OBJ_ZSET  <span class="comment">// 有序集合</span></span><br><span class="line">OBJ_HASH  <span class="comment">// HASH结构（注意，此处不同于传统意义上的哈希表（如stl::hash_map），这里的hash仅有字段散列的语义）</span></span><br><span class="line">REDIS_VMPOINTER  <span class="comment">// VM指针，已经废弃，翻看了一下VM相关实现和历史</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Redis采用VM机制是希望把存储做成如同Oracle一样的方式，具备自动淘汰冷热数据功能，但是，它采用了RDB文件和VM机制来分别实现二进制存储、冷热淘汰的功能，期望是既节约内存又达到完美性能的地步</span></span><br><span class="line"><span class="comment">redis之所以高性能最本质的原因是数据都cache到内存里。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encoding则对应了 Redis 中的10种编码方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure><table><thead><tr><th>数据类型</th><th style="text-align:right">一般情况</th><th style="text-align:center">少量情况</th><th style="text-align:right">特殊情况</th></tr></thead><tbody><tr><td>STRING</td><td style="text-align:right">RAW</td><td style="text-align:center">EMBSTR</td><td style="text-align:right">INT</td></tr><tr><td>LIST</td><td style="text-align:right">LINKEDLIST</td><td style="text-align:center">ZIPLIST</td><td style="text-align:right"></td></tr><tr><td>HASH</td><td style="text-align:right">HT</td><td style="text-align:center">ZIPLIST</td></tr></tbody></table><h3 id="refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"><a href="#refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较" class="headerlink" title="refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"></a>refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的<a href="https://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">引用计数与垃圾收集之比较</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objcet.c基本上就是提供了一堆对象操作，初始化等相关的api接口</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>&#123; <span class="comment">/* 最初的创建robj对象方法，后面的创建方法与此类似 */</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">        <span class="comment">//lru lfu算法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK(); <span class="comment">//都记录下该对象的LRU时钟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//正常释放</span></span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);<span class="comment">//异常</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法"><a href="#Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法" class="headerlink" title="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法"></a>Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法</h2><ol><li>引用计数  refcount</li><li>lru （Least Recently Used）//最长时间未被使用<br><img src="//chiqtv.cn/2018/11/09/Redis4源码阅读学习-1/5.png" alt="Image text"></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) = 2^24 - 1 单位毫秒 /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000  <span class="comment">//代表LRU算法的精度，即一个LRU的单位是多长时间，1秒</span></span></span><br><span class="line"><span class="comment">//LRU时钟的时间粒度高于serverCron刷新的时间粒度，那么就主动获取最新的时间，否则使用server缓存的时间</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">    <span class="comment">//如果定时器执行的频率高于LRU算法的精度时，可以直接将server.lruclock直接在对象创建时赋值过去，避免了函数调用的内存开销以及时间开销</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.........</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lruclock = getLRUClock();</span><br><span class="line">    atomicSet(server.lruclock,lruclock);</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数据的空闲时间</span></span><br><span class="line">evictionPoolPopulate-&gt;estimateObjectIdleTime-&gt;LRU_CLOCK</span><br><span class="line">objectCommand(idletime) -&gt; estimateObjectIdleTime</span><br></pre></td></tr></table></figure><p>3.LFU（Least Frequently Used） 最不常用页面置换算法，基于LFU的热点key发现机制  4.0<br>counter：基于概率的对数计数器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX; <span class="comment">//RAND_MAX c语言宏，rand最大上限值</span></span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">//LFU_INIT_VAL = 5</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//默认server.lfu_log_factor=10，概率因子</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++;   <span class="comment">//baseval增加后，p&lt;r的概率非线形增长</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span><span class="comment">//从db-&gt;dict字典中获取key的val，并更新val的lru/lfu</span></span></span><br></pre></td></tr></table></figure><p><img src="//chiqtv.cn/2018/11/09/Redis4源码阅读学习-1/1.png" alt="Image text"></p><h3 id="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"><a href="#counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万" class="headerlink" title="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"></a>counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万</h3><h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span> 概率因子</span><br><span class="line">lfu-decay-time <span class="number">1</span>  每分钟衰减<span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新对象的访问时间和计数器值,减少，每分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">//获取lru时间  分钟   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//获取使用频次</span></span><br><span class="line">    <span class="comment">//时间超过了lfu_decay_time的话，那么将使用频次减少</span></span><br><span class="line">    <span class="keyword">if</span> (LFUTimeElapsed(ldt) &gt;= server.lfu_decay_time &amp;&amp; counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; LFU_INIT_VAL*<span class="number">2</span>) &#123;</span><br><span class="line">            counter /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; LFU_INIT_VAL*<span class="number">2</span>) counter = LFU_INIT_VAL*<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新时间和频次</span></span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次访问该数据对象已经过去了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前的分钟计数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="redis内存达到上限后的释放内存原则"><a href="#redis内存达到上限后的释放内存原则" class="headerlink" title="redis内存达到上限后的释放内存原则"></a>redis内存达到上限后的释放内存原则</h3><ol><li>释放内存的标准是释放之后使用内存的大小小于maxmemory的大小</li><li>每次释放的数量，redis.conf配置</li><li>超过限制后redis策略</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis.conf配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-lru -&gt; 从设置了过期时间的键中选择空转时间最长的键值对清除掉</span><br><span class="line"><span class="keyword">volatile</span>-lfu -&gt; 从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</span><br><span class="line"><span class="keyword">volatile</span>-random -&gt; 从设置了过期时间的键中，随机选择键进行清除.</span><br><span class="line"></span><br><span class="line">allkeys-lru -&gt; 从所有的键中选择空转时间最长的键值对清除</span><br><span class="line">allkeys-lfu -&gt; 从所有的键中选择某段时间之内使用频次最少的键值对清除.</span><br><span class="line">allkeys-random -&gt; 从所有的key中随机删除</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-ttl -&gt; 从已设置过期时间的数据集合中挑选即将过期的数据淘汰</span><br><span class="line">noeviction -&gt;不做任何的清理工作，禁止写入，报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The <span class="keyword">default</span> of <span class="number">5</span> produces good enough results. <span class="number">10</span> Approximates very closely</span><br><span class="line"><span class="meta"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line">#</span><br><span class="line"><span class="meta"># maxmemory-samples 5 lru，lfu每次采样数，5最佳</span></span><br></pre></td></tr></table></figure><h1 id="如何筛选释放的key"><a href="#如何筛选释放的key" class="headerlink" title="如何筛选释放的key"></a>如何筛选释放的key</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16 <span class="comment">//存储待释放的键相关信息的存储空间能够容纳的键的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255 <span class="comment">//cached中的最大的键的长度    512mb</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span> <span class="comment">//存储待释放的键所在内存的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化EvictionPoolLRU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolAlloc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    ep = zmalloc(<span class="keyword">sizeof</span>(*ep)*EVPOOL_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; EVPOOL_SIZE; j++) &#123;</span><br><span class="line">        ep[j].idle = <span class="number">0</span>;</span><br><span class="line">        ep[j].key = <span class="literal">NULL</span>;</span><br><span class="line">        ep[j].cached = sdsnewlen(<span class="literal">NULL</span>,EVPOOL_CACHED_SDS_SIZE);</span><br><span class="line">        ep[j].dbid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EvictionPoolLRU = ep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"><a href="#根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中" class="headerlink" title="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"></a>根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line"></span><br><span class="line"><span class="comment">//从sampledict中最多选取server.maxmemory_samples个指向sampledict的指针存放在放入到samples中,</span></span><br><span class="line"><span class="comment">//server.maxmemory_samples配置5</span></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment">         * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment">         * again in the key dictionary to obtain the value object. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果maxmemory_policy为MAXMEMORY_VOLATILE_TTL，证明需要将距离过期时间最近的键清除掉;那么直接从redisDB-&gt;expire对应的字典中获取键对应的过期时间值即可，此时不需要改变已经存在的de。</span></span><br><span class="line">   <span class="comment">//如果maxmemory_policy != MAXMEMORY_VOLATILE_TTL且不是从redisDB-&gt;dict中获取键的值(使用redisDB-&gt;expire中获取的键),</span></span><br><span class="line">  那么需要从redisDB-&gt;dict中获取键对应的值的对象，才能够获取lru字段 </span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//lru，lfu，ttl 统一用idle来衡量</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            <span class="comment">/* When we use an LRU policy, we sort the keys by idle time</span></span><br><span class="line"><span class="comment">             * so that we expire keys starting from greater idle time.</span></span><br><span class="line"><span class="comment">             * However when the policy is an LFU one, we have a frequency</span></span><br><span class="line"><span class="comment">             * estimation, and we want to evict keys with lower frequency</span></span><br><span class="line"><span class="comment">             * first. So inside the pool we put objects using the inverted</span></span><br><span class="line"><span class="comment">             * frequency subtracting the actual frequency to the maximum</span></span><br><span class="line"><span class="comment">             * frequency of 255. */</span></span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o); <span class="comment">//LFUDecrAndReturn返回 counter</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">         </span><br><span class="line">  <span class="comment">//EvictionPoolLRU中的元素全部按照元素对应的idle值按照从小到大的顺序</span></span><br><span class="line">    <span class="comment">//idle越大，位置越靠后，当然也就最先被清除掉。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找元素的插入位置</span></span><br><span class="line">        <span class="comment">//pool中所有的元素都不为空，且其中元素的最小的idle大于等于idle</span></span><br><span class="line">        <span class="comment">//EVPOOL_SIZE 16</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">               <span class="comment">//满了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to reuse the cached SDS string allocated in the pool entry,</span></span><br><span class="line"><span class="comment">         * because allocating and deallocating this object is costly</span></span><br><span class="line"><span class="comment">         * (according to the profiler, not my fantasy. Remember:</span></span><br><span class="line"><span class="comment">         * premature optimizbla bla bla bla. */</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用"><a href="#统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用" class="headerlink" title="统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用"></a>统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment"> * count of used memory. */</span></span><br><span class="line">mem_used = mem_reported;</span><br><span class="line"><span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure><h3 id="内存管理策略的入口函数—freeMemoryIfNeeded"><a href="#内存管理策略的入口函数—freeMemoryIfNeeded" class="headerlink" title="内存管理策略的入口函数—freeMemoryIfNeeded()"></a>内存管理策略的入口函数—freeMemoryIfNeeded()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">     <span class="comment">//在阻塞状态，并且阻塞时间未到，应该是和阻塞状态有关</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">     <span class="comment">// 如果没有超过限制，那么没必要进行内存的清理工作</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (mem_reported &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    <span class="comment">// 排查aof，slaves</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">     <span class="comment">//在进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//默认情况，不搞了</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i, keys_freed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">          <span class="comment">//如果策略是TTL，设置了过期时间的LRU，LRU</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">     </span><br><span class="line">                <span class="comment">//针对server中的所有db中选出最佳的可以被淘汰的键进行淘汰 </span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">//从EvctionPoolLRU中的最后一个元素(idle值最大）开始释放内存</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"><span class="comment">//如果是allkeys开头的删除策略，从dict字典中获取对象; 否则从expire字典中获取对象</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">//获取了bestid和de，释放EvctionPoolLRU里面key对应的内存</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="comment">//如果使用random相关的空间管理策略，则直接随机从dict或者expire中获取一个键进行删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">             <span class="comment">//每次选不同db的一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="comment">//最终删除选择的bestkey</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            <span class="comment">/* We compute the amount of memory freed by db*Delete() alone.</span></span><br><span class="line"><span class="comment">             * It is possible that actually the memory needed to propagate</span></span><br><span class="line"><span class="comment">             * the DEL in AOF and replication link is greater than the one</span></span><br><span class="line"><span class="comment">             * we are freeing removing the key, but we can't account for</span></span><br><span class="line"><span class="comment">             * that otherwise we would never exit the loop.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * AOF and Output buffer memory will be freed eventually so</span></span><br><span class="line"><span class="comment">             * we only care about memory used by the key space. */</span></span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">             * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">             * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">             * transmission here inside the loop. */</span></span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally our stop condition is the ability to release</span></span><br><span class="line"><span class="comment">             * a fixed, pre-computed amount of memory. However when we</span></span><br><span class="line"><span class="comment">             * are deleting objects in another thread, it's better to</span></span><br><span class="line"><span class="comment">             * check, from time to time, if we already reached our target</span></span><br><span class="line"><span class="comment">             * memory, since the "mem_freed" amount is computed only</span></span><br><span class="line"><span class="comment">             * across the dbAsyncDelete() call, while the thread can</span></span><br><span class="line"><span class="comment">             * release the memory all the time. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">                mem_used = zmalloc_used_memory();</span><br><span class="line">                mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) &#123;</span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keys_freed) &#123;</span><br><span class="line">            latencyEndMonitor(latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;= mem_tofree)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ol><li>淘汰算法的优化，更有效的需要淘汰的key</li><li>算法对性能，内存的影响</li></ol><h2 id="过期key删除策略"><a href="#过期key删除策略" class="headerlink" title="过期key删除策略"></a>过期key删除策略</h2><h3 id="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"><a href="#惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；" class="headerlink" title="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"></a>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">//获取过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">     <span class="comment">//执行lua脚本，先阻塞</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">     <span class="comment">//主从同步，从不删除，只删除主节点，从节点同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">//没过期</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">//过期数量++</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">//失效记录，aof记录等</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);  <span class="comment">//lazy机制</span></span><br><span class="line">    <span class="comment">//发送删除通知从数据库</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//删除方式选择，异步或者同步</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">     <span class="comment">//删除待清理key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">     <span class="comment">//返回数据库字典中包含key的条目指针，并从数据库字典中摘除该条目</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);<span class="comment">//评估代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If releasing the object is too much work, let's put it into the</span></span><br><span class="line"><span class="comment">         * lazy free list. */</span></span><br><span class="line">         <span class="comment">//判断大小，是否需要后台删除，大于64的再丢给后台线程bio后台处理</span></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD) &#123;</span><br><span class="line">            </span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);<span class="comment">//待处理对象增加1</span></span><br><span class="line">            </span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//丢给bio后台子线程弄</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="comment">//集群模式下</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.conf </span><br><span class="line">lazyfree-lazy-eviction no  <span class="comment">//内存满  freeMemoryIfNeeded</span></span><br><span class="line">lazyfree-lazy-expire no  <span class="comment">//过期     expireIfNeeded</span></span><br><span class="line">lazyfree-lazy-server-del no  <span class="comment">//del命令  dbDelete</span></span><br><span class="line">slave-lazy-flush no   <span class="comment">//slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景   readSyncBulkPayload</span></span><br></pre></td></tr></table></figure><p><strong>lazyfree机制  删除大数据的键值，导致redis阻塞，4.0引入的，将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</strong></p><h4 id="redis-思考"><a href="#redis-思考" class="headerlink" title="redis 思考"></a>redis 思考</h4><ol><li>redis4.0引入的命令 unlink（unlinkCommand）</li><li>FLUSHALL/FLUSHDB ASYNC  线上禁用</li><li>Lazy 应该全开</li></ol><h3 id="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长"><a href="#定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长" class="headerlink" title="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长"></a>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长</h3><ol><li>databasesCron -&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);分多次<br>遍历各个数据库，从expires字典中随机检查一部分过期键的过期时间，删除其中的过期键</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW 0</span></span><br><span class="line"><span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;  </span><br><span class="line"><span class="comment">//server.hz  10 默认值，conf，serverCron任务的执行周期执行周期，空闲每秒执行10次，清理时间最大为25ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_FAST 1   <span class="comment">//1000微秒</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">               <span class="comment">//随机取，过期删除</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span><span class="comment">//删除5个就遍历下一个db</span></span><br></pre></td></tr></table></figure><ol start="2"><li>事件处理函数aeMain    beforeSleep  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</li><li>访问key 判断lookupKeyRead，过期删除</li></ol><h2 id="持久化rdb-aof"><a href="#持久化rdb-aof" class="headerlink" title="持久化rdb/aof"></a>持久化rdb/aof</h2><h3 id="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"><a href="#rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态" class="headerlink" title="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"></a>rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态</h3><ol><li>RDB文件创建两个命令可以生成RDB文件：SAVE和BGSAVE。</li></ol><p><img src="//chiqtv.cn/2018/11/09/Redis4源码阅读学习-1/2.png" alt="Image text"><br>   SAVE命令会阻塞redis的服务器进程，直到RDB文件创建完毕为止。在阻塞过程中，server不能处理任何请求    saveCommand-&gt;rdbSave-&gt;rdbSaveRio-&gt;rdbSaveKeyValuePair<br>   REDIS // RDB协议约束的固定字符串<br>   0006 // redis的版本<br>   FE 00 // 表示当前接下来的key都是db=0中的key;<br>   FC 1506327609 // 表示key失效时间点为1506327609<br>   0 // 表示key的属性是string类型<br>   username // key<br>   afei // value<br>   FF // 表示遍历完成<br>   y73e9iq1 // checksum  , CRC64</p><p>   <img src="//chiqtv.cn/2018/11/09/Redis4源码阅读学习-1/3.jpeg" alt="Image text"><br>   BGSAVE则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。<br>   fork()系统调用我们可以创建一个和当前进程一样的新进程，继承了父进程的整个地址空间,其中包括了进程上下文,堆栈地址,内存信息进程控制块<br>   bgsaveCommand-&gt;rdbSaveBackground-&gt; rdbSave<br>   <a href="https://blog.codingnow.com/2011/01/fork_multi_thread.html" target="_blank" rel="noopener">fork危害，多进程的多线程程序</a><br>   自动执行bgsave，配置redis.conf  </p><h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>   save 900 1<br>   save 300 10<br>   save 60 10000<br>   只要这三个条件中的任意一条符合，那么服务器就会执行BGSAVE。配置保存在 redisServer saveparam中，serverCron中判断执行<br>   rdb加载，loadDataFromDisk -&gt; rdbLoad（），阻塞</p><ol start="2"><li><p>aof记录服务器所处理的所有的除查询意外的操作，以文本的方式记录<br>原理是：处理文件事件执行写命令，使得命令被追加到aof_buf中，，然后在处理时间事件执行serverCron函数会调用flushAppendOnlyFile函数进行文件的写入和同步。<br> appendonly yes<br> appendfilename “appendonly.aof”<br> appendfsync everysec<br> always：将aof_buf中的所有内容写入并同步到aof文件。<br> everysec：将aof_buf中的所有内容写入到aof文件，如果上次同步的时间距离现在超过1s，那么对aof文件进行同步，同步操作由一个线程专门负责执行<br> no：将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，同步有操作系统执行。</p><p> aof流程主要函数：<br> //函数1：将command写入aof_buff  propagate-&gt; feedAppendOnlyFile，数据修改更新到AOF缓存中<br> //函数2：启动子进程，后台用于整理aof的数据 serverCron-&gt; rewriteAppendOnlyFileBackground<br> //函数3：刷一遍server.db[16],依次将对象写入磁盘临时文件tmpfile，rewriteAppendOnlyFile -&gt;rewriteAppendOnlyFileRio<br> //函数4：将aof_buff内容持久化flushAppendOnlyFile<br> //函数5：将backgroundRewriteDoneHandler 更新子进程同步期间产生的修改</p><p><img src="https://img-blog.csdn.net/20160503161237360" alt="Image text">   </p><p> aof_rewrite 解决AOF文件体积膨胀的问题<br> 触发条件  </p><ol><li>被动： 当AOF文件尺寸超过conf：auto-aof-rewrite-min-size 64mb &amp; 达到一定增长比，<br>指当前aof文件比上次重写的增长比例大小 auto-aof-rewrite-percentage 100； </li><li>主动： 调用BGREWRITEAOF命令；<br><img src="https://img-blog.csdn.net/20160503161309698" alt="Image text"><br>对应bgrewriteaofCommand逻辑  </li></ol></li><li><p>混合持久化 conf aof-use-rdb-preamble no， aof rewrite 的时候就直接把 rdb 的内容写到 aof 文件开头     </p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |          RDB           |   </span><br><span class="line">            |         FORMAT         |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |        AOF             |   </span><br><span class="line">            |       FORMAT           |   </span><br><span class="line">            +------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">       <span class="keyword">int</span> error;</span><br><span class="line">       <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">           errno = error;</span><br><span class="line">           <span class="keyword">goto</span> werr;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>rdb优缺点：二进制文件，速度快，存在数据丢失，性能消耗低<br>aof优缺点：数据丢失小，性能消耗大，4.0管道优化相对好些<br>混合持久化：加载速度快，避免丢失数据</p><h3 id="事故案例：陌陌争霸"><a href="#事故案例：陌陌争霸" class="headerlink" title="事故案例：陌陌争霸"></a>事故案例：陌陌争霸</h3><p>32 个数据仓库部署到 4 台物理机上即可，每台机器上启动 8 个 Redis 进程。使用 64G 内存的机器，后来增加到了 96G 内存。实测每个 Redis 服务会占到 4~5 G 内存，四台配置相同的从主机进行主从备份。  </p><p>事故1：有一台数据服务主机无法被游戏服务器访问到，影响了部分用户登陆，运维维护时发现，一台从机的内存耗尽，导致了从机的数据库服务重启。在从机重新对主机连接，8 个 Redis 同时发送 SYNC 的冲击下，把主机击毁了。<br>问题1：从主机为什么出现内存不足<br>原因：redis 服务同时做 BGSAVE，概率性 ，而导致 fork 多个进程需要消耗太多内存<br>问题2：重新进行 SYNC 操作会导致主机过载<br>原因：重启后，8 个 slave redis 同时开启同步，等于瞬间在主机上 fork 出 8 个 redis 进程<br>解决方案：取消主从，脚本控制bgsave</p><p>事故2:内存内存不足<br>原因：定期备份redis数据库文件，拷贝数据库文件时，系统使用大量的内存做为cache，释放不及时，脚本控制bgsave，内存不住，使用交换分区，脚本保证30分钟内必须执行一次bgsave</p><p>思考：1.备份方案的选择。2.使用leveldb做redis的持久化存储 3.redis内存上限设置一半  </p><h1 id="hyperloglog-c"><a href="#hyperloglog-c" class="headerlink" title="hyperloglog.c"></a>hyperloglog.c</h1><h2 id="在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"><a href="#在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身" class="headerlink" title="在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"></a>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</h2><p>##看到第一句话就知道这个已经完全没有了解的必要了，逆天的算法，用于比如ip访问数的基数统计。</p><h2 id="动态字符串-sds-h和sds-c"><a href="#动态字符串-sds-h和sds-c" class="headerlink" title="+ 动态字符串 sds.h和sds.c"></a>+ 动态字符串 sds.h和sds.c</h2><h2 id="双端链表-adlist-c和adlist-h"><a href="#双端链表-adlist-c和adlist-h" class="headerlink" title="+ 双端链表 adlist.c和adlist.h"></a>+ 双端链表 adlist.c和adlist.h</h2><h2 id="字典-dict-h和dict-c"><a href="#字典-dict-h和dict-c" class="headerlink" title="+ 字典 dict.h和dict.c"></a>+ 字典 dict.h和dict.c</h2><h2 id="跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。"><a href="#跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。" class="headerlink" title="+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。"></a>+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。</h2><h2 id="intset-c和intset-h"><a href="#intset-c和intset-h" class="headerlink" title="+intset.c和intset.h"></a>+intset.c和intset.h</h2><ol><li>intset 是一种有序的整型集合，共有 <code>INTSET_ENC_INT16</code>、<code>INTSET_ENC_INT32</code>、<code>INTSET_ENC_INT64</code> 编码类型。</li><li>intset <code>length</code> 属性记了录集合的大小。</li><li>intset 内部采用<code>二分查找算法</code> 定位元素。</li><li>intset 只会升级，不会降级。当将一个高位元素添加到低编码集合时，此时，需要对集合进行升级。</li></ol><h2 id="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"><a href="#这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。" class="headerlink" title="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"></a>这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。</h2><h2 id="ziplist-c和ziplist-h"><a href="#ziplist-c和ziplist-h" class="headerlink" title="ziplist.c和ziplist.h"></a>ziplist.c和ziplist.h</h2><ol><li>实在是不想看实现了，估计也看不懂，看名字就知道是一种极节内存内存的链表，redis是内存性数据库，肯定还是要能省则省，代码肯定是有的，肯定是性能稍微差一点，但是应该差的不多，大神撸出来的东西是不用有任何怀疑的。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zmalloc-c&quot;&gt;&lt;a href=&quot;#zmalloc-c&quot; class=&quot;headerlink&quot; title=&quot;zmalloc.c&quot;&gt;&lt;/a&gt;zmalloc.c&lt;/h2&gt;&lt;h2 id=&quot;tcmalloc&quot;&gt;&lt;a href=&quot;#tcmalloc&quot; class=&quot;
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c，数据库，缓存，redis" scheme="http://chiqtv.cn/tags/c%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E7%BC%93%E5%AD%98%EF%BC%8Credis/"/>
    
  </entry>
  
  <entry>
    <title>DDoS防护的方案和演进</title>
    <link href="http://chiqtv.cn/2018/10/09/DDoS%E9%98%B2%E6%8A%A4%E7%9A%84%E6%96%B9%E6%A1%88%E5%92%8C%E6%BC%94%E8%BF%9B/"/>
    <id>http://chiqtv.cn/2018/10/09/DDoS防护的方案和演进/</id>
    <published>2018-10-09T10:02:37.000Z</published>
    <updated>2019-04-10T12:31:52.845Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>国内某一线公司的DDoS防护方案迭代    </p></blockquote><blockquote><p>单点故障</p><p>单点资源瓶颈</p><p>主要解决办法：程序识别或运营通过调度DNS来解决</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/1.png" alt></p><blockquote><p>LVS+KEEPALIVED+JLB</p><p>高效率</p><p>易部署</p><p>易管理</p><p>能充分利用机房资源（所有计算机、以及所有带宽资源）</p><p>上行带宽瓶颈</p><p>数据报文转发瓶颈</p><p>无抵御攻击能力</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/2.png" alt></p><blockquote><p>架构图：DPVS+Firewall+keepalived+JLB</p><p>增加了抵御L4攻击的能力</p><p>增加了数据包的转发能力</p><p>引入问题：</p><p>开发、调试、部署相对麻烦</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/3.png" alt></p><blockquote><p>架构图：ECMP+DPVS+Firewall+JLB</p><p>解决了上行瓶颈问题</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/4.png" alt></p><blockquote><p>WAN/LAN Anycast +ECMP+Firewall&amp;LoadBalancer（XDP+eBPF）</p><p>机房整体资源充分利用，整体上无明显的缺点</p><p>需要开发很多周边控制程序</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/5.png" alt></p><blockquote><p>WAN/LAN Anycast +ECMP+Firewall（XDP+eBPF）</p><p>机房整体资源利用</p><p>避免引入了故障点（LB，firewall）</p><p>需要开发很多周边控制程序</p></blockquote><p><img src="//chiqtv.cn/2018/10/09/DDoS防护的方案和演进/6.png" alt></p><blockquote><p>个人感受：从框架的迭代进化来看，其实没有什么技术上的难点，用一句很简单的话来说就是，所以99%的计算机问题都可以通过加入一个中间层来解决，和今天的大公司的移动端，后端框架一样，无非是变的的越来越重，越来越层，把问题细分化来解决。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;国内某一线公司的DDoS防护方案迭代    &lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;单点故障&lt;/p&gt;
&lt;p&gt;单点资源瓶颈&lt;/p&gt;
&lt;p&gt;主要解决办法：程序识别或运营通过调度DNS来解决&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="安全" scheme="http://chiqtv.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="DDos" scheme="http://chiqtv.cn/tags/DDos/"/>
    
  </entry>
  
  <entry>
    <title>ssl pinning</title>
    <link href="http://chiqtv.cn/2017/10/01/ssl-pinning/"/>
    <id>http://chiqtv.cn/2017/10/01/ssl-pinning/</id>
    <published>2017-10-01T00:59:58.000Z</published>
    <updated>2019-04-09T06:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ssl-pinning-mode"><a href="#ssl-pinning-mode" class="headerlink" title="ssl pinning mode"></a>ssl pinning mode</h1><p>https抓包的问题，工作的一个小争论引发的，不相信https可以抓包分析数据，非要我演示一次。https抓包其实早就已经烂大街，本着用事实说话的方式，安装了Charles，发现竟然有部分如淘宝，支付宝的包无法解析，jd的是正常的，好奇的查了一下，才知道现在有ssl pinning mode这个东西。</p><h2 id="简述一下https的连接过程"><a href="#简述一下https的连接过程" class="headerlink" title="简述一下https的连接过程"></a>简述一下https的连接过程</h2><p><img src="//chiqtv.cn/2017/10/01/ssl-pinning/1.gif" alt></p><h3 id="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"><a href="#上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。" class="headerlink" title="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"></a>上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。</h3><p>1、client hello和 server hello表示双方要建立一个加密会话。</p><p>2、服务器把数字证书传输给客户端，证书中包含服务器公钥，客户端用公钥解析证书中的数字签名，可以验证服务器的身份。</p><p>3、Server Hello Done表示hello 流程结束。</p><p>4、客户端生成一个对称加密密钥，用于实际数据的加密传输，并用服务器的公钥加密，把对生成的密钥传递给服务器。同时携带一个用刚刚生成的加密密钥加密的“client finished”。</p><p>5、服务器收到对称加密密钥，并尝试用该密钥解密加密字段，如能得到明文“client finished”，认为该密钥有效，可以用于之后的数据加密传输。同时用该密钥加密“server finished”，传递给客户端。</p><p>6、客户端用对称机密密钥解密，如能得到明文“server finished”，客户端认为该服务器已经正确的接收到对称密钥。</p><p>7、加密数据传输开始。</p><blockquote><p>虚线部分是服务器端要求验证客户身份,和双向认证有关。</p></blockquote><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ol><li>内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。 </li><li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持 </li><li>数据完整性。防止内容被第三方冒充或者篡改。</li></ol><h3 id="带来的问题：中间人攻击（MITM）"><a href="#带来的问题：中间人攻击（MITM）" class="headerlink" title="带来的问题：中间人攻击（MITM）"></a>带来的问题：中间人攻击（MITM）</h3><p><img src="//chiqtv.cn/2017/10/01/ssl-pinning/2.jpeg" alt></p><ol><li>客户端首先要向远程的服务器发送建立连接的请求，并带有自己的支持的加解密的方式级别，这个过程经过了中间人的窃听，中间人把消息修改后发给了真正的目的地——服务端</li><li>服务端收到了要建立https链接的请求后，会发送当时从证书签发机构签发的公钥证书。这个过程中中间人又窃听了，然后中间人替换上自己的证书后又转发给了客户端。</li><li>客户端收到了中间人发过来的公钥证书，验证证书的真伪，并产生随机的对称加密的密钥，用中间人发的公钥加密后发给了中间人。由于刚才客户端收到的公钥证书本身就是中间人产生的，所以中间人用相应的私钥就解开了，拿到了客户端产生的那个随机产生的对称加密密钥。中间人再用刚才服务端返回的公钥证书加密这个客户端产生的用来对称加密的密钥，发给服务端。</li><li>服务端收到了当时用自己下发的公钥的证书加密的对称加密密钥，用自己的私钥解密，也得到了对称加密的密钥。</li></ol><blockquote><p>用Charles来搞是比较常见的，网上的教程也是一把一把的，大部分https的数据包都的可以解析出来，但是阿里系的不行。</p></blockquote><h3 id="解决中间人攻击的办法：ssl-pinning-mode"><a href="#解决中间人攻击的办法：ssl-pinning-mode" class="headerlink" title="解决中间人攻击的办法：ssl pinning mode"></a>解决中间人攻击的办法：ssl pinning mode</h3><ol><li>简单点说就是：ssl pinning就是client能够把server的证书和一个已知的server的证书的拷贝做对比，通过把server的ssl 证书捆绑到程序中就可以达到目的</li><li>如果还是想获取接口请求参数估计只能从客户端逆向入手了，类似于iOS上的Snoop-it一类的工具，网上实际上也有很完整的解决方案了，实际上就是hook的方式将此次校验的结果返回true或者干脆不让其做校验，前提是手机一定要越狱，开源<a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">方案地址</a>，具体原理可以<a href="https://nabla-c0d3.github.io/blog/2016/02/21/ssl-kill-switch-twitter/" target="_blank" rel="noopener">参考</a>。</li><li>其实做到https+强制pinning就很少有人搞的动了，还担心就加上双向认证，关键还有就是客户端的代码质量。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ssl-pinning-mode&quot;&gt;&lt;a href=&quot;#ssl-pinning-mode&quot; class=&quot;headerlink&quot; title=&quot;ssl pinning mode&quot;&gt;&lt;/a&gt;ssl pinning mode&lt;/h1&gt;&lt;p&gt;https抓包的问题，工作的
      
    
    </summary>
    
      <category term="安全" scheme="http://chiqtv.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ssl" scheme="http://chiqtv.cn/tags/ssl/"/>
    
      <category term="https" scheme="http://chiqtv.cn/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Android Facede</title>
    <link href="http://chiqtv.cn/2016/08/01/Android-Facede/"/>
    <id>http://chiqtv.cn/2016/08/01/Android-Facede/</id>
    <published>2016-08-01T00:59:58.000Z</published>
    <updated>2019-04-09T07:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android外观模式的应用"><a href="#Android外观模式的应用" class="headerlink" title="Android外观模式的应用"></a>Android外观模式的应用</h1><pre><code>这是一个`app`最初的项目结构  </code></pre><p><img src="//chiqtv.cn/2016/08/01/Android-Facede/1.png" alt></p><p>所有的页面都放在<code>activities</code>，自定义<code>view</code>放在<code>widget</code>，网络相关的封装在<code>network</code>，所有工具类放在<code>utils</code>，少数的<code>xxxManager</code>单例藏在某个包下面，因为少没必要过度提炼就这样吧…<br>没什么问题，项目上线！  </p><p>随着项目迭代，越来越多的页面来了，数据库的表也多起来了，工具类更是爆炸性增长，还不排除有些工具类还在<code>activity</code>里面没来得及提炼出来，<code>xxxManager</code>散落一地，<code>callback</code>到处都是…各个包的类都在快速增长</p><p>如果用线来表示相互间的调用，那么整个项目就是一个毛线团，找代码都开始难找了<br>那么这时候就改理一理这个线团了</p><p>之前app没有一个明确的职责分层，横向依赖很严重，小改伤筋动骨</p><h5 id="AppContext与外观模式的应用"><a href="#AppContext与外观模式的应用" class="headerlink" title="AppContext与外观模式的应用"></a>AppContext与外观模式的应用</h5><p>随着业务的发展，<code>app</code>里面的组件，业务线也会逐渐的增多。<br>每个业务线一个<code>module</code>，那么新的问题就来了，<code>module</code>之间的通信问题，横向依赖问题。  </p><p>每个<code>module</code>除了在自己的地盘处理业务，还有可能给其他module提供服务，或者这个<code>module</code>就是一个<code>plugin</code>风格的业务组件。<br>比较粗暴的做法，直接引用<code>module</code>，想调谁就引用谁，那么这和之前单<code>module</code>，类的横向引用又有什么本质上的区别呢？<br>这里我们可以借鉴下<code>Android</code>的<code>Context</code>类的设计，<code>Context</code>就是封装了一大堆<code>Android</code>的子系统（通过<code>getSystemService</code>获取），处理在Android环境下的通信问题。<br>那么我们可以依葫芦画瓢的设计一个我们自己的<code>AppContext</code>，我们的业务<code>module</code>或者组件都是在<code>AppContext</code>环境下，他们之间的通信就通过<code>AppContext</code>，具体业务就交给具体的<code>modul</code>e实现.<br>如果设计多个业务<code>module</code>的协作，那么也应该由<code>AppContext</code>屏蔽协作的细节，这是一个很典型的外观模式的应用。<br>在面向对象编程范式内，很多问题都可以通过引入额外的一层来解决<br><img src="//chiqtv.cn/2016/08/01/Android-Facede/2.png" alt>  </p><p>有些基础组件<code>module</code>或通用性非常高的<code>module</code>，可以下沉到<code>AppContext</code>下面</p><p><code>AppContext</code>的核心职责就是封装好<code>app</code>所用到的子系统（审视下以前代码里面的单例<code>manager</code>，思考一下他是不是能作为<code>app</code>的一个子系统工作）来统一管理服务，无论该服务是基于<code>Android</code>，还是业务<code>module</code>，还是其他第三方组件。当然这里也应该<code>module</code>与<code>app</code>通信，一些app级别的配置也可以在这里处理</p><p>在实际操作中，一定要渐进式的处理，主要是因为：</p><ul><li>互联网时代不能让飞机停下来，做到在天上就给飞机动了手术</li><li>可以逐渐验证自己的方案，不要一开始就置自己于险境</li></ul><blockquote><p>比如目前工程中moduleA直接依赖moduleB调用接口，重构过程中不必直接取消依赖（不要影响目前的业务），在AppContext中添加一个moduleB的service，这个service代理moduleB提供的接口服务，然后moduleA调用接口逐渐的转向AppContext提供的方式，当转得差不多的时候就断掉moduleA与moduleB之间的依赖。</p></blockquote><p>对于有些业务线的<code>module</code>，完全可以把他当做一个app来对待  </p><p><img src="//chiqtv.cn/2016/08/01/Android-Facede/3.png" alt>  </p><h5 id="AppContext只是解决了module之间的通信或者是子系统的管理"><a href="#AppContext只是解决了module之间的通信或者是子系统的管理" class="headerlink" title="AppContext只是解决了module之间的通信或者是子系统的管理"></a>AppContext只是解决了module之间的通信或者是子系统的管理</h5><blockquote><p>由多收缩到一的问题（统一依赖AppContext），只限于单进程，还没有跨进程，跨app，关于跨进程local，remote的问题，另开一贴讲设计思路与实现</p></blockquote><p>一个<code>App</code>除了通信，还有一些工具类，一些的<code>style</code>，<code>theme</code>，<code>resource</code>相关的定义。  </p><p>很多<code>app</code>都会搞一个类似<code>core</code>，<code>common</code>的<code>module</code>，一股脑儿的扔里面，这玩意儿到后面绝对是一锅东北菜，乱炖的感觉。  </p><p>对于<code>module</code>层级下面的<code>util</code>，只能是高度通用的<code>util</code>才放到下面，命名一定要体现其具体功能，千万不要直接<code>utils</code>，<code>StringUtils</code>等很模糊的命名，推荐<code>Logger</code>，<code>DeviceUtil</code>，<code>UrlUtil</code>等一眼就能看出其具体功能的<code>util</code>。  </p><p>对于<code>resource</code>相关的定义，单独一个<code>module</code><br>这些<code>module</code>都会逐渐沉淀下来，以后<code>app</code>按需依赖.<br><img src="//chiqtv.cn/2016/08/01/Android-Facede/4.png" alt><br>黑线一下的就是业务线开发的基础，是不是有点类似<code>android.jar</code>的感觉</p><h4 id="UserCase"><a href="#UserCase" class="headerlink" title="UserCase"></a>UserCase</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">人之所以聪明，是因为人会创造工具并使用</span><br><span class="line"></span><br><span class="line">重构的基础是人员，如何照顾开发的情绪，如何渐进式的进行重构，</span><br><span class="line">如何借助工具进行重构，重构不等于重写，重构不等于业务都给我停下让路</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android外观模式的应用&quot;&gt;&lt;a href=&quot;#Android外观模式的应用&quot; class=&quot;headerlink&quot; title=&quot;Android外观模式的应用&quot;&gt;&lt;/a&gt;Android外观模式的应用&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;这是一个`app`最初的项目
      
    
    </summary>
    
      <category term="Android" scheme="http://chiqtv.cn/categories/Android/"/>
    
    
      <category term="android" scheme="http://chiqtv.cn/tags/android/"/>
    
      <category term="设计模式" scheme="http://chiqtv.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>libco</title>
    <link href="http://chiqtv.cn/2016/04/08/libco/"/>
    <id>http://chiqtv.cn/2016/04/08/libco/</id>
    <published>2016-04-08T14:39:02.000Z</published>
    <updated>2019-04-09T06:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="co-create-初始化相关"><a href="#co-create-初始化相关" class="headerlink" title="co_create  初始化相关"></a>co_create  初始化相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,</span><br><span class="line">   pfn_co_routine_t pfn,void *arg )</span><br><span class="line"></span><br><span class="line">static stCoRoutineEnv_t* g_arrCoEnvPerThread[ 204800 ] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">void co_init_curr_thread_env()</span><br></pre></td></tr></table></figure><ol><li><p>将Env_t信息保存在全局变量g_arrCoEnvPerThread中对应于threadId的位置</p></li><li><p>创建一个空协程，被设置为当前Env_t的main routine，用于运行该线程的主逻辑</p></li><li><p>Epoll_t相关的信息初始化，管理时间片相关</p></li><li><p>stCoRoutine_t 保存每个协程的信息</p></li></ol><ol><li><p>co_create_env</p><p>创建协程的函数是co_create_env()，每个协程有自己密切相关的结构stCoRoutine_t</p></li><li><p>支持共享栈</p><p>所以共享栈采用的方式就是每次发生协程切换的时候，把实际用到的栈内容stack_bp   stack_sp通过save_stack_buffer来保存到malloc的内存中去，然后调用coctx_swap进行寄存器信息的切换，再把切换进来的新协程之前以相同方式保存的栈数据再拷贝到上面的共享栈空间的对应的内存位置上去(栈指针在coctx_swap已经更新完了，这里只是填补数据的作用，而且每个协程切换前后一直使用相同的共享栈，即使有局部指针也没有问题)，从而大大增加了内存的利用效率。</p></li></ol><h2 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h2><p>协程 = 回调 + 栈内存</p><p>协程执行实际是协程的切换，包括协程上下文（寄存器状态）的切换，回调执行之后会再次切换回来</p><p>如果协程中创建了新的协程，则会有嵌套的协程切换</p><p>co_resume</p><p>同时创建的协程第一次启动也是使用这个接口，并且在第一次启动的时候会初始化特殊的coctx_t结构，在协程执行结束后，会自动设置cEnd=1，同时将自己yield出去</p><p>栈帧stack frame layout：</p><p><img src="//chiqtv.cn/2016/04/08/libco/illustration-1.png" alt></p><p>调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2</p><p><img src="//chiqtv.cn/2016/04/08/libco/illustration-2.png" alt></p><p>libco程序的第一个协程呢，假如第一个协程yield时，CPU控制权让给谁呢？关于这个问题，我们首先要明白这“第一个”协程是什么。实际上，libco的第一个协程，即执行main函数的协程，是一个特殊的协程。这个协程又可以称作主协程，它负责协调其他协程的调度执行（后文我们会看到，还有网络 </p><p>I/O以及定时事件的驱动），它自己则永远不会yield，不会主动让出 </p><p>CPU。不让出CPU，不等于说它一直霸占着CPU。我们知道CPU执行权有两种转移途径，一是通过yield让给调用者，其二则是resume启动其他协程运行。</p><h4 id="阻塞调用Hook"><a href="#阻塞调用Hook" class="headerlink" title="阻塞调用Hook"></a>阻塞调用Hook</h4><p>通过glibc中dlfcn.h的dlsym和RTLD_NEXT结合起来，从而给标准库函数添加钩子</p><p>#define HOOK_SYS_FUNC(name) if( !g_sys_##name##_func ) { g_sys_##name##_func = (name##_pfn_t)dlsym(RTLD_NEXT,#name); }</p><p>epoll 基于事件驱动的IO多路复用技术，1. mmap，2. 红黑树，33. rdlist</p><p><strong>int</strong> <strong>epoll_create(**</strong>int<strong> </strong>size);**</p><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p><p>epoll的事件注册函数 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p><p>等待事件的产生</p><h4 id="协程的事件管理"><a href="#协程的事件管理" class="headerlink" title="协程的事件管理"></a>协程的事件管理</h4><ol><li><p>初始化 AllocEpoll</p></li><li><p>添加监听事件 co_poll</p></li><li><p>轮询 co_eventloop</p></li></ol><h4 id="感受"><a href="#感受" class="headerlink" title="感受:"></a>感受:</h4><blockquote><p>总体代码质量并不是特别好，总感觉为了使用C++而使用C++，甚至有些命名都不是 特别规范，最好理解的协程库还是云风c语言版本的，强力推荐，libco最大的优势就是作为微信内部框架的底层库，在线上也承受了巨大的流量，稳定跑到几千台服务器上，其他的都不重要。</p></blockquote><p>libco github ：<a href="https://github.com/Tencent/libco" target="_blank" rel="noopener">地址</a></p><p>云风 github： <a href="https://github.com/cloudwu/coroutine/" target="_blank" rel="noopener">地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;co-create-初始化相关&quot;&gt;&lt;a href=&quot;#co-create-初始化相关&quot; class=&quot;headerlink&quot; title=&quot;co_create  初始化相关&quot;&gt;&lt;/a&gt;co_create  初始化相关&lt;/h2&gt;&lt;figure class=&quot;high
      
    
    </summary>
    
      <category term="第三方源码库" scheme="http://chiqtv.cn/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%BA%90%E7%A0%81%E5%BA%93/"/>
    
    
      <category term="c++" scheme="http://chiqtv.cn/tags/c/"/>
    
      <category term="协程" scheme="http://chiqtv.cn/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--智能指针</title>
    <link href="http://chiqtv.cn/2014/08/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>http://chiqtv.cn/2014/08/09/c-11学习笔记-智能指针/</id>
    <published>2014-08-09T10:14:25.000Z</published>
    <updated>2019-04-09T10:28:28.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常高，很多地方都会使用到，只存在一份拷贝显然是最好的，这个时候对象生命周期的管理就会很复杂，所以c++引入了智能指针。</p><p>任何事物都会有两面性。</p></blockquote><h2 id="Shared-ptr"><a href="#Shared-ptr" class="headerlink" title="Shared_ptr"></a>Shared_ptr</h2><h3 id="摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）"><a href="#摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）" class="headerlink" title="摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）"></a>摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;construct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    ~Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;destruct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int priority()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;22222&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processWidget(int priority,std::shared_ptr&lt;Widget&gt; pw)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;111111&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    processWidget(priority(),std::shared_ptr&lt;Widget&gt;(new Widget));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>processWidget运行的过程应该是</p><ol><li><p>New Widget</p></li><li><p>shared_ptr constructor</p></li><li><p>Priority()</p></li></ol><p>我在llvm上测试的结果也是这个执行顺序</p><p>也许某些编译器上可能执行的顺序是</p><ol><li><p>New Widget</p></li><li><p>Priority() //发生异常</p></li><li>shared_ptr constructor</li></ol><p>就有可能有内存泄露</p><blockquote><p><strong>所以最好的办法还是应该把new widget提到外面来写，所以好的编码习惯很重要。</strong></p></blockquote><h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BPtr b;</span><br><span class="line">    ~A () &#123;</span><br><span class="line">         cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    APtr a;</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b; // 1</span><br><span class="line">    b-&gt;a = a; // 2</span><br><span class="line">    </span><br><span class="line">     cout &lt;&lt; &quot;over!!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr"><a href="#要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr" class="headerlink" title="要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr"></a>要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line"></span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line">typedef std::weak_ptr&lt;A&gt; AWeakPtr;</span><br><span class="line">typedef std::weak_ptr&lt;B&gt; BWeakPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BWeakPtr b; // 注意这里</span><br><span class="line">    ~A () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    AWeakPtr a; // 注意这里</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这两种指针其实和oc里面的 strong, weak非常相识。</p><p> weak_ptr的另外一种用法</p><p>使用情景：当类对象被 shared_ptr 管理时，需要在类自己定义的函数里把当前类对象作为参数传给其他函数时，这时需要传递一个 shared_ptr ，否则就不能保持 shared_ptr 管理这个类对象的语义（因为有一个 raw pointer 指向这个类对象，而 shared_ptr 对类对象的这个引用没有计数，很有可能 shared_ptr 已经把类对象资源释放了，而那个调用函数还在使用类对象——显然，这肯定会产生错误）。《摘录：<a href="http://blog.csdn.net/zhongguoren666/article/details/8617436》" target="_blank" rel="noopener">http://blog.csdn.net/zhongguoren666/article/details/8617436》</a></p><p>直接看官网的例子吧：</p><p>《<a href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Good: std::enable_shared_from_this&lt;Good&gt;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; getptr() &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bad</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CObj: public std::enable_shared_from_this&lt;CObj&gt; &#123;</span><br><span class="line">    friend class CObjMgr;</span><br><span class="line">protected:</span><br><span class="line">    CObj() &#123;&#125;   // 只有CObjMgr可以创建与删除</span><br><span class="line">    ~CObj()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // Good: the two shared_ptr&apos;s share the same object</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1(new Good);</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;gp2.use_count() = &quot; &lt;&lt; gp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    </span><br><span class="line">    // Bad, each shared_ptr thinks it&apos;s the only owner of the object</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad);</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; // UB: double-delete of Bad</span><br></pre></td></tr></table></figure><ol><li>绝对不能在构造函数中调用shared_from_this()</li></ol><p>​      因为shared_ptr里面初始化enable_shared_from_this的成员weak_ptr，      这个时候weak_ptr还是空值。</p><ol start="2"><li>为什么内部不能用this指针</li></ol><p>​      因为我们程序中用shared_ptr来管理指针，如果我们在类的内部传递的过程中用原始指针，这样类内部的引用shared_ptr不会察觉到，因为有可能我们传进去的时候已经被shared_ptr释放掉了</p><h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><blockquote><p>相对就要单纯许多了，unique_ptr“唯一”拥有其所指对象，只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p></blockquote><h3 id="代替普通指针"><a href="#代替普通指针" class="headerlink" title="代替普通指针"></a>代替普通指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo()  </span><br><span class="line">&#123;//不安全的代码  </span><br><span class="line">    X *px = new X;  </span><br><span class="line">    // do something, exception may occurs  </span><br><span class="line">delete px; // may not go here     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unique_ptr&lt;X&gt; px(new X);</span><br></pre></td></tr></table></figure><h3 id="在函数中返回对象"><a href="#在函数中返回对象" class="headerlink" title="在函数中返回对象"></a>在函数中返回对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;X&gt; foo()  </span><br><span class="line">&#123;  </span><br><span class="line">    unique_ptr&lt;X&gt; px(new X);  </span><br><span class="line">    // do something  </span><br><span class="line">    return px; //移动语义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="放入容器中"><a href="#放入容器中" class="headerlink" title="放入容器中"></a>放入容器中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“1111”&#125;, new string&#123;“2222”&#125;，new string&#123;“3333”&#125;  &#125;;  </span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; test(new string(&quot;11111&quot;));  </span><br><span class="line">v.push_back(std::move(test));//使用移动语法</span><br></pre></td></tr></table></figure><h3 id="支持直接持有数组"><a href="#支持直接持有数组" class="headerlink" title="支持直接持有数组"></a>支持直接持有数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],</span><br><span class="line">    [](int* p)&#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;);</span><br><span class="line">//或者使用helper</span><br><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常
      
    
    </summary>
    
      <category term="C++" scheme="http://chiqtv.cn/categories/C/"/>
    
    
      <category term="c++" scheme="http://chiqtv.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--Lambda 表达式（对比测试Lambda ，bind，Function Object）</title>
    <link href="http://chiqtv.cn/2014/08/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%AF%B9%E6%AF%94%E6%B5%8B%E8%AF%95Lambda-%EF%BC%8Cbind%EF%BC%8CFunction-Object%EF%BC%89/"/>
    <id>http://chiqtv.cn/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/</id>
    <published>2014-08-09T10:02:37.000Z</published>
    <updated>2019-04-09T10:07:37.697Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。</p><p>还是直接看对比栗子吧，抄袭的是msdn的官网</p><p>该示例使用 for_each 函数调用中嵌入的 lambda 向控制台打印 vector 对象中的每个元素是偶数还是奇数。</p></blockquote><h3 id="使用lambda"><a href="#使用lambda" class="headerlink" title="使用lambda"></a>使用lambda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">   // Create a vector object that contains 10 elements.</span><br><span class="line">   vector&lt;int&gt; v;</span><br><span class="line">   for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">      v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Count the number of even numbers in the vector by </span><br><span class="line">   // using the for_each function and a lambda.</span><br><span class="line">   int evenCount = 0;</span><br><span class="line">   for_each(v.begin(), v.end(),[&amp;evenCount] (int n) &#123;</span><br><span class="line">      cout &lt;&lt; n;</span><br><span class="line">      if (n % 2 == 0) &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">         ++evenCount;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // Print the count of even numbers to the console.</span><br><span class="line">   cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Function-Object"><a href="#使用Function-Object" class="headerlink" title="使用Function Object"></a>使用Function Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(int&amp; evenCount) </span><br><span class="line">        : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">            ++m_evenCount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line"></span><br><span class="line">    int&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    // Create a vector object that contains 10 elements.</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Count the number of even numbers in the vector by </span><br><span class="line">    // using the for_each function and a function object.</span><br><span class="line">    int evenCount = 0;</span><br><span class="line">    for_each(v.begin(), v.end(), FunctorClass(evenCount));</span><br><span class="line"></span><br><span class="line">    // Print the count of even numbers to the console.</span><br><span class="line">    cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>正如微软文档所言，这两种在效率上并没有实质性的差距，我自己也测试了，不管在debug模式下还是release模式下，果然没有差距。</p><p>无意中我在晚上发现了bind和Lambda对比测试，前三种方式是网上的，后面两种是我自己加的，结果绝对让我蛋碎了一地。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdint&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(uint64_t&amp; evenCount)</span><br><span class="line">    : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">         m_evenCount += n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line">    </span><br><span class="line">    uint64_t&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef std::chrono::high_resolution_clock clock;</span><br><span class="line">    typedef clock::time_point                  time_point;</span><br><span class="line">    typedef clock::duration                    duration;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    timer()</span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void reset()</span><br><span class="line">    &#123;</span><br><span class="line">        _starttime = clock::now();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    duration elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">        return clock::now() - _starttime;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    time_point _starttime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool test_timer()</span><br><span class="line">&#123;</span><br><span class="line">    using std::chrono::milliseconds;</span><br><span class="line">    typedef timer::duration duration;</span><br><span class="line">    </span><br><span class="line">    const milliseconds sleep_time(500);</span><br><span class="line">    </span><br><span class="line">    timer t;</span><br><span class="line">    std::this_thread::sleep_for(sleep_time);</span><br><span class="line">    duration recorded = t.elapsed();</span><br><span class="line">    </span><br><span class="line">    // make sure the clock and this_thread::sleep_for is precise within one millisecond (or at least in agreement as to</span><br><span class="line">    // how inaccurate they are)</span><br><span class="line">    return (recorded - milliseconds(1) &lt; sleep_time)</span><br><span class="line">    &amp;&amp; (recorded + milliseconds(1) &gt; sleep_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void volatile_write(const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    volatile T* p = new T;</span><br><span class="line">    *p = x;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void run_test(const std::string&amp; name, Function func)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line">    timer t;</span><br><span class="line">    volatile_write(func());</span><br><span class="line">    timer::duration duration = t.elapsed();</span><br><span class="line">    std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; duration.count() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void do_test_loop(Function func, const uint64_t upper_limit = 100000000ULL)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t i;</span><br><span class="line">    for (i = 0; i &lt; upper_limit; ++i)</span><br><span class="line">        func(i);</span><br><span class="line">    if(i == upper_limit)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = [&amp;x] (uint64_t i) &#123; x += i;</span><br><span class="line"> &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_accumulate_bind_function(uint64_t&amp; x, uint64_t i)</span><br><span class="line">&#123;</span><br><span class="line">    x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_class_function()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line"></span><br><span class="line">    do_test_loop(FunctorClass(x));</span><br><span class="line">   // for_each(v.begin(), v.end(), FunctorClass(x));</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind_auto()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">uint64_t test_accumulate_boost_bind()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    </span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = boost::bind(&amp;test_accumulate_bind_function, boost::ref(x), _1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_boost_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!test_timer())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed timer test.&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run_test(&quot;Accumulate (lambda)            &quot;, &amp;test_accumulate_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (bind)              &quot;, &amp;test_accumulate_bind);</span><br><span class="line">    run_test(&quot;Accumulate (bound lambda)      &quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (Function Object)    &quot;, &amp;test_accumulate_class_function);</span><br><span class="line">    run_test(&quot;Accumulate (bind auto)    &quot;, &amp;test_accumulate_bind_auto);</span><br><span class="line">#if USE_BOOST</span><br><span class="line">    run_test(&quot;Accumulate (boost bind)        &quot;, &amp;test_accumulate_boost_bind);</span><br><span class="line">    run_test(&quot;Accumulate (boost bound lambda)&quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="debug模式："><a href="#debug模式：" class="headerlink" title="debug模式："></a>debug模式：</h3><p><strong>Accumulate (lambda)            100000000  422885105</strong></p><p><strong>Accumulate (bind)              100000000   4346676523</strong></p><p><strong>Accumulate (bound lambda)      100000000 1707092933</strong></p><p><strong>Accumulate (class function)    100000000   494674507</strong></p><p><strong>Accumulate (bind auto)         100000000 3381097610</strong></p><h3 id="Release模式"><a href="#Release模式" class="headerlink" title="Release模式"></a>Release模式</h3><p><strong>Accumulate (lambda)            100000000  17978</strong></p><p><strong>Accumulate (bind)              100000000   607188485</strong></p><p><strong>Accumulate (bound lambda)      100000000 520421500</strong></p><p><strong>Accumulate (Function Object)    100000000  1925</strong></p><p><strong>Accumulate (bind auto)         100000000 1726</strong></p><blockquote><p>编译器：APPLE LLVM5.1</p><p>c++就是这样让人蛋疼，随便一个东西，初学者都可以写5中写法，那大神下，至少可以写10种以上，效率上的差距也是大的惊人，我还是那句话c++应该做减法了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。&lt;/p&gt;
&lt;p&gt;还是直接看对比栗子吧，抄袭的是msdn的官网&lt;/p&gt;
&lt;p&gt;该示例使用 for_each 函数调用中嵌入的 lambda 向控制
      
    
    </summary>
    
      <category term="C++" scheme="http://chiqtv.cn/categories/C/"/>
    
    
      <category term="c++" scheme="http://chiqtv.cn/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>c++ 11学习笔记--右值引用和移动构造语义</title>
    <link href="http://chiqtv.cn/2014/06/09/c-11%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%92%8C%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E8%AF%AD%E4%B9%89/"/>
    <id>http://chiqtv.cn/2014/06/09/c-11学习笔记-右值引用和移动构造语义/</id>
    <published>2014-06-09T09:42:12.000Z</published>
    <updated>2019-04-09T10:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"><a href="#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。" class="headerlink" title="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"></a>今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const char* rhs)            // 普通赋值构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const myStr&amp; rhs)             // 拷贝构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs.str_);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str copy constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(myStr&amp;&amp; rhs)</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(rhs);</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str move constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~myStr()                          // 析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        if (!str_) return;</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str destructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">        delete [] str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const myStr&amp; operator=(myStr rhs)   // 赋值操作符重载</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.swap(*this);            // 使用copy-and-swap惯用法获得数据</span><br><span class="line">        return (*this);             // 避免重复撰写operator=</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void swap(myStr&amp; rhs)             // 交换算法</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(str_, rhs.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operator char*(void) const</span><br><span class="line">    &#123;</span><br><span class="line">        return str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr&amp; operator+=(const char* rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs) strcat(str_, rhs);</span><br><span class="line">        return (*this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行下面的代码"><a href="#执行下面的代码" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myStr ss(&quot;000&quot;);</span><br><span class="line">    myStr s1(&quot;11111&quot;), s2(&quot;22222&quot;), s3(&quot;3333333&quot;), s4(&quot;4444444&quot;);</span><br><span class="line">    cout &lt;&lt; std::endl;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line">    </span><br><span class="line">    const long long max = 30000000;</span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i&lt;max; i++) &#123;</span><br><span class="line">        ss = s1 + s2 + s3 + s4;</span><br><span class="line">    &#125;</span><br><span class="line">     time(&amp;timestamp2);</span><br><span class="line">    </span><br><span class="line"> timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure><h3 id="下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。"><a href="#下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。" class="headerlink" title="下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。"></a>下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="再找一个例子"><a href="#再找一个例子" class="headerlink" title="再找一个例子"></a>再找一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class MemoryBlock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    // 构造器（初始化资源）</span><br><span class="line">    explicit MemoryBlock(size_t length)</span><br><span class="line">    : _length(length)</span><br><span class="line">    , _data(new int[length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 析构器（释放资源）</span><br><span class="line">    ~MemoryBlock()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_data != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _data;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock destructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝构造器（实现拷贝语义：拷贝that）</span><br><span class="line">    MemoryBlock(const MemoryBlock&amp; that)</span><br><span class="line">    // 拷贝that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(new int[that._length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        std::cout &lt;&lt; &quot;copy constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝赋值运算符（实现拷贝语义：释放this ＋ 拷贝that）</span><br><span class="line">    MemoryBlock&amp; operator=(const MemoryBlock&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 拷贝that对象所拥有的资源</span><br><span class="line">            _length = that._length;</span><br><span class="line">            _data = new int[_length];</span><br><span class="line">            std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动构造器（实现移动语义：移动that）</span><br><span class="line">    MemoryBlock(MemoryBlock&amp;&amp; that)</span><br><span class="line">    // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(that._data)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">        that._data = nullptr;</span><br><span class="line">        that._length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动赋值运算符（实现移动语义：释放this ＋ 移动that）</span><br><span class="line">    MemoryBlock&amp; operator=(MemoryBlock&amp;&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">            _data = that._data;</span><br><span class="line">            _length = that._length;</span><br><span class="line">            </span><br><span class="line">            // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">            that._data = nullptr;</span><br><span class="line">            that._length = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _length; // 资源的长度</span><br><span class="line">    int* _data; // 指向资源的指针，代表资源本身</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MemoryBlock f() &#123; return MemoryBlock(50); &#125;</span><br></pre></td></tr></table></figure><h3 id="执行下面的代码-1"><a href="#执行下面的代码-1" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const long long max = 100000;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line"></span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line">    for (long long i = 0; i&lt;max; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryBlock a = MemoryBlock(50);</span><br><span class="line"></span><br><span class="line">        MemoryBlock c = std::move(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time(&amp;timestamp2);</span><br><span class="line">timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure><blockquote><p>如果把MemoryBlock c = std::move(a)换成MemoryBlock c = a;</p><p>性能上大概也有30%的差距。</p><p>这就是右值引用和移动构造语义带来的好处，我理解就是以前只能引用左值，而右值是不能引用的，新语法的加入实现了右值的引用，减少了零时对象的产生销毁，但是也带来了更多怪异的语法，明显增加了c++的学习成本，如果语法设计角度，像oc一样增加类似引用计数器来管理对象，会不会更加优雅一下，至少让上层的码农不会那么累，其实通智能指针也能达到同样的效果。</p><p>这么多年了c++都在做加法，让学习，使用成本太高了，标准委员为的大爷些什么时候考虑一下做点减法呢，不要让c++那么学院派或者满地都是陷阱，也不要让实现一种技术有10种方法，但是有5种都是陷阱。靠！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。&quot;&gt;&lt;a href=&quot;#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="C++" scheme="http://chiqtv.cn/categories/C/"/>
    
    
      <category term="c++" scheme="http://chiqtv.cn/tags/c/"/>
    
  </entry>
  
</feed>
