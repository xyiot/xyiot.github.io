<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="协程,">





  <link rel="alternate" href="/atom.xml" title="三余无梦生" type="application/atom+xml">






<meta name="description" content="gpm源码阅读基本数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]// 如果从传统内存布局的角度来讲">
<meta name="keywords" content="协程">
<meta property="og:type" content="article">
<meta property="og:title" content="gpm源码阅读">
<meta property="og:url" content="http://chiqtv.cn/2019/08/16/gpm源码阅读/index.html">
<meta property="og:site_name" content="三余无梦生">
<meta property="og:description" content="gpm源码阅读基本数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]// 如果从传统内存布局的角度来讲">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-09-05T14:54:28.108Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="gpm源码阅读">
<meta name="twitter:description" content="gpm源码阅读基本数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]// 如果从传统内存布局的角度来讲">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chiqtv.cn/2019/08/16/gpm源码阅读/">





  <title>gpm源码阅读 | 三余无梦生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三余无梦生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chiqtv.cn/2019/08/16/gpm源码阅读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">gpm源码阅读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T08:34:05+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="gpm源码阅读"><a href="#gpm源码阅读" class="headerlink" title="gpm源码阅读"></a>gpm源码阅读</h1><h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack 描述的是 Go 的执行栈，下界和上界分别为 [lo, hi]</span></span><br><span class="line"><span class="comment">// 如果从传统内存布局的角度来讲，Go 的栈实际上是分配在 C 语言中的堆区的</span></span><br><span class="line"><span class="comment">// 所以才能比 ulimit -s 的 stack size 还要大(1GB)</span></span><br><span class="line"><span class="keyword">type</span> stack <span class="keyword">struct</span> &#123;</span><br><span class="line">    lo <span class="keyword">uintptr</span></span><br><span class="line">    hi <span class="keyword">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// g 的运行现场</span></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="keyword">uintptr</span>    <span class="comment">// sp 寄存器</span></span><br><span class="line">    pc   <span class="keyword">uintptr</span>    <span class="comment">// pc 寄存器</span></span><br><span class="line">    g    guintptr   <span class="comment">// g 指针</span></span><br><span class="line">    ctxt unsafe.Pointer <span class="comment">// 这个似乎是用来辅助 gc 的</span></span><br><span class="line">    ret  sys.Uintreg</span><br><span class="line">    lr   <span class="keyword">uintptr</span>    <span class="comment">// 这是在 arm 上用的寄存器，不用关心</span></span><br><span class="line">    bp   <span class="keyword">uintptr</span>    <span class="comment">// 开启 GOEXPERIMENT=framepointer，才会有这个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 简单数据结构，lo 和 hi 成员描述了栈的下界和上界内存地址</span></span><br><span class="line">    stack       stack</span><br><span class="line">    <span class="comment">// 在函数的栈增长 prologue 中用 sp 寄存器和 stackguard0 来做比较</span></span><br><span class="line">    <span class="comment">// 如果 sp 比 stackguard0 小(因为栈向低地址方向增长)，那么就触发栈拷贝和调度</span></span><br><span class="line">    <span class="comment">// 正常情况下 stackguard0 = stack.lo + StackGuard</span></span><br><span class="line">    <span class="comment">// 不过 stackguard0 在需要进行调度时，会被修改为 StackPreempt</span></span><br><span class="line">    <span class="comment">// 以触发抢占s</span></span><br><span class="line">    stackguard0 <span class="keyword">uintptr</span></span><br><span class="line">    <span class="comment">// stackguard1 是在 C 栈增长 prologue 作对比的对象</span></span><br><span class="line">    <span class="comment">// 在 g0 和 gsignal 栈上，其值为 stack.lo+StackGuard</span></span><br><span class="line">    <span class="comment">// 在其它的栈上这个值是 ~0(按 0 取反)以触发 morestack 调用(并 crash)</span></span><br><span class="line">    stackguard1 <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    _panic         *_panic</span><br><span class="line">    _defer         *_defer</span><br><span class="line">    m              *m             <span class="comment">// 当前与 g 绑定的 m</span></span><br><span class="line">    sched          gobuf          <span class="comment">// goroutine 的现场</span></span><br><span class="line">    syscallsp      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallsp = sched.sp to use during gc</span></span><br><span class="line">    syscallpc      <span class="keyword">uintptr</span>        <span class="comment">// if status==Gsyscall, syscallpc = sched.pc to use during gc</span></span><br><span class="line">    stktopsp       <span class="keyword">uintptr</span>        <span class="comment">// expected sp at top of stack, to check in traceback</span></span><br><span class="line">    param          unsafe.Pointer <span class="comment">// wakeup 时的传入参数</span></span><br><span class="line">    atomicstatus   <span class="keyword">uint32</span></span><br><span class="line">    stackLock      <span class="keyword">uint32</span> <span class="comment">// sigprof/scang lock; <span class="doctag">TODO:</span> fold in to atomicstatus</span></span><br><span class="line">    goid           <span class="keyword">int64</span>  <span class="comment">// goroutine id</span></span><br><span class="line">    waitsince      <span class="keyword">int64</span>  <span class="comment">// g 被阻塞之后的近似时间</span></span><br><span class="line">    waitreason     <span class="keyword">string</span> <span class="comment">// if status==Gwaiting</span></span><br><span class="line">    schedlink      guintptr</span><br><span class="line">    preempt        <span class="keyword">bool</span>     <span class="comment">// 抢占标记，这个为 true 时，stackguard0 是等于 stackpreempt 的</span></span><br><span class="line">    throwsplit     <span class="keyword">bool</span>     <span class="comment">// must not split stack</span></span><br><span class="line">    raceignore     <span class="keyword">int8</span>     <span class="comment">// ignore race detection events</span></span><br><span class="line">    sysblocktraced <span class="keyword">bool</span>     <span class="comment">// StartTrace has emitted EvGoInSyscall about this goroutine</span></span><br><span class="line">    sysexitticks   <span class="keyword">int64</span>    <span class="comment">// syscall 返回之后的 cputicks，用来做 tracing</span></span><br><span class="line">    traceseq       <span class="keyword">uint64</span>   <span class="comment">// trace event sequencer</span></span><br><span class="line">    tracelastp     puintptr <span class="comment">// last P emitted an event for this goroutine</span></span><br><span class="line">    lockedm        muintptr <span class="comment">// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上</span></span><br><span class="line">    sig            <span class="keyword">uint32</span></span><br><span class="line">    writebuf       []<span class="keyword">byte</span></span><br><span class="line">    sigcode0       <span class="keyword">uintptr</span></span><br><span class="line">    sigcode1       <span class="keyword">uintptr</span></span><br><span class="line">    sigpc          <span class="keyword">uintptr</span></span><br><span class="line">    gopc           <span class="keyword">uintptr</span> <span class="comment">// 创建该 goroutine 的语句的指令地址</span></span><br><span class="line">    startpc        <span class="keyword">uintptr</span> <span class="comment">// goroutine 函数的指令地址</span></span><br><span class="line">    racectx        <span class="keyword">uintptr</span></span><br><span class="line">    waiting        *sudog         <span class="comment">// sudog structures this g is waiting on (that have a valid elem ptr); in lock order</span></span><br><span class="line">    cgoCtxt        []<span class="keyword">uintptr</span>      <span class="comment">// cgo traceback context</span></span><br><span class="line">    labels         unsafe.Pointer <span class="comment">// profiler labels</span></span><br><span class="line">    timer          *timer         <span class="comment">// time.Sleep 缓存的定时器</span></span><br><span class="line">    selectDone     <span class="keyword">uint32</span>         <span class="comment">// 该 g 是否正在参与 select，是否已经有人从 select 中胜出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 g 遇到阻塞，或需要等待的场景时，会被打包成 sudog 这样一个结构。一个 g 可能被打包为多个 sudog 分别挂在不同的等待队列上:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sudog 代表在等待列表里的 g，比如向 channel 发送/接收内容时</span></span><br><span class="line"><span class="comment">// 之所以需要 sudog 是因为 g 和同步对象之间的关系是多对多的</span></span><br><span class="line"><span class="comment">// 一个 g 可能会在多个等待队列中，所以一个 g 可能被打包为多个 sudog</span></span><br><span class="line"><span class="comment">// 多个 g 也可以等待在同一个同步对象上</span></span><br><span class="line"><span class="comment">// 因此对于一个同步对象就会有很多 sudog 了</span></span><br><span class="line"><span class="comment">// sudog 是从一个特殊的池中进行分配的。用 acquireSudog 和 releaseSudog 来分配和释放 sudog</span></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后的这些字段都是被该 g 所挂在的 channel 中的 hchan.lock 来保护的</span></span><br><span class="line">    <span class="comment">// shrinkstack depends on</span></span><br><span class="line">    <span class="comment">// this for sudogs involved in channel ops.</span></span><br><span class="line">    g *g</span><br><span class="line"></span><br><span class="line">    <span class="comment">// isSelect 表示一个 g 是否正在参与 select 操作</span></span><br><span class="line">    <span class="comment">// 所以 g.selectDone 必须用 CAS 来操作，以胜出唤醒的竞争</span></span><br><span class="line">    isSelect <span class="keyword">bool</span></span><br><span class="line">    next     *sudog</span><br><span class="line">    prev     *sudog</span><br><span class="line">    elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面这些字段则永远都不会被并发访问</span></span><br><span class="line">    <span class="comment">// 对于 channel 来说，waitlink 只会被 g 访问</span></span><br><span class="line">    <span class="comment">// 对于信号量来说，所有的字段，包括上面的那些字段都只在持有 semaRoot 锁时才可以访问</span></span><br><span class="line">    acquiretime <span class="keyword">int64</span></span><br><span class="line">    releasetime <span class="keyword">int64</span></span><br><span class="line">    ticket      <span class="keyword">uint32</span></span><br><span class="line">    parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">    waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">    waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">    c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程在 runtime 中的结构，对应一个 pthread，pthread 也会对应唯一的内核线程(task_struct):</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// 用来执行调度指令的 goroutine</span></span><br><span class="line">    morebuf gobuf  <span class="comment">// gobuf arg to morestack</span></span><br><span class="line">    divmod  <span class="keyword">uint32</span> <span class="comment">// div/mod denominator for arm - known to liblink</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fields not known to debuggers.</span></span><br><span class="line">    procid        <span class="keyword">uint64</span>       <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    gsignal       *g           <span class="comment">// signal-handling g</span></span><br><span class="line">    goSigStack    gsignalStack <span class="comment">// Go-allocated signal handling stack</span></span><br><span class="line">    sigmask       sigset       <span class="comment">// storage for saved signal mask</span></span><br><span class="line">    tls           [<span class="number">6</span>]<span class="keyword">uintptr</span>   <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    mstartfn      <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">curg</span>          *<span class="title">g</span>       // 当前运行的用户 <span class="title">goroutine</span></span></span><br><span class="line"><span class="function">    <span class="title">caughtsig</span>     <span class="title">guintptr</span> // <span class="title">goroutine</span> <span class="title">running</span> <span class="title">during</span> <span class="title">fatal</span> <span class="title">signal</span></span></span><br><span class="line"><span class="function">    <span class="title">p</span>             <span class="title">puintptr</span> // <span class="title">attached</span> <span class="title">p</span> <span class="title">for</span> <span class="title">executing</span> <span class="title">go</span> <span class="title">code</span> <span class="params">(<span class="literal">nil</span> <span class="keyword">if</span> not executing <span class="keyword">go</span> code)</span></span></span><br><span class="line"><span class="function">    <span class="title">nextp</span>         <span class="title">puintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">id</span>            <span class="title">int64</span></span></span><br><span class="line"><span class="function">    <span class="title">mallocing</span>     <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">throwing</span>      <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">preemptoff</span>    <span class="title">string</span> // 该字段不等于空字符串的话，要保持 <span class="title">curg</span> 始终在这个 <span class="title">m</span> 上运行</span></span><br><span class="line"><span class="function">    <span class="title">locks</span>         <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">softfloat</span>     <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">dying</span>         <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">profilehz</span>     <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">helpgc</span>        <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">spinning</span>      <span class="title">bool</span> // <span class="title">m</span> 失业了，正在积极寻找工作~</span></span><br><span class="line"><span class="function">    <span class="title">blocked</span>       <span class="title">bool</span> // <span class="title">m</span> 正阻塞在 <span class="title">note</span> 上</span></span><br><span class="line"><span class="function">    <span class="title">inwb</span>          <span class="title">bool</span> // <span class="title">m</span> 正在执行 <span class="title">write</span> <span class="title">barrier</span></span></span><br><span class="line"><span class="function">    <span class="title">newSigstack</span>   <span class="title">bool</span> // <span class="title">minit</span> <span class="title">on</span> <span class="title">C</span> <span class="title">thread</span> <span class="title">called</span> <span class="title">sigaltstack</span></span></span><br><span class="line"><span class="function">    <span class="title">printlock</span>     <span class="title">int8</span></span></span><br><span class="line"><span class="function">    <span class="title">incgo</span>         <span class="title">bool</span>   // <span class="title">m</span> 正在执行 <span class="title">cgo</span> <span class="title">call</span></span></span><br><span class="line"><span class="function">    <span class="title">freeWait</span>      <span class="title">uint32</span> // <span class="title">if</span> == 0, <span class="title">safe</span> <span class="title">to</span> <span class="title">free</span> <span class="title">g0</span> <span class="title">and</span> <span class="title">delete</span> <span class="title">m</span> <span class="params">(atomic)</span></span></span><br><span class="line"><span class="function">    <span class="title">fastrand</span>      [2]<span class="title">uint32</span></span></span><br><span class="line"><span class="function">    <span class="title">needextram</span>    <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">traceback</span>     <span class="title">uint8</span></span></span><br><span class="line"><span class="function">    <span class="title">ncgocall</span>      <span class="title">uint64</span>      // <span class="title">cgo</span> 调用总计数</span></span><br><span class="line"><span class="function">    <span class="title">ncgo</span>          <span class="title">int32</span>       // 当前正在执行的 <span class="title">cgo</span> 订单计数</span></span><br><span class="line"><span class="function">    <span class="title">cgoCallersUse</span> <span class="title">uint32</span>      // <span class="title">if</span> <span class="title">non</span>-<span class="title">zero</span>, <span class="title">cgoCallers</span> <span class="title">in</span> <span class="title">use</span> <span class="title">temporarily</span></span></span><br><span class="line"><span class="function">    <span class="title">cgoCallers</span>    *<span class="title">cgoCallers</span> // <span class="title">cgo</span> <span class="title">traceback</span> <span class="title">if</span> <span class="title">crashing</span> <span class="title">in</span> <span class="title">cgo</span> <span class="title">call</span></span></span><br><span class="line"><span class="function">    <span class="title">park</span>          <span class="title">note</span></span></span><br><span class="line"><span class="function">    <span class="title">alllink</span>       *<span class="title">m</span> // <span class="title">on</span> <span class="title">allm</span></span></span><br><span class="line"><span class="function">    <span class="title">schedlink</span>     <span class="title">muintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">mcache</span>        *<span class="title">mcache</span></span></span><br><span class="line"><span class="function">    <span class="title">lockedg</span>       <span class="title">guintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">createstack</span>   [32]<span class="title">uintptr</span>    // <span class="title">stack</span> <span class="title">that</span> <span class="title">created</span> <span class="title">this</span> <span class="title">thread</span>.</span></span><br><span class="line"><span class="function">    <span class="title">freglo</span>        [16]<span class="title">uint32</span>     // <span class="title">d</span>[<span class="title">i</span>] <span class="title">lsb</span> <span class="title">and</span> <span class="title">f</span>[<span class="title">i</span>]</span></span><br><span class="line"><span class="function">    <span class="title">freghi</span>        [16]<span class="title">uint32</span>     // <span class="title">d</span>[<span class="title">i</span>] <span class="title">msb</span> <span class="title">and</span> <span class="title">f</span>[<span class="title">i</span>+16]</span></span><br><span class="line"><span class="function">    <span class="title">fflag</span>         <span class="title">uint32</span>         // <span class="title">floating</span> <span class="title">point</span> <span class="title">compare</span> <span class="title">flags</span></span></span><br><span class="line"><span class="function">    <span class="title">lockedExt</span>     <span class="title">uint32</span>         // <span class="title">tracking</span> <span class="title">for</span> <span class="title">external</span> <span class="title">LockOSThread</span></span></span><br><span class="line"><span class="function">    <span class="title">lockedInt</span>     <span class="title">uint32</span>         // <span class="title">tracking</span> <span class="title">for</span> <span class="title">internal</span> <span class="title">lockOSThread</span></span></span><br><span class="line"><span class="function">    <span class="title">nextwaitm</span>     <span class="title">muintptr</span>       // 正在等待锁的下一个 <span class="title">m</span></span></span><br><span class="line"><span class="function">    <span class="title">waitunlockf</span>   <span class="title">unsafe</span>.<span class="title">Pointer</span> // <span class="title">todo</span> <span class="title">go</span> <span class="title">func</span><span class="params">(*g, unsafe.pointer)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">waitlock</span>      <span class="title">unsafe</span>.<span class="title">Pointer</span></span></span><br><span class="line"><span class="function">    <span class="title">waittraceev</span>   <span class="title">byte</span></span></span><br><span class="line"><span class="function">    <span class="title">waittraceskip</span> <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">startingtrace</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function">    <span class="title">syscalltick</span>   <span class="title">uint32</span></span></span><br><span class="line"><span class="function">    <span class="title">thread</span>        <span class="title">uintptr</span> // <span class="title">thread</span> <span class="title">handle</span></span></span><br><span class="line"><span class="function">    <span class="title">freelink</span>      *<span class="title">m</span>      // <span class="title">on</span> <span class="title">sched</span>.<span class="title">freem</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    // <span class="title">these</span> <span class="title">are</span> <span class="title">here</span> <span class="title">because</span> <span class="title">they</span> <span class="title">are</span> <span class="title">too</span> <span class="title">large</span> <span class="title">to</span> <span class="title">be</span> <span class="title">on</span> <span class="title">the</span> <span class="title">stack</span></span></span><br><span class="line"><span class="function">    // <span class="title">of</span> <span class="title">low</span>-<span class="title">level</span> <span class="title">NOSPLIT</span> <span class="title">functions</span>.</span></span><br><span class="line"><span class="function">    <span class="title">libcall</span>   <span class="title">libcall</span></span></span><br><span class="line"><span class="function">    <span class="title">libcallpc</span> <span class="title">uintptr</span> // <span class="title">for</span> <span class="title">cpu</span> <span class="title">profiler</span></span></span><br><span class="line"><span class="function">    <span class="title">libcallsp</span> <span class="title">uintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">libcallg</span>  <span class="title">guintptr</span></span></span><br><span class="line"><span class="function">    <span class="title">syscall</span>   <span class="title">libcall</span> // 存储 <span class="title">windows</span> 平台的 <span class="title">syscall</span> 参数</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">mOS</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<p>抽象数据结构，可以认为是 processor 的抽象，代表了任务执行时的上下文，m 必须获得 p 才能执行:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    id          <span class="keyword">int32</span></span><br><span class="line">    status      <span class="keyword">uint32</span> <span class="comment">// one of pidle/prunning/...</span></span><br><span class="line">    link        puintptr</span><br><span class="line">    schedtick   <span class="keyword">uint32</span>     <span class="comment">// 每次调用 schedule 时会加一</span></span><br><span class="line">    syscalltick <span class="keyword">uint32</span>     <span class="comment">// 每次系统调用时加一</span></span><br><span class="line">    sysmontick  sysmontick <span class="comment">// 上次 sysmon 观察到的 tick 时间</span></span><br><span class="line">    m           muintptr   <span class="comment">// 和相关联的 m 的反向指针，如果 p 是 idle 的话，那这个指针是 nil</span></span><br><span class="line">    mcache      *mcache</span><br><span class="line">    racectx     <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    deferpool    [<span class="number">5</span>][]*_defer <span class="comment">// pool of available defer structs of different sizes (see panic.go)</span></span><br><span class="line">    deferpoolbuf [<span class="number">5</span>][<span class="number">32</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.</span></span><br><span class="line">    goidcache    <span class="keyword">uint64</span></span><br><span class="line">    goidcacheend <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runnable 状态的 goroutine。访问时是不加锁的</span></span><br><span class="line">    runqhead <span class="keyword">uint32</span></span><br><span class="line">    runqtail <span class="keyword">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    <span class="comment">// runnext 非空时，代表的是一个 runnable 状态的 G，</span></span><br><span class="line">    <span class="comment">// 这个 G 是被 当前 G 修改为 ready 状态的，</span></span><br><span class="line">    <span class="comment">// 并且相比在 runq 中的 G 有更高的优先级</span></span><br><span class="line">    <span class="comment">// 如果当前 G 的还有剩余的可用时间，那么就应该运行这个 G</span></span><br><span class="line">    <span class="comment">// 运行之后，该 G 会继承当前 G 的剩余时间</span></span><br><span class="line">    <span class="comment">// If a set of goroutines is locked in a</span></span><br><span class="line">    <span class="comment">// communicate-and-wait pattern, this schedules that set as a</span></span><br><span class="line">    <span class="comment">// unit and eliminates the (potentially large) scheduling</span></span><br><span class="line">    <span class="comment">// latency that otherwise arises from adding the ready'd</span></span><br><span class="line">    <span class="comment">// goroutines to the end of the run queue.</span></span><br><span class="line">    runnext guintptr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G's (status == Gdead)</span></span><br><span class="line">    gfree    *g</span><br><span class="line">    gfreecnt <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    sudogcache []*sudog</span><br><span class="line">    sudogbuf   [<span class="number">128</span>]*sudog</span><br><span class="line"></span><br><span class="line">    tracebuf traceBufPtr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traceSweep indicates the sweep events should be traced.</span></span><br><span class="line">    <span class="comment">// This is used to defer the sweep start event until a span</span></span><br><span class="line">    <span class="comment">// has actually been swept.</span></span><br><span class="line">    traceSweep <span class="keyword">bool</span></span><br><span class="line">    <span class="comment">// traceSwept and traceReclaimed track the number of bytes</span></span><br><span class="line">    <span class="comment">// swept and reclaimed by sweeping in the current sweep loop.</span></span><br><span class="line">    traceSwept, traceReclaimed <span class="keyword">uintptr</span></span><br><span class="line"></span><br><span class="line">    palloc persistentAlloc <span class="comment">// per-P to avoid mutex</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Per-P GC state</span></span><br><span class="line">    gcAssistTime         <span class="keyword">int64</span> <span class="comment">// Nanoseconds in assistAlloc</span></span><br><span class="line">    gcFractionalMarkTime <span class="keyword">int64</span> <span class="comment">// Nanoseconds in fractional mark worker</span></span><br><span class="line">    gcBgMarkWorker       guintptr</span><br><span class="line">    gcMarkWorkerMode     gcMarkWorkerMode</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前标记 worker 的开始时间，单位纳秒</span></span><br><span class="line">    gcMarkWorkerStartTime <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// gcw is this P's GC work buffer cache. The work buffer is</span></span><br><span class="line">    <span class="comment">// filled by write barriers, drained by mutator assists, and</span></span><br><span class="line">    <span class="comment">// disposed on certain GC state transitions.</span></span><br><span class="line">    gcw gcWork</span><br><span class="line"></span><br><span class="line">    <span class="comment">// wbBuf is this P's GC write barrier buffer.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Consider caching this in the running G.</span></span><br><span class="line">    wbBuf wbBuf</span><br><span class="line"></span><br><span class="line">    runSafePointFn <span class="keyword">uint32</span> <span class="comment">// if 1, run sched.safePointFn at next safe point</span></span><br><span class="line"></span><br><span class="line">    pad [sys.CacheLineSize]<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局调度器，全局只有一个 schedt 类型的实例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 下面两个变量需以原子访问访问。保持在 struct 顶部，以使其在 32 位系统上可以对齐</span></span><br><span class="line">    goidgen  <span class="keyword">uint64</span></span><br><span class="line">    lastpoll <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">    lock mutex</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当修改 nmidle，nmidlelocked，nmsys，nmfreed 这些数值时</span></span><br><span class="line">    <span class="comment">// 需要记得调用 checkdead</span></span><br><span class="line"></span><br><span class="line">    midle        muintptr <span class="comment">// idle m's waiting for work</span></span><br><span class="line">    nmidle       <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的空闲 m 计数</span></span><br><span class="line">    nmidlelocked <span class="keyword">int32</span>    <span class="comment">// 当前等待工作的被 lock 的 m 计数</span></span><br><span class="line">    mnext        <span class="keyword">int64</span>    <span class="comment">// 当前预缴创建的 m 数，并且该值会作为下一个创建的 m 的 ID</span></span><br><span class="line">    maxmcount    <span class="keyword">int32</span>    <span class="comment">// 允许创建的最大的 m 数量</span></span><br><span class="line">    nmsys        <span class="keyword">int32</span>    <span class="comment">// number of system m's not counted for deadlock</span></span><br><span class="line">    nmfreed      <span class="keyword">int64</span>    <span class="comment">// cumulative number of freed m's</span></span><br><span class="line"></span><br><span class="line">    ngsys <span class="keyword">uint32</span> <span class="comment">// number of system goroutines; updated atomically</span></span><br><span class="line"></span><br><span class="line">    pidle      puintptr <span class="comment">// 空闲 p's</span></span><br><span class="line">    npidle     <span class="keyword">uint32</span></span><br><span class="line">    nmspinning <span class="keyword">uint32</span> <span class="comment">// See "Worker thread parking/unparking" comment in proc.go.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局的可运行 g 队列</span></span><br><span class="line">    runqhead guintptr</span><br><span class="line">    runqtail guintptr</span><br><span class="line">    runqsize <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// dead G 的全局缓存</span></span><br><span class="line">    gflock       mutex</span><br><span class="line">    gfreeStack   *g</span><br><span class="line">    gfreeNoStack *g</span><br><span class="line">    ngfree       <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// sudog 结构的集中缓存</span></span><br><span class="line">    sudoglock  mutex</span><br><span class="line">    sudogcache *sudog</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同大小的可用的 defer struct 的集中缓存池</span></span><br><span class="line">    deferlock mutex</span><br><span class="line">    deferpool [<span class="number">5</span>]*_defer</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被设置了 m.exited 标记之后的 m，这些 m 正在 freem 这个链表上等待被 free</span></span><br><span class="line">    <span class="comment">// 链表用 m.freelink 字段进行链接</span></span><br><span class="line">    freem *m</span><br><span class="line"></span><br><span class="line">    gcwaiting  <span class="keyword">uint32</span> <span class="comment">// gc is waiting to run</span></span><br><span class="line">    stopwait   <span class="keyword">int32</span></span><br><span class="line">    stopnote   note</span><br><span class="line">    sysmonwait <span class="keyword">uint32</span></span><br><span class="line">    sysmonnote note</span><br><span class="line"></span><br><span class="line">    <span class="comment">// safepointFn should be called on each P at the next GC</span></span><br><span class="line">    <span class="comment">// safepoint if p.runSafePointFn is set.</span></span><br><span class="line">    safePointFn   <span class="function"><span class="keyword">func</span><span class="params">(*p)</span></span></span><br><span class="line"><span class="function">    <span class="title">safePointWait</span> <span class="title">int32</span></span></span><br><span class="line"><span class="function">    <span class="title">safePointNote</span> <span class="title">note</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">profilehz</span> <span class="title">int32</span> // <span class="title">cpu</span> <span class="title">profiling</span> <span class="title">rate</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="title">procresizetime</span> <span class="title">int64</span> // 上次修改 <span class="title">gomaxprocs</span> 的纳秒时间</span></span><br><span class="line"><span class="function">    <span class="title">totaltime</span>      <span class="title">int64</span> // <span class="title">gomaxprocs</span> <span class="title">dt</span> <span class="title">up</span> <span class="title">to</span> <span class="title">procresizetime</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="gpm流程"><a href="#gpm流程" class="headerlink" title="gpm流程"></a>gpm流程</h2><h3 id="p初始化"><a href="#p初始化" class="headerlink" title="p初始化"></a>p初始化</h3><p>程序启动后调用</p>
<pre class="mermaid">graph TD
runtime.newproc --> runtime.newproc1</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//不设置runtime.GOMAXPROCS(n), 默认逻辑cpu数量。</span></span><br><span class="line">procs := ncpu</span><br><span class="line">	<span class="keyword">if</span> n, ok := atoi32(gogetenv(<span class="string">"GOMAXPROCS"</span>)); ok &amp;&amp; n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		procs = n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> procresize(procs) != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"unknown runnable goroutine during bootstrap"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理p</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procresize</span><span class="params">(nprocs <span class="keyword">int32</span>)</span> *<span class="title">p</span></span> &#123;</span><br><span class="line">	old := gomaxprocs</span><br><span class="line">	<span class="keyword">if</span> old &lt; <span class="number">0</span> || nprocs &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">"procresize: invalid arg"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGomaxprocs(nprocs)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// update statistics</span></span><br><span class="line">	now := nanotime()</span><br><span class="line">	<span class="keyword">if</span> sched.procresizetime != <span class="number">0</span> &#123;</span><br><span class="line">		sched.totaltime += <span class="keyword">int64</span>(old) * (now - sched.procresizetime)</span><br><span class="line">	&#125;</span><br><span class="line">	sched.procresizetime = now</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Grow allp if necessary.</span></span><br><span class="line">  <span class="comment">//扩大p的数量，前提是小于nprocs</span></span><br><span class="line">	<span class="keyword">if</span> nprocs &gt; <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) &#123;</span><br><span class="line">		<span class="comment">// Synchronize with retake, which could be running</span></span><br><span class="line">		<span class="comment">// concurrently since it doesn't run on a P.</span></span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		<span class="keyword">if</span> nprocs &lt;= <span class="keyword">int32</span>(<span class="built_in">cap</span>(allp)) &#123;</span><br><span class="line">			allp = allp[:nprocs]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			nallp := <span class="built_in">make</span>([]*p, nprocs)</span><br><span class="line">			<span class="comment">// Copy everything up to allp's cap so we</span></span><br><span class="line">			<span class="comment">// never lose old allocated Ps.</span></span><br><span class="line">			<span class="built_in">copy</span>(nallp, allp[:<span class="built_in">cap</span>(allp)])</span><br><span class="line">			allp = nallp</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化p</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">int32</span>(<span class="number">0</span>); i &lt; nprocs; i++ &#123;</span><br><span class="line">		pp := allp[i]</span><br><span class="line">		<span class="keyword">if</span> pp == <span class="literal">nil</span> &#123;</span><br><span class="line">			pp = <span class="built_in">new</span>(p)</span><br><span class="line">			pp.id = i</span><br><span class="line">			pp.status = _Pgcstop</span><br><span class="line">			pp.sudogcache = pp.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">			<span class="keyword">for</span> i := <span class="keyword">range</span> pp.deferpool &#123;</span><br><span class="line">				pp.deferpool[i] = pp.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			pp.wbBuf.reset()</span><br><span class="line">			atomicstorep(unsafe.Pointer(&amp;allp[i]), unsafe.Pointer(pp))</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pp.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> getg().m.mcache == <span class="literal">nil</span> &#123;</span><br><span class="line">					throw(<span class="string">"missing mcache?"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				pp.mcache = getg().m.mcache <span class="comment">// bootstrap</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pp.mcache = allocmcache()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &amp;&amp; pp.racectx == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> old == <span class="number">0</span> &amp;&amp; i == <span class="number">0</span> &#123;</span><br><span class="line">				pp.racectx = raceprocctx0</span><br><span class="line">				raceprocctx0 = <span class="number">0</span> <span class="comment">// bootstrap</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				pp.racectx = raceproccreate()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// free unused P's</span></span><br><span class="line">	<span class="keyword">for</span> i := nprocs; i &lt; old; i++ &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &amp;&amp; p == getg().m.p.ptr() &#123;</span><br><span class="line">			<span class="comment">// moving to p[0], pretend that we were descheduled</span></span><br><span class="line">			<span class="comment">// and then scheduled again to keep the trace sane.</span></span><br><span class="line">			traceGoSched()</span><br><span class="line">			traceProcStop(p)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// move all runnable goroutines to the global queue</span></span><br><span class="line">		<span class="keyword">for</span> p.runqhead != p.runqtail &#123;</span><br><span class="line">			<span class="comment">// pop from tail of local queue</span></span><br><span class="line">			p.runqtail--</span><br><span class="line">			gp := p.runq[p.runqtail%<span class="keyword">uint32</span>(<span class="built_in">len</span>(p.runq))].ptr()</span><br><span class="line">			<span class="comment">// push onto head of global queue</span></span><br><span class="line">			globrunqputhead(gp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p.runnext != <span class="number">0</span> &#123;</span><br><span class="line">			globrunqputhead(p.runnext.ptr())</span><br><span class="line">			p.runnext = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// if there's a background worker, make it runnable and put</span></span><br><span class="line">		<span class="comment">// it on the global queue so it can clean itself up</span></span><br><span class="line">		<span class="keyword">if</span> gp := p.gcBgMarkWorker.ptr(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			globrunqput(gp)</span><br><span class="line">			<span class="comment">// This assignment doesn't race because the</span></span><br><span class="line">			<span class="comment">// world is stopped.</span></span><br><span class="line">			p.gcBgMarkWorker.set(<span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Flush p's write barrier buffer.</span></span><br><span class="line">		<span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">			wbBufFlush1(p)</span><br><span class="line">			p.gcw.dispose()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> p.sudogbuf &#123;</span><br><span class="line">			p.sudogbuf[i] = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.sudogcache = p.sudogbuf[:<span class="number">0</span>]</span><br><span class="line">		<span class="keyword">for</span> i := <span class="keyword">range</span> p.deferpool &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="keyword">range</span> p.deferpoolbuf[i] &#123;</span><br><span class="line">				p.deferpoolbuf[i][j] = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			p.deferpool[i] = p.deferpoolbuf[i][:<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		freemcache(p.mcache)</span><br><span class="line">		p.mcache = <span class="literal">nil</span></span><br><span class="line">		gfpurge(p)</span><br><span class="line">		traceProcFree(p)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceprocdestroy(p.racectx)</span><br><span class="line">			p.racectx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		p.gcAssistTime = <span class="number">0</span></span><br><span class="line">		p.status = _Pdead</span><br><span class="line">		<span class="comment">// can't free P itself because it can be referenced by an M in syscall</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Trim allp.</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">int32</span>(<span class="built_in">len</span>(allp)) != nprocs &#123;</span><br><span class="line">		lock(&amp;allpLock)</span><br><span class="line">		allp = allp[:nprocs]</span><br><span class="line">		unlock(&amp;allpLock)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &amp;&amp; _g_.m.p.ptr().id &lt; nprocs &#123;</span><br><span class="line">		<span class="comment">// continue to use the current P</span></span><br><span class="line">		_g_.m.p.ptr().status = _Prunning</span><br><span class="line">		_g_.m.p.ptr().mcache.prepareForSweep()</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// release the current P and acquire allp[0]</span></span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			_g_.m.p.ptr().m = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		_g_.m.p = <span class="number">0</span></span><br><span class="line">		_g_.m.mcache = <span class="literal">nil</span></span><br><span class="line">		p := allp[<span class="number">0</span>]</span><br><span class="line">		p.m = <span class="number">0</span></span><br><span class="line">		p.status = _Pidle</span><br><span class="line">		acquirep(p)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoStart()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> runnablePs *p</span><br><span class="line">	<span class="keyword">for</span> i := nprocs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		p := allp[i]</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p.ptr() == p &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">      <span class="comment">// 设置 p 的状态</span></span><br><span class="line">		p.status = _Pidle</span><br><span class="line">		<span class="keyword">if</span> runqempty(p) &#123;</span><br><span class="line">			pidleput(p) <span class="comment">//将这些 p 串成链表放进 sched 全局调度器的 pidle 队列中</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			p.m.set(mget())</span><br><span class="line">			p.link.set(runnablePs)</span><br><span class="line">			runnablePs = p</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stealOrder.reset(<span class="keyword">uint32</span>(nprocs))</span><br><span class="line">	<span class="keyword">var</span> int32p *<span class="keyword">int32</span> = &amp;gomaxprocs <span class="comment">// make compiler check that gomaxprocs is an int32</span></span><br><span class="line">	atomic.Store((*<span class="keyword">uint32</span>)(unsafe.Pointer(int32p)), <span class="keyword">uint32</span>(nprocs))<span class="comment">//把nprocs赋值给gomaxprocs</span></span><br><span class="line">	<span class="keyword">return</span> runnablePs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动调用 runtime.GOMAXPROCS也会procresize重置p</p>
<pre class="mermaid">graph TD
runtime.GOMAXPROCS --> runtime.startTheWorld 
runtime.startTheWorld  --> runtime.startTheWorldWithSema
runtime.startTheWorldWithSema --> procresize</pre>



<h3 id="g-初始化"><a href="#g-初始化" class="headerlink" title="g 初始化"></a>g 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// do.....</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>
<p>实际上会被翻译成 <code>runtime.newproc</code>，初始化g，丢如g的等待队列中</p>
<pre class="mermaid">graph TD
runtime.newproc --> runtime.newproc1</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc</span><span class="params">(siz <span class="keyword">int32</span>, fn *funcval)</span></span> &#123;</span><br><span class="line">	argp := add(unsafe.Pointer(&amp;fn), sys.PtrSize)  <span class="comment">//获取参数起始地址</span></span><br><span class="line">	gp := getg()  <span class="comment">//获取当前g指针</span></span><br><span class="line">	pc := getcallerpc()</span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newproc1(fn, (*<span class="keyword">uint8</span>)(argp), siz, gp, pc)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getcallerpc<span class="comment">//获取f执行完的返回地址</span></span><br><span class="line">getcallersp <span class="comment">//获取f栈顶的指针，libco，sp是栈低的指针</span></span><br><span class="line"><span class="comment">//	func f(arg1, arg2, arg3 int) &#123;</span></span><br><span class="line"><span class="comment">//		pc := getcallerpc()</span></span><br><span class="line"><span class="comment">//		sp := getcallersp()</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br></pre></td></tr></table></figure>
<pre class="mermaid">graph TD
newproc1 --> newg
newg[gfget] --> nil{is nil?}
nil -->|no|E[init stack / gostartcallfn ]
nil -->|yes|C[malg]
C --> D[set g status=> idle->dead]
D --> k[allgad]
k --> E
E --> G[set g status=> dead-> runnable]
G --> runqput</pre>

<p>结果是调用 runqput 将 g 放进了执行队列</p>
<p>最关键的代码</p>
<p><code>newg.sched.pc = funcPC(goexit) + sys.PCQuantum</code></p>
<p>解决了goroutine运行结束后如何运行下一个goroutine的问题。</p>
<p>gostartcall 函数buf.pc 中的 goexit 的函数地址放到了 goroutine 的栈顶，保证函数执行完之后能执行runtime.goexit。</p>
<p> runqput(_p_, newg, true)</p>
<pre class="mermaid">graph TD
runqput --> full{is the local runnable queue full?}
full -->|no|E[put local queue ]
full -->|yes|C[runqputslow]
C --> K[lock/globrunqputbatch/unlock]
E --> next{ next == true or false ?}
next --> |true| F[puts g in the _p_.runnext slot]
next --> |false| j[adds g to the tail of the runnable queue]</pre>

<blockquote>
<p>操作全局 sched 时，需要获取全局 sched.lock 锁，全局锁争抢的开销较大，所以才称之为 slow</p>
</blockquote>
<h3 id="m工作机制"><a href="#m工作机制" class="headerlink" title="m工作机制"></a>m工作机制</h3><p>在 runtime 中有三种线程，一种是主线程，一种是用来跑 sysmon 的线程，一种是普通的用户线程。</p>
<p>主线程在 runtime 由对应的全局变量: <code>runtime.m0</code> 来表示。</p>
<p>用户线程就是普通的线程了，和 p 绑定，执行 g 中的任务。</p>
<p>sysmon线程是一种特殊的内核线程，负责监控调度。</p>
<p>runtime.main执行流程(runtime/proc.go/func main())</p>
<pre class="mermaid">graph TD
runtime.main --> A[m0 G0]
A --> D[init max stack size]
D --> B[systemstack execute -> newm -> sysmon]
B --> runtime.lockOsThread
runtime.lockOsThread --> runtime.init
runtime.init --> runtime.gcenable
runtime.gcenable --> startTemplateThread
startTemplateThread --> main.init
main.init --> main.main</pre>

<ol>
<li><p>m0和g0绑定</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m0: 系统主线程</span></span><br><span class="line"><span class="comment">// g0：主goroutine</span></span><br><span class="line"><span class="comment">// m0、g0是比较特殊的 仅用于main goroutine的父goroutine</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化maxstacksize，</p>
</li>
</ol>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行栈最大限制：1GB on 64-bit，250MB on 32-bit</span></span><br><span class="line">sys.PtrSize == <span class="number">8</span> &#123;  <span class="comment">// 64bits 系统</span></span><br><span class="line">        maxstacksize = <span class="number">1000000000</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// 32bits系统</span></span><br><span class="line">        maxstacksize = <span class="number">250000000</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>初始化sysmon线程，创建一个新的m来跑，不需要绑定g执行，与整个调度协同脱离。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> GOARCH != <span class="string">"wasm"</span> &#123; <span class="comment">// no threads on wasm yet, so no sysmon</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		newm(sysmon, <span class="literal">nil</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>锁定lockOSThread，开始runtime初始化，开启gc</p>
</li>
<li><p>startTemplateThread   webaseembly环境下不启动，比较慢，大多数程序必须要，辅助线程，解决线程异常问题</p>
</li>
<li><p>各种init初始化</p>
</li>
</ol>
<h4 id="sysmon线程"><a href="#sysmon线程" class="headerlink" title="sysmon线程"></a>sysmon线程</h4><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//没有绑定p的，wirte barriers都是不被允许的，和gc机制相关</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	sched.nmsys++</span><br><span class="line">	checkdead()</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If a heap span goes unused for 5 minutes after a garbage collection,</span></span><br><span class="line">	<span class="comment">// we hand it back to the operating system.</span></span><br><span class="line">	scavengelimit := <span class="keyword">int64</span>(<span class="number">5</span> * <span class="number">60</span> * <span class="number">1e9</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debug.scavenge &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Scavenge-a-lot for testing.</span></span><br><span class="line">		forcegcperiod = <span class="number">10</span> * <span class="number">1e6</span></span><br><span class="line">		scavengelimit = <span class="number">20</span> * <span class="number">1e6</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastscavenge := nanotime()</span><br><span class="line">	nscavenge := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	lasttrace := <span class="keyword">int64</span>(<span class="number">0</span>)</span><br><span class="line">	idle := <span class="number">0</span> <span class="comment">// how many cycles in succession we had not wokeup somebody</span></span><br><span class="line">	delay := <span class="keyword">uint32</span>(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> idle == <span class="number">0</span> &#123; <span class="comment">// 初始化时 20us sleep.</span></span><br><span class="line">			delay = <span class="number">20</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> idle &gt; <span class="number">50</span> &#123; <span class="comment">// start doubling the sleep after 1ms...</span></span><br><span class="line">			delay *= <span class="number">2</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> delay &gt; <span class="number">10</span>*<span class="number">1000</span> &#123; <span class="comment">//最长10ms</span></span><br><span class="line">			delay = <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">		&#125;</span><br><span class="line">		usleep(delay)</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &lt;= <span class="number">0</span> &amp;&amp; (sched.gcwaiting != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs)) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> atomic.Load(&amp;sched.gcwaiting) != <span class="number">0</span> || atomic.Load(&amp;sched.npidle) == <span class="keyword">uint32</span>(gomaxprocs) &#123;</span><br><span class="line">				atomic.Store(&amp;sched.sysmonwait, <span class="number">1</span>)</span><br><span class="line">				unlock(&amp;sched.lock)</span><br><span class="line">				<span class="comment">// Make wake-up period small enough</span></span><br><span class="line">				<span class="comment">// for the sampling to be correct.</span></span><br><span class="line">				maxsleep := forcegcperiod / <span class="number">2</span></span><br><span class="line">				<span class="keyword">if</span> scavengelimit &lt; forcegcperiod &#123;</span><br><span class="line">					maxsleep = scavengelimit / <span class="number">2</span></span><br><span class="line">				&#125;</span><br><span class="line">				shouldRelax := <span class="literal">true</span></span><br><span class="line">				<span class="keyword">if</span> osRelaxMinNS &gt; <span class="number">0</span> &#123;</span><br><span class="line">					next := timeSleepUntil()</span><br><span class="line">					now := nanotime()</span><br><span class="line">					<span class="keyword">if</span> next-now &lt; osRelaxMinNS &#123;</span><br><span class="line">						shouldRelax = <span class="literal">false</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">					osRelax(<span class="literal">true</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				notetsleep(&amp;sched.sysmonnote, maxsleep)</span><br><span class="line">				<span class="keyword">if</span> shouldRelax &#123;</span><br><span class="line">					osRelax(<span class="literal">false</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				lock(&amp;sched.lock)</span><br><span class="line">				atomic.Store(&amp;sched.sysmonwait, <span class="number">0</span>)</span><br><span class="line">				noteclear(&amp;sched.sysmonnote)</span><br><span class="line">				idle = <span class="number">0</span></span><br><span class="line">				delay = <span class="number">20</span></span><br><span class="line">			&#125;</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// trigger libc interceptors if needed</span></span><br><span class="line">		<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">			asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	   <span class="comment">// 如果 10ms 没有 poll 过 network，那么就 netpoll 一次</span></span><br><span class="line">		lastpoll := <span class="keyword">int64</span>(atomic.Load64(&amp;sched.lastpoll))</span><br><span class="line">		now := nanotime()</span><br><span class="line">		<span class="keyword">if</span> netpollinited() &amp;&amp; lastpoll != <span class="number">0</span> &amp;&amp; lastpoll+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &lt; now &#123;</span><br><span class="line">			atomic.Cas64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(lastpoll), <span class="keyword">uint64</span>(now))</span><br><span class="line">      <span class="comment">//netpoll中会执行epollWait，epollWait返回可读写的fd</span></span><br><span class="line">      <span class="comment">//netpoll返回可读写的fd关联的协程</span></span><br><span class="line">			list := netpoll(<span class="literal">false</span>) <span class="comment">// non-blocking - returns list of goroutines</span></span><br><span class="line">			<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">				<span class="comment">// Need to decrement number of idle locked M's</span></span><br><span class="line">				<span class="comment">// (pretending that one more is running) before injectglist.</span></span><br><span class="line">				<span class="comment">// Otherwise it can lead to the following situation:</span></span><br><span class="line">				<span class="comment">// injectglist grabs all P's but before it starts M's to run the P's,</span></span><br><span class="line">				<span class="comment">// another M returns from syscall, finishes running its G,</span></span><br><span class="line">				<span class="comment">// observes that there is no work to do and no other running M's</span></span><br><span class="line">				<span class="comment">// and reports deadlock.</span></span><br><span class="line">				incidlelocked(<span class="number">-1</span>)</span><br><span class="line">        <span class="comment">//将可读写fd关联的协程状态设置为ready</span></span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				incidlelocked(<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// retake P's blocked in syscalls</span></span><br><span class="line">		<span class="comment">// and preempt long running G's</span></span><br><span class="line">		<span class="keyword">if</span> retake(now) != <span class="number">0</span> &#123;</span><br><span class="line">			idle = <span class="number">0</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			idle++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 检查是否需要强制gc，两分钟一次</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;forcegc.lock)</span><br><span class="line">			forcegc.idle = <span class="number">0</span></span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			unlock(&amp;forcegc.lock)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 清理内存</span></span><br><span class="line">		<span class="keyword">if</span> lastscavenge+scavengelimit/<span class="number">2</span> &lt; now &#123;</span><br><span class="line">			mheap_.scavenge(<span class="keyword">int32</span>(nscavenge), <span class="keyword">uint64</span>(now), <span class="keyword">uint64</span>(scavengelimit))</span><br><span class="line">			lastscavenge = now</span><br><span class="line">			nscavenge++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> debug.schedtrace &gt; <span class="number">0</span> &amp;&amp; lasttrace+<span class="keyword">int64</span>(debug.schedtrace)*<span class="number">1000000</span> &lt;= now &#123;</span><br><span class="line">			lasttrace = now</span><br><span class="line">			schedtrace(debug.scheddetail &gt; <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="核心功能："><a href="#核心功能：" class="headerlink" title="核心功能："></a>核心功能：</h5><ol>
<li>检查checkdead ，检查goroutine锁死，启动时检查一次。</li>
<li>处理netpoll返回，injectglist将协程的状态设置为ready状态</li>
<li>强制gc</li>
<li>收回因为 syscall 而长时间阻塞的 p，同时抢占那些执行时间过长的 g，retake(now)</li>
<li>如果 堆 内存闲置超过 5min，那么释放掉，mheap_.scavenge(int32(nscavenge), uint64(now), uint64(scavengelimit))</li>
</ol>
<h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><pre class="mermaid">graph TD
sysmon --> lock
lock --> checkdead
checkdead --> unlock
unlock --> for
K[scavenge heap once in a while]  --> |every 10ms| for 
for --> usleep
usleep --> netpoll
netpoll --> injectglist 
injectglist --> retake
retake --> forceGC
forceGC --> K</pre>



<h4 id="普通线程"><a href="#普通线程" class="headerlink" title="普通线程"></a>普通线程</h4><pre class="mermaid">graph TD
newm --> newm1
newm1 --> newosproc
newosproc --> clone</pre>



<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个m，该 m 会在启动时调用函数 fn，或者 schedule 函数</span></span><br><span class="line"><span class="comment">// fn 需要是 static 类型，且不能是在堆上分配的闭包。</span></span><br><span class="line"><span class="comment">// 运行 m 时，m.p 是有可能为 nil 的，所以不允许 write barriers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm</span><span class="params">(fn <span class="keyword">func</span>()</span>, _<span class="title">p_</span> *<span class="title">p</span>)</span> &#123;</span><br><span class="line">	mp := allocm(_p_, fn)</span><br><span class="line">	mp.nextp.set(_p_)  <span class="comment">//传入的 p 会被赋值给 m 的 nextp 成员，在 m 执行 schedule 时，会将 nextp 拿出来，进行之后真正的绑定操作</span></span><br><span class="line">	<span class="comment">//issue/22227.</span></span><br><span class="line">	newm1(mp)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newm1</span><span class="params">(mp *m)</span></span> &#123;</span><br><span class="line">	execLock.rlock() <span class="comment">// Prevent process clone.</span></span><br><span class="line">	newosproc(mp)  -&gt;   thr_new</span><br><span class="line">	execLock.runlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h5><p>空闲的 m 会被丢进全局调度器的 midle 队列中，在需要 m 的时候，会先从这里取，如果获取不到newm申请一个</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mget</span><span class="params">()</span> *<span class="title">m</span></span> &#123;</span><br><span class="line">	mp := sched.midle.ptr()</span><br><span class="line">	<span class="keyword">if</span> mp != <span class="literal">nil</span> &#123;</span><br><span class="line">		sched.midle = mp.schedlink</span><br><span class="line">		sched.nmidle--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取m，全局，调用mget必须lock(&amp;sched.lock)</span></span><br></pre></td></tr></table></figure>
<h5 id="和newm相关的调用"><a href="#和newm相关的调用" class="headerlink" title="和newm相关的调用"></a>和newm相关的调用</h5><pre class="mermaid">graph TD
main --> |sysmon|newm
startTheWorld --> startTheWorldWithSema
gcMarkTermination --> startTheWorldWithSema
gcStart--> startTheWorldWithSema
startTheWorldWithSema --> |helpgc|newm
startTheWorldWithSema --> |run p|newm
startm --> mget
mget --> |if no free m|newm
startTemplateThread --> |templateThread|newm
LockOsThread --> startTemplateThread
main --> |iscgo|startTemplateThread
handoffp --> startm
wakep --> startm
injectglist --> startm</pre>

<p> sched.midle 中没有空闲的 m 了，就去创建，两个特殊的sysmon，templateThread</p>
<h5 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h5><ol>
<li>schedule</li>
</ol>
<pre class="mermaid">graph TD
schedule --> A[schedtick%61 == 0]
A --> |yes|globrunqget
A --> |no|runqget
globrunqget --> C[gp == nil]
C --> |no|execute
C --> |yes|runqget
runqget --> B[gp == nil]
B --> |no|execute
B --> |yes|findrunnable
findrunnable --> execute</pre>

<ol>
<li><p>cgo的g不能被schedule走，cgo实用的m的g0栈</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We should not schedule away from a g that is executing a cgo call,</span></span><br><span class="line"><span class="comment">// since the cgo call is using the m's g0 stack.</span></span><br><span class="line"><span class="keyword">if</span> _g_.m.incgo &#123;</span><br><span class="line">	throw(<span class="string">"schedule: in cgo"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2 . 为了保证调度的公平性，每个工作线程每进行61次调度就需要优先从全局运行队列中获取goroutine出来运行,</p>
<p>​     因为如果只调度本地运行队列中的goroutine，则全局运行队列中的goroutine有可能得不到运行</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// Check the global runnable queue once in a while to ensure fairness.</span></span><br><span class="line">	<span class="comment">// Otherwise two goroutines can completely occupy the local runqueue</span></span><br><span class="line">	<span class="comment">// by constantly respawning each other.</span></span><br><span class="line">	<span class="comment">//全局的队列中找</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.p.ptr().schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp = globrunqget(_g_.m.p.ptr(), <span class="number">1</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//从与m关联的p的本地运行队列中获取goroutine</span></span><br><span class="line">	gp, inheritTime = runqget(_g_.m.p.ptr())</span><br><span class="line">	<span class="keyword">if</span> gp != <span class="literal">nil</span> &amp;&amp; _g_.m.spinning &#123;</span><br><span class="line">		throw(<span class="string">"schedule: spinning with local work"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> gp == <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">//如果从本地运行队列和全局运行队列都没有找到需要运行的goroutine，</span></span><br><span class="line">   <span class="comment">//则调用findrunnable函数从其它工作线程的运行队列中偷取，如果偷取不到，则当前工作线程进入睡眠，</span></span><br><span class="line">   <span class="comment">//直到获取到需要运行的goroutine之后findrunnable函数才会返回</span></span><br><span class="line">	gp, inheritTime = findrunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>状态处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This thread is going to run a goroutine and is not spinning anymore,</span></span><br><span class="line">	<span class="comment">// so if it was marked as spinning we need to reset it now and potentially</span></span><br><span class="line">	<span class="comment">// start a new spinning M.</span></span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		resetspinning()</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行execute，具体 gogo(&amp;gp.sched)，汇编完成嗯，执行go func()中func(),把 g 对象的 gobuf 里的内容搬到寄存器里。然后从 <code>gobuf.pc</code> 寄存器存储的指令位置开始继续向后执行</p>
</li>
</ol>
<h5 id="Goexit"><a href="#Goexit" class="headerlink" title="Goexit"></a>Goexit</h5><p>每个goroutine栈底都会有runtime.goexit()，它其实就是在创建G的时候，被设置进去的</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finishes execution of the current goroutine.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racegoend()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoEnd()</span><br><span class="line">	&#125;</span><br><span class="line">	mcall(goexit0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">	_g_ := getg() <span class="comment">//获取g0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将已经执行完毕的goroutine状态设为dead</span></span><br><span class="line">	casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">  <span class="comment">// 如果是系统goroutine则全局计数减一</span></span><br><span class="line">	<span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">		atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//清空状态</span></span><br><span class="line">	gp.m = <span class="literal">nil</span></span><br><span class="line">	locked := gp.lockedm != <span class="number">0</span></span><br><span class="line">	gp.lockedm = <span class="number">0</span></span><br><span class="line">	_g_.m.lockedg = <span class="number">0</span></span><br><span class="line">	gp.paniconfault = <span class="literal">false</span></span><br><span class="line">	gp._defer = <span class="literal">nil</span> <span class="comment">// should be true already but just in case.</span></span><br><span class="line">	gp._panic = <span class="literal">nil</span> <span class="comment">// non-nil for Goexit during panic. points at stack-allocated data.</span></span><br><span class="line">	gp.writebuf = <span class="literal">nil</span></span><br><span class="line">	gp.waitreason = <span class="number">0</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gp.labels = <span class="literal">nil</span></span><br><span class="line">	gp.timer = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gp.gcAssistBytes &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Flush assist credit to the global pool. This gives</span></span><br><span class="line">		<span class="comment">// better information to pacing if the application is</span></span><br><span class="line">		<span class="comment">// rapidly creating an exiting goroutines.</span></span><br><span class="line">		scanCredit := <span class="keyword">int64</span>(gcController.assistWorkPerByte * <span class="keyword">float64</span>(gp.gcAssistBytes))</span><br><span class="line">		atomic.Xaddint64(&amp;gcController.bgScanCredit, scanCredit)</span><br><span class="line">		gp.gcAssistBytes = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Note that gp's stack scan is now "valid" because it has no</span></span><br><span class="line">	<span class="comment">// stack.</span></span><br><span class="line">	gp.gcscanvalid = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 因为M和正在运行的G是有互相引用的，G都已经执行完了，所以就摘掉</span></span><br><span class="line">	dropg()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> GOARCH == <span class="string">"wasm"</span> &#123; <span class="comment">// no threads yet on wasm</span></span><br><span class="line">		gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">		schedule() <span class="comment">// never returns</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> _g_.m.lockedInt != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"invalid m-&gt;lockedInt = "</span>, _g_.m.lockedInt, <span class="string">"\n"</span>)</span><br><span class="line">		throw(<span class="string">"internal lockOSThread error"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 把已经执行完的goroutine放置在P的本地free goroutine队列里，最多64个，超出则转移到全局调度器</span></span><br><span class="line">	gfput(_g_.m.p.ptr(), gp)</span><br><span class="line">	<span class="keyword">if</span> locked &#123;</span><br><span class="line">		<span class="comment">// The goroutine may have locked this thread because</span></span><br><span class="line">		<span class="comment">// it put it in an unusual kernel state. Kill it</span></span><br><span class="line">		<span class="comment">// rather than returning it to the thread pool.</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Return to mstart, which will release the P and exit</span></span><br><span class="line">		<span class="comment">// the thread.</span></span><br><span class="line">		<span class="keyword">if</span> GOOS != <span class="string">"plan9"</span> &#123; <span class="comment">// See golang.org/issue/22227.</span></span><br><span class="line">			gogo(&amp;_g_.m.g0.sched)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Clear lockedExt on plan9 since we may end up re-using</span></span><br><span class="line">			<span class="comment">// this thread.</span></span><br><span class="line">			_g_.m.lockedExt = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 调度，找出下一个可以执行的goroutine，继续执行</span></span><br><span class="line">	schedule()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>G的状态变为_GDead，如果是系统G则更新全局计数器。</li>
<li>重置G身上一系列的属性变量。</li>
<li>解除M和G的互相引用关系。</li>
<li>放置在本地P或全局的free goroutine队列。</li>
<li>调度，寻找下一个可运行的goroutine。</li>
</ol>
<h5 id="wakep"><a href="#wakep" class="headerlink" title="wakep"></a>wakep</h5><pre class="mermaid">graph TD
wakep --> startm 
startm --> mget 
mget --> |no|newm
mget --> |yes|notewakeup</pre>

<ol>
<li>wakep的作用是添加一个P来执行goroutinue</li>
</ol>
<p>​      在有G变为runnable的时候,调用startm</p>
<ol start="2">
<li>startm(nil, true)，传入的_p_ = nil，要获取一个idle P，如果获取不到，直接返回，</li>
<li>调用<code>mget</code>获得一个已经睡眠m，获取到了则调用notewakeup来唤醒m（因为m在mput的时候已经睡眠了）</li>
<li>如果获取失败，就调用newm创建</li>
</ol>
<h5 id="gopark"><a href="#gopark" class="headerlink" title="gopark"></a>gopark</h5><p>阻塞，用于协程的切换，系统调用，channel读写条件不满足，抢占式调度时间片结束。</p>
<p>主要做两件事：</p>
<ol>
<li><p>解除当前goroutine的m的绑定关系，将当前goroutine状态机切换为等待状态；</p>
</li>
<li><p>调用一次schedule()函数，在局部调度器P发起一轮新的调度</p>
</li>
</ol>
<p>核心函数mcall(park_m)，park_m是一个函数指针</p>
<ol>
<li>切换当前线程的堆栈从g的堆栈切换到g0的堆栈；</li>
<li>并在g0的堆栈上执行新的函数park_m，park_m中执行schedule，调度器会重新调度选择一个goroutine去运行</li>
<li>保存当前协程的信息( PC/SP存储到g-&gt;sched)，当后续对当前协程调用goready函数时候能够恢复现场；</li>
</ol>
<h5 id="goready"><a href="#goready" class="headerlink" title="goready"></a>goready</h5><p>唤醒某一个goroutine，该协程转换到runnable的状态，并将其放入P的local queue，等待调度，有延时。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 切换到g0的栈</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ready(gp, traceskip, <span class="literal">true</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Mark gp ready to run.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ready</span><span class="params">(gp *g, traceskip <span class="keyword">int</span>, next <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">		traceGoUnpark(gp, traceskip)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	status := readgstatus(gp)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mark runnable.</span></span><br><span class="line">	_g_ := getg()</span><br><span class="line">	_g_.m.locks++ <span class="comment">// disable preemption because it can be holding p in a local var</span></span><br><span class="line">	<span class="keyword">if</span> status&amp;^_Gscan != _Gwaiting &#123;</span><br><span class="line">		dumpgstatus(gp)</span><br><span class="line">		throw(<span class="string">"bad g-&gt;status in ready"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq</span></span><br><span class="line">  <span class="comment">//设置gp状态为runnable，然后加入到P的可运行local queue;</span></span><br><span class="line">	casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">	runqput(_g_.m.p.ptr(), gp, next)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) != <span class="number">0</span> &amp;&amp; atomic.Load(&amp;sched.nmspinning) == <span class="number">0</span> &#123;</span><br><span class="line">		wakep()</span><br><span class="line">	&#125;</span><br><span class="line">	_g_.m.locks--</span><br><span class="line">	<span class="keyword">if</span> _g_.m.locks == <span class="number">0</span> &amp;&amp; _g_.preempt &#123; <span class="comment">// restore the preemption request in Case we've cleared it in newstack</span></span><br><span class="line">		_g_.stackguard0 = stackPreempt</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="findrunnable-抛开gc状态"><a href="#findrunnable-抛开gc状态" class="headerlink" title="findrunnable(抛开gc状态)"></a>findrunnable(抛开gc状态)</h5><pre class="mermaid">graph TD
runqget --> A[gp == nil]
A --> |no|return
A --> |yes|globrunqget
globrunqget --> B[gp == nil]
B --> |no| return
B --> |yes| C[netpollinited && lastpoll != 0]
C --> |yes|netpoll
netpoll --> K[gp == nil]
K --> |no|return
K --> |yes|runqsteal
C --> |no|runqsteal
runqsteal --> D[gp == nil]
D --> |no|return
D --> |yes|E[globrunqget]
E --> F[gp == nil]
F --> |no| return
F --> |yes| G[check all p's runq]
G --> H[runq is empty]
H --> |no|runqget
H --> |yes|I[netpoll]
I --> J[gp == nil]
J --> |no| return
J --> |yes| stopm
stopm --> runqget</pre>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 找到一个可执行的 goroutine 来 execute</span></span><br><span class="line"><span class="comment">// 会尝试从其它的 P 那里偷 g，从全局队列中拿，或者 network 中 poll</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findrunnable</span><span class="params">()</span> <span class="params">(gp *g, inheritTime <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	_g_ := getg()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The conditions here and in handoffp must agree: if</span></span><br><span class="line">	<span class="comment">// findrunnable would return a G to run, handoffp must start</span></span><br><span class="line">	<span class="comment">// an M.</span></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">	_p_ := _g_.m.p.ptr()</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">		gcstopm()</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		runSafePointFn()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fingwait &amp;&amp; fingwake &#123;</span><br><span class="line">		<span class="keyword">if</span> gp := wakefing(); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			ready(gp, <span class="number">0</span>, <span class="literal">true</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> *cgo_yield != <span class="literal">nil</span> &#123;</span><br><span class="line">		asmcgocall(*cgo_yield, <span class="literal">nil</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从本地队列中获取</span></span><br><span class="line">	<span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> gp, inheritTime</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从全局队列中获取</span></span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Poll network.</span></span><br><span class="line">	<span class="comment">// This netpoll is only an optimization before we resort to stealing.</span></span><br><span class="line">	<span class="comment">// We can safely skip it if there are no waiters or a thread is blocked</span></span><br><span class="line">	<span class="comment">// in netpoll already. If there is any kind of logical race with that</span></span><br><span class="line">	<span class="comment">// blocked thread (e.g. it has already returned from netpoll, but does</span></span><br><span class="line">	<span class="comment">// not set lastpoll yet), this thread will do blocking netpoll below</span></span><br><span class="line">	<span class="comment">// anyway.</span></span><br><span class="line"> <span class="comment">// 从poll获取</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> list := netpoll(<span class="literal">false</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">			gp := list.pop()</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">			<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">				traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Steal work from other P's.</span></span><br><span class="line">	procs := <span class="keyword">uint32</span>(gomaxprocs)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;sched.npidle) == procs<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Either GOMAXPROCS=1 or everybody, except for us, is idle already.</span></span><br><span class="line">		<span class="comment">// New work can appear from returning syscall/cgocall, network or timers.</span></span><br><span class="line">		<span class="comment">// Neither of that submits to local run queues, so no point in stealing.</span></span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If number of spinning M's &gt;= number of busy P's, block.</span></span><br><span class="line">	<span class="comment">// This is necessary to prevent excessive CPU consumption</span></span><br><span class="line">	<span class="comment">// when GOMAXPROCS&gt;&gt;1 but the program parallelism is low.</span></span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &amp;&amp; <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &gt;= procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">		<span class="keyword">goto</span> stop</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">		atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 尝试4次从别的P偷</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> enum := stealOrder.start(fastrand()); !enum.done(); enum.next() &#123;</span><br><span class="line">			<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			stealRunNextG := i &gt; <span class="number">2</span> <span class="comment">// first look for ready queues with more than 1 g</span></span><br><span class="line">       <span class="comment">// 在这里开始针对P进行偷取操作</span></span><br><span class="line">			<span class="keyword">if</span> gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">stop:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We have nothing to do. If we're in the GC mark phase, can</span></span><br><span class="line">	<span class="comment">// safely scan and blacken objects, and have work to do, run</span></span><br><span class="line">	<span class="comment">// idle-time marking rather than give up the P.</span></span><br><span class="line"> <span class="comment">//如果处于垃圾回收标记阶段，就进行垃圾回收的标记工作；</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; _p_.gcBgMarkWorker != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(_p_) &#123;</span><br><span class="line">		_p_.gcMarkWorkerMode = gcMarkWorkerIdleMode</span><br><span class="line">		gp := _p_.gcBgMarkWorker.ptr()</span><br><span class="line">		casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">		<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">			traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wasm only:</span></span><br><span class="line">	<span class="comment">// If a callback returned and no other goroutine is awake,</span></span><br><span class="line">	<span class="comment">// then pause execution until a callback was triggered.</span></span><br><span class="line">	<span class="keyword">if</span> beforeIdle() &#123;</span><br><span class="line">		<span class="comment">// At least one goroutine got woken.</span></span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Before we drop our P, make a snapshot of the allp slice,</span></span><br><span class="line">	<span class="comment">// which can change underfoot once we no longer block</span></span><br><span class="line">	<span class="comment">// safe-points. We don't need to snapshot the contents because</span></span><br><span class="line">	<span class="comment">// everything up to cap(allp) is immutable.</span></span><br><span class="line">	allpSnapshot := allp</span><br><span class="line"></span><br><span class="line">	<span class="comment">// return P and block</span></span><br><span class="line">	lock(&amp;sched.lock)</span><br><span class="line">	<span class="keyword">if</span> sched.gcwaiting != <span class="number">0</span> || _p_.runSafePointFn != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">goto</span> top</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">		gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> releasep() != _p_ &#123;</span><br><span class="line">		throw(<span class="string">"findrunnable: wrong p"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	pidleput(_p_)</span><br><span class="line">	unlock(&amp;sched.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Delicate dance: thread transitions from spinning to non-spinning state,</span></span><br><span class="line">	<span class="comment">// potentially concurrently with submission of new goroutines. We must</span></span><br><span class="line">	<span class="comment">// drop nmspinning first and then check all per-P queues again (with</span></span><br><span class="line">	<span class="comment">// #StoreLoad memory barrier in between). If we do it the other way around,</span></span><br><span class="line">	<span class="comment">// another thread can submit a goroutine after we've checked all run queues</span></span><br><span class="line">	<span class="comment">// but before we drop nmspinning; as the result nobody will unpark a thread</span></span><br><span class="line">	<span class="comment">// to run the goroutine.</span></span><br><span class="line">	<span class="comment">// If we discover new work below, we need to restore m.spinning as a signal</span></span><br><span class="line">	<span class="comment">// for resetspinning to unpark a new worker thread (because there can be more</span></span><br><span class="line">	<span class="comment">// than one starving goroutine). However, if after discovering new work</span></span><br><span class="line">	<span class="comment">// we also observe no idle Ps, it is OK to just park the current thread:</span></span><br><span class="line">	<span class="comment">// the system is fully loaded so no spinning threads are required.</span></span><br><span class="line">	<span class="comment">// Also see "Worker thread parking/unparking" comment at the top of the file.</span></span><br><span class="line">	wasSpinning := _g_.m.spinning</span><br><span class="line">	<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">		_g_.m.spinning = <span class="literal">false</span></span><br><span class="line">		<span class="keyword">if</span> <span class="keyword">int32</span>(atomic.Xadd(&amp;sched.nmspinning, <span class="number">-1</span>)) &lt; <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: negative nmspinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// check all runqueues once again</span></span><br><span class="line">	<span class="keyword">for</span> _, _p_ := <span class="keyword">range</span> allpSnapshot &#123;</span><br><span class="line">		<span class="keyword">if</span> !runqempty(_p_) &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">					_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">					atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">goto</span> top</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for idle-priority GC work again.</span></span><br><span class="line">	<span class="keyword">if</span> gcBlackenEnabled != <span class="number">0</span> &amp;&amp; gcMarkWorkAvailable(<span class="literal">nil</span>) &#123;</span><br><span class="line">		lock(&amp;sched.lock)</span><br><span class="line">		_p_ = pidleget()</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &amp;&amp; _p_.gcBgMarkWorker == <span class="number">0</span> &#123;</span><br><span class="line">			pidleput(_p_)</span><br><span class="line">			_p_ = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;sched.lock)</span><br><span class="line">		<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">			acquirep(_p_)</span><br><span class="line">			<span class="keyword">if</span> wasSpinning &#123;</span><br><span class="line">				_g_.m.spinning = <span class="literal">true</span></span><br><span class="line">				atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Go back to idle GC check.</span></span><br><span class="line">			<span class="keyword">goto</span> stop</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// poll network</span></span><br><span class="line">	<span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Xchg64(&amp;sched.lastpoll, <span class="number">0</span>) != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.p != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with p"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> _g_.m.spinning &#123;</span><br><span class="line">			throw(<span class="string">"findrunnable: netpoll with spinning"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		list := netpoll(<span class="literal">true</span>) <span class="comment">// block until new work is available</span></span><br><span class="line">		atomic.Store64(&amp;sched.lastpoll, <span class="keyword">uint64</span>(nanotime()))</span><br><span class="line">		<span class="keyword">if</span> !list.empty() &#123;</span><br><span class="line">			lock(&amp;sched.lock)</span><br><span class="line">			_p_ = pidleget()</span><br><span class="line">			unlock(&amp;sched.lock)</span><br><span class="line">			<span class="keyword">if</span> _p_ != <span class="literal">nil</span> &#123;</span><br><span class="line">				acquirep(_p_)</span><br><span class="line">				gp := list.pop()</span><br><span class="line">				injectglist(&amp;list)</span><br><span class="line">				casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">				<span class="keyword">if</span> trace.enabled &#123;</span><br><span class="line">					traceGoUnpark(gp, <span class="number">0</span>)</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> gp, <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	stopm()</span><br><span class="line">	<span class="keyword">goto</span> top</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>调用runqget()从当前<em>P</em>的队列中取<em>G</em>（和schedule()中的调用相同），获取到就return</p>
</li>
<li><p>获取不到就全局队列中获取，获取到了就return</p>
</li>
<li><p>尝试从poll中获取，获取得到也return</p>
</li>
<li><p>获取不到就尝试从其他的p中获取，找数量超过1个的，找得到就返回，runqsteal</p>
</li>
<li><p>如果处于垃圾回收标记阶段，就进行垃圾回收的标记工作；</p>
</li>
<li>再次调用globrunqget()从全局队列中取可执行的<em>G</em>，获取的到就返回 return</li>
<li>再次检查所有的runqueues，如果有返回到最开始的top</li>
<li>没有就做gc方面的工作，然次从poll获取，获取的到就return，获取不到就然后调用stopm</li>
<li>stopm的核心是调用mput把m结构体对象放入sched的midle空闲队列，然后通过notesleep(&amp;m.park)函数让自己进入睡眠状态。</li>
<li>唤醒后在再次跳转到top</li>
</ol>
<h5 id="handoffp"><a href="#handoffp" class="headerlink" title="handoffp"></a>handoffp</h5><p>p和m解除绑定状态，把 p 放回全局的 pidle 队列中</p>
<p>大概有5中情况调用handoffp</p>
<ol>
<li>线程退出mexit</li>
<li>遍历p的时候，p的状态syscall</li>
<li>m已经被某个g锁定，先停止当前m（stoplockedm），等待g可运行时，再执行g</li>
<li>entersyscallblock，锁相关的时候导致的阻塞回调用到，直接p和m解除绑定状态</li>
<li>retake抢占式调度，会解绑</li>
</ol>
<pre class="mermaid">graph TD

mexit --> A[is m0?]
A --> |yes|B[handoffp]
A --> |no| C[iterate allm]
C --> |m found|handoffp
C --> |m not found| throw

forEachP --> |p status == syscall| handoffp

stoplockedm --> handoffp

entersyscallblock --> entersyscallblock_handoff
entersyscallblock_handoff --> handoffp

retake --> |p status == syscall| handoffp</pre>



<h5 id="g状态"><a href="#g状态" class="headerlink" title="g状态"></a>g状态</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// G status</span></span><br><span class="line">	_Gidle = <span class="literal">iota</span> <span class="comment">// 刚刚新建，未初始化</span></span><br><span class="line"></span><br><span class="line">	_Grunnable <span class="comment">// 大的g队列中，还没有运行过，没有自己的堆栈空间，等待m绑定运行</span></span><br><span class="line"></span><br><span class="line">	_Grunning <span class="comment">// 分配了m，p有堆栈，但是没有在运行队列中，有堆栈空间</span></span><br><span class="line"></span><br><span class="line">	_Gsyscall <span class="comment">// 3不在运行队列中，阻塞状态，只和m绑定，m并没有和p绑定</span></span><br><span class="line"></span><br><span class="line">	_Gwaiting <span class="comment">// 4表示G在等待某些条件完成, 这时候G不在运行也不在运行队列中(可能在channel的等待队列中)</span></span><br><span class="line"></span><br><span class="line">	_Gmoribund_unused <span class="comment">// 5没使用</span></span><br><span class="line"></span><br><span class="line">	_Gdead <span class="comment">// 没有使用了，在空闲列表上，没有堆栈</span></span><br><span class="line"></span><br><span class="line">	_Genqueue_unused <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">	_Gcopystack <span class="comment">// 表示G正在获取一个新的栈空间并把原来的内容复制过去，防止被gc，栈空间扩容</span></span><br><span class="line">   </span><br><span class="line">  <span class="comment">//gc</span></span><br><span class="line">	_Gscan         = <span class="number">0x1000</span></span><br><span class="line">	_Gscanrunnable = _Gscan + _Grunnable <span class="comment">// 0x1001</span></span><br><span class="line">	_Gscanrunning  = _Gscan + _Grunning  <span class="comment">// 0x1002</span></span><br><span class="line">	_Gscansyscall  = _Gscan + _Gsyscall  <span class="comment">// 0x1003</span></span><br><span class="line">	_Gscanwaiting  = _Gscan + _Gwaiting  <span class="comment">// 0x1004</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="G的状态迁移"><a href="#G的状态迁移" class="headerlink" title="G的状态迁移"></a>G的状态迁移</h5><pre class="mermaid">graph LR
start{newg} --> Gidle
Gidle --> |oneNewExtraM|Gdead
Gidle --> |newproc1|Gdead

Gdead --> |newproc1|Grunnable
Gdead --> |needm|Gsyscall

Gscanrunning --> |scang|Grunning

Grunnable --> |execute|Grunning

Gany --> |casgcopystack|Gcopystack

Gcopystack --> |todotodo|Grunning

Gsyscall --> |dropm|Gdead
Gsyscall --> |exitsyscall0|Grunnable
Gsyscall --> |exitsyscall|Grunning

Grunning --> |goschedImpl|Grunnable
Grunning --> |goexit0|Gdead
Grunning --> |newstack|Gcopystack
Grunning --> |reentersyscall|Gsyscall
Grunning --> |entersyscallblock|Gsyscall
Grunning --> |markroot|Gwaiting
Grunning --> |gcAssistAlloc1|Gwaiting
Grunning --> |park_m|Gwaiting
Grunning --> |gcMarkTermination|Gwaiting
Grunning --> |gcBgMarkWorker|Gwaiting
Grunning --> |newstack|Gwaiting

Gwaiting --> |gcMarkTermination|Grunning
Gwaiting --> |gcBgMarkWorker|Grunning
Gwaiting --> |markroot|Grunning
Gwaiting --> |gcAssistAlloc1|Grunning
Gwaiting --> |newstack|Grunning
Gwaiting --> |findRunnableGCWorker|Grunnable
Gwaiting --> |ready|Grunnable
Gwaiting --> |findrunnable|Grunnable
Gwaiting --> |injectglist|Grunnable
Gwaiting --> |schedule|Grunnable
Gwaiting --> |park_m|Grunnable
Gwaiting --> |procresize|Grunnable
Gwaiting --> |checkdead|Grunnable</pre>

<h5 id="P状态"><a href="#P状态" class="headerlink" title="P状态"></a>P状态</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// P status</span></span><br><span class="line">	_Pidle    = <span class="literal">iota</span></span><br><span class="line">	_Prunning <span class="comment">// Only this P is allowed to change from _Prunning.</span></span><br><span class="line">	_Psyscall <span class="comment">//等待状态，retake中关注陷入retake的p，继续判断它等待的时间是否已经太长，如果是这样，就准备抛弃原来的还陷入syscall的m，调用handoff(p)，开始为p准备新生活</span></span><br><span class="line">	_Pgcstop</span><br><span class="line">	_Pdead</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h5 id="P状态迁移"><a href="#P状态迁移" class="headerlink" title="P状态迁移"></a>P状态迁移</h5><pre class="mermaid">graph LR

Pidle --> |acquirep1|Prunning

Psyscall --> |retake|Pidle
Psyscall --> |entersyscall_gcwait|Pgcstop
Psyscall --> |exitsyscallfast|Prunning

Pany --> |gcstopm|Pgcstop
Pany --> |forEachP|Pidle
Pany --> |releasep|Pidle
Pany --> |handoffp|Pgcstop
Pany --> |procresize release current p use allp 0|Pidle
Pany --> |procresize when init|Pgcstop
Pany --> |procresize when free old p| Pdead
Pany --> |procresize after resize use current p|Prunning
Pany --> |reentersyscall|Psyscall
Pany --> |stopTheWorldWithSema|Pgcstop</pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/协程/" rel="tag"># 协程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/16/Mac下编译RedisDesktopManager/" rel="next" title="Mac下编译RedisDesktopManager">
                <i class="fa fa-chevron-left"></i> Mac下编译RedisDesktopManager
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="三鱼">
            
              <p class="site-author-name" itemprop="name">三鱼</p>
              <p class="site-description motion-element" itemprop="description">挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xyiot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:softstarxy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/5419866199/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#gpm源码阅读"><span class="nav-number">1.</span> <span class="nav-text">gpm源码阅读</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.1.</span> <span class="nav-text">基本数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gpm流程"><span class="nav-number">1.2.</span> <span class="nav-text">gpm流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#p初始化"><span class="nav-number">1.2.1.</span> <span class="nav-text">p初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g-初始化"><span class="nav-number">1.2.2.</span> <span class="nav-text">g 初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#m工作机制"><span class="nav-number">1.2.3.</span> <span class="nav-text">m工作机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#sysmon线程"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">sysmon线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#源码"><span class="nav-number">1.2.3.1.1.</span> <span class="nav-text">源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#核心功能："><span class="nav-number">1.2.3.1.2.</span> <span class="nav-text">核心功能：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#流程图"><span class="nav-number">1.2.3.1.3.</span> <span class="nav-text">流程图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#普通线程"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">普通线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#工作流程"><span class="nav-number">1.2.3.2.1.</span> <span class="nav-text">工作流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#和newm相关的调用"><span class="nav-number">1.2.3.2.2.</span> <span class="nav-text">和newm相关的调用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#核心流程"><span class="nav-number">1.2.3.2.3.</span> <span class="nav-text">核心流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Goexit"><span class="nav-number">1.2.3.2.4.</span> <span class="nav-text">Goexit</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#wakep"><span class="nav-number">1.2.3.2.5.</span> <span class="nav-text">wakep</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gopark"><span class="nav-number">1.2.3.2.6.</span> <span class="nav-text">gopark</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#goready"><span class="nav-number">1.2.3.2.7.</span> <span class="nav-text">goready</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#findrunnable-抛开gc状态"><span class="nav-number">1.2.3.2.8.</span> <span class="nav-text">findrunnable(抛开gc状态)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#handoffp"><span class="nav-number">1.2.3.2.9.</span> <span class="nav-text">handoffp</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#g状态"><span class="nav-number">1.2.3.2.10.</span> <span class="nav-text">g状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#G的状态迁移"><span class="nav-number">1.2.3.2.11.</span> <span class="nav-text">G的状态迁移</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P状态"><span class="nav-number">1.2.3.2.12.</span> <span class="nav-text">P状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#P状态迁移"><span class="nav-number">1.2.3.2.13.</span> <span class="nav-text">P状态迁移</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三鱼</span>
  
</div>




  <script src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js"></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>








        
<div class="busuanzi-count">
     <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
