<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="协程,">





  <link rel="alternate" href="/atom.xml" title="三余无梦生" type="application/atom+xml">






<meta name="description" content="深入浅出channel/select go的编程哲学：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存    channel优雅的关闭channel 关闭一个已关闭的通道会引起Panic 将值发送到已关闭的通道会发生Panic  解决办法：1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func IsClose">
<meta name="keywords" content="协程">
<meta property="og:type" content="article">
<meta property="og:title" content="深入浅出channel&#x2F;select">
<meta property="og:url" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/index.html">
<meta property="og:site_name" content="三余无梦生">
<meta property="og:description" content="深入浅出channel/select go的编程哲学：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存    channel优雅的关闭channel 关闭一个已关闭的通道会引起Panic 将值发送到已关闭的通道会发生Panic  解决办法：1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func IsClose">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/zzz.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/xxx.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/uuu.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/ooo.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/ppp.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/vvvvv.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/bbbbb.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/mmm.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/iii.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/111111.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/22222222.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/aaa.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/bbb.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/ccc.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/ddd.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/fff.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/ggg.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/hhh.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/jjj.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/kkk.png">
<meta property="og:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/lll.png">
<meta property="og:updated_time" content="2019-07-30T09:17:26.277Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入浅出channel&#x2F;select">
<meta name="twitter:description" content="深入浅出channel/select go的编程哲学：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存    channel优雅的关闭channel 关闭一个已关闭的通道会引起Panic 将值发送到已关闭的通道会发生Panic  解决办法：1234567891011121314151617181920212223package mainimport &quot;fmt&quot;func IsClose">
<meta name="twitter:image" content="http://chiqtv.cn/2019/07/01/深入浅出channel-select/zzz.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://chiqtv.cn/2019/07/01/深入浅出channel-select/">





  <title>深入浅出channel/select | 三余无梦生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三余无梦生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://chiqtv.cn/2019/07/01/深入浅出channel-select/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入浅出channel/select</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-01T14:48:37+08:00">
                2019-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>浏览
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="深入浅出channel-select"><a href="#深入浅出channel-select" class="headerlink" title="深入浅出channel/select"></a>深入浅出channel/select</h2><blockquote>
<p><strong>go的编程哲学：不要通过共享内存的方式进行通信，而是应该通过通信的方式共享内存</strong></p>
</blockquote>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/zzz.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/xxx.png" alt></p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><h3 id="优雅的关闭channel"><a href="#优雅的关闭channel" class="headerlink" title="优雅的关闭channel"></a>优雅的关闭channel</h3><ol>
<li>关闭一个已关闭的通道会引起Panic</li>
<li>将值发送到已关闭的通道会发生Panic</li>
</ol>
<h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IsClosed</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	fmt.Println(IsClosed(c)) <span class="comment">// false</span></span><br><span class="line">	<span class="built_in">close</span>(c)</span><br><span class="line">	fmt.Println(IsClosed(c)) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">API server listening at: <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8248</span></span><br><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="问题-并发安全的问题"><a href="#问题-并发安全的问题" class="headerlink" title="问题:并发安全的问题"></a>问题:并发安全的问题</h3><h4 id="简单粗暴的方法"><a href="#简单粗暴的方法" class="headerlink" title="简单粗暴的方法"></a>简单粗暴的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeClose</span><span class="params">(ch <span class="keyword">chan</span> T)</span> <span class="params">(justClosed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// The return result can be altered</span></span><br><span class="line">            <span class="comment">// in a defer function call.</span></span><br><span class="line">            justClosed = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// assume ch != nil here.</span></span><br><span class="line">    <span class="built_in">close</span>(ch)   <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> <span class="comment">// &lt;=&gt; justClosed = true; return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SafeSend</span><span class="params">(ch <span class="keyword">chan</span> T, value T)</span> <span class="params">(closed <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">recover</span>() != <span class="literal">nil</span> &#123;</span><br><span class="line">            closed = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    ch &lt;- value  <span class="comment">// panic if ch is closed</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> <span class="comment">// &lt;=&gt; closed = false; return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="带来的问题"><a href="#带来的问题" class="headerlink" title="带来的问题"></a>带来的问题</h3><ol>
<li><p>recover性能影响，</p>
</li>
<li><p>使用场景有限</p>
</li>
</ol>
<h3 id="更多人采用的方式-sync-Once"><a href="#更多人采用的方式-sync-Once" class="headerlink" title="更多人采用的方式 sync.Once/"></a>更多人采用的方式 sync.Once/</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C    <span class="keyword">chan</span> T</span><br><span class="line">    once sync.Once</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyChannel <span class="keyword">struct</span> &#123;</span><br><span class="line">    C      <span class="keyword">chan</span> T</span><br><span class="line">    closed <span class="keyword">bool</span></span><br><span class="line">    mutex  sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMyChannel</span><span class="params">()</span> *<span class="title">MyChannel</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MyChannel&#123;C: <span class="built_in">make</span>(<span class="keyword">chan</span> T)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">SafeClose</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">if</span> !mc.closed &#123;</span><br><span class="line">        <span class="built_in">close</span>(mc.C)</span><br><span class="line">        mc.closed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mc *MyChannel)</span> <span class="title">IsClosed</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    mc.mutex.Lock()</span><br><span class="line">    <span class="keyword">defer</span> mc.mutex.Unlock()</span><br><span class="line">    <span class="keyword">return</span> mc.closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更优雅的方案"><a href="#更优雅的方案" class="headerlink" title="更优雅的方案"></a>更优雅的方案</h3><ol>
<li>N 个接收者，一个发送者，发送者通过关闭通道说不再发送</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 100 缓冲 int</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the sender</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> value := rand.Intn(MaxRandomNumber); value == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// The only sender can close the channel safely.</span></span><br><span class="line">				<span class="built_in">close</span>(dataCh)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dataCh &lt;- value</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line">			<span class="comment">// Receive values until dataCh is closed and</span></span><br><span class="line">			<span class="comment">// the value buffer queue of dataCh is empty.</span></span><br><span class="line">			<span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">				log.Println(value)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关闭原则：发送者处关闭</strong></p>
<ol start="2">
<li><h5 id="一个接收者，N个发送者"><a href="#一个接收者，N个发送者" class="headerlink" title="一个接收者，N个发送者"></a>一个接收者，N个发送者</h5></li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">	<span class="comment">// Its sender is the receiver of channel dataCh.</span></span><br><span class="line">	<span class="comment">// Its reveivers are the senders of channel dataCh.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- rand.Intn(MaxRandomNumber):</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// the receiver</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> value := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">			<span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="built_in">close</span>(stopCh)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line">			log.Println(value)</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭原则:</p>
<ol>
<li>dataCh可以不必关闭，让系统进行垃圾回收。</li>
<li>引入额外的信号通道，以通知发送者停止发送。</li>
</ol>
<ol start="3">
<li><h5 id="M-个接收者，N-个发送者"><a href="#M-个接收者，N-个发送者" class="headerlink" title="M 个接收者，N 个发送者"></a>M 个接收者，N 个发送者</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"math/rand"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line">	log.SetFlags(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">const</span> MaxRandomNumber = <span class="number">100000</span></span><br><span class="line">	<span class="keyword">const</span> NumReceivers = <span class="number">10</span></span><br><span class="line">	<span class="keyword">const</span> NumSenders = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">	wgReceivers := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wgReceivers.Add(NumReceivers)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br><span class="line">	stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// stopCh is an additional signal channel.</span></span><br><span class="line">	<span class="comment">// Its sender is the moderator goroutine shown below.</span></span><br><span class="line">	<span class="comment">// Its reveivers are all senders and receivers of dataCh.</span></span><br><span class="line">	toStop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="comment">// The channel toStop is used to notify the moderator</span></span><br><span class="line">	<span class="comment">// to close the additional signal channel (stopCh).</span></span><br><span class="line">	<span class="comment">// Its senders are any senders and receivers of dataCh.</span></span><br><span class="line">	<span class="comment">// Its reveiver is the moderator goroutine shown below.</span></span><br><span class="line">	<span class="comment">// It must be a buffered channel.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> stoppedBy <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// moderator</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		stoppedBy = &lt;-toStop</span><br><span class="line">		<span class="built_in">close</span>(stopCh)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// senders</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumSenders; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				value := rand.Intn(MaxRandomNumber)</span><br><span class="line">				<span class="keyword">if</span> value == <span class="number">0</span> &#123;</span><br><span class="line">					<span class="comment">// Here, the try-send operation is to notify the</span></span><br><span class="line">					<span class="comment">// moderator to close the additional signal channel.</span></span><br><span class="line">					<span class="keyword">select</span> &#123;</span><br><span class="line">					<span class="keyword">case</span> toStop &lt;- <span class="string">"sender#"</span> + id:</span><br><span class="line">					<span class="keyword">default</span>:</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// The try-receive operation here is to try to exit the</span></span><br><span class="line">				<span class="comment">// sender goroutine as early as possible. Try-receive</span></span><br><span class="line">				<span class="comment">// try-send select blocks are specially optimized by the</span></span><br><span class="line">				<span class="comment">// standard Go compiler, so they are very efficient.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Even if stopCh is closed, the first branch in this</span></span><br><span class="line">				<span class="comment">// select block may be still not selected for some</span></span><br><span class="line">				<span class="comment">// loops (and for ever in theory) if the send to dataCh</span></span><br><span class="line">				<span class="comment">// is also non-blocking. If this is not acceptable,</span></span><br><span class="line">				<span class="comment">// then the above try-receive operation is essential.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> dataCh &lt;- value:</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// receivers</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NumReceivers; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wgReceivers.Done()</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="comment">// Same as the sender goroutine, the try-receive</span></span><br><span class="line">				<span class="comment">// operation here is to try to exit the receiver</span></span><br><span class="line">				<span class="comment">// goroutine as early as possible.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Even if stopCh is closed, the first branch in this</span></span><br><span class="line">				<span class="comment">// select block may be still not selected for some</span></span><br><span class="line">				<span class="comment">// loops (and for ever in theory) if the receive from</span></span><br><span class="line">				<span class="comment">// dataCh is also non-blocking. If this is not acceptable,</span></span><br><span class="line">				<span class="comment">// then the above try-receive operation is essential.</span></span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> value := &lt;-dataCh:</span><br><span class="line">					<span class="keyword">if</span> value == MaxRandomNumber<span class="number">-1</span> &#123;</span><br><span class="line">						<span class="comment">// The same trick is used to notify</span></span><br><span class="line">						<span class="comment">// the moderator to close the</span></span><br><span class="line">						<span class="comment">// additional signal channel.</span></span><br><span class="line">						<span class="keyword">select</span> &#123;</span><br><span class="line">						<span class="keyword">case</span> toStop &lt;- <span class="string">"receiver#"</span> + id:</span><br><span class="line">							log.Println(id)</span><br><span class="line">						<span class="keyword">default</span>:</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span></span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					<span class="comment">//	log.Println(value)</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	wgReceivers.Wait()</span><br><span class="line">	log.Println(<span class="string">"stopped by"</span>, stoppedBy)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭原则:</p>
<ol>
<li>引入哨兵来保障toStop，通道并非一定要关闭</li>
</ol>
</li>
</ol>
<blockquote>
<ol>
<li><p>不到在接收端关闭通道，发送者如果只有一个，就在发送端关闭，关闭之后并不影响通道消息的接收</p>
</li>
<li><p>不要关闭多个并发下的channel</p>
</li>
</ol>
</blockquote>
<p>###源码分析</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">	qcount   <span class="keyword">uint</span>           <span class="comment">// 队列中的数据个数</span></span><br><span class="line">	dataqsiz <span class="keyword">uint</span>           <span class="comment">//缓冲期数据大小</span></span><br><span class="line">	buf      unsafe.Pointer <span class="comment">// 指向缓冲期数据指针</span></span><br><span class="line">	elemsize <span class="keyword">uint16</span>   <span class="comment">//channel大小</span></span><br><span class="line">	closed   <span class="keyword">uint32</span>   <span class="comment">//状态</span></span><br><span class="line">	elemtype *_type <span class="comment">// channel类型</span></span><br><span class="line">	sendx    <span class="keyword">uint</span>   <span class="comment">// 标识当前 Channel 送的已经处理到了数组中的哪个位置。</span></span><br><span class="line">	recvx    <span class="keyword">uint</span>   <span class="comment">// 标识当前 Channel 接收已经处理到了数组中的哪个位置。</span></span><br><span class="line">	recvq    waitq  <span class="comment">// 存储当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表</span></span><br><span class="line">	sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">	<span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Do not change another G's status while holding this lock</span></span><br><span class="line">	<span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">	<span class="comment">// with stack shrinking.</span></span><br><span class="line">	lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sudog的双向链表</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">	first *sudog  <span class="comment">//表示一个在等待列表中的 Goroutine，对g的封装</span></span><br><span class="line">	last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">	g *g</span><br><span class="line"></span><br><span class="line">	<span class="comment">// isSelect indicates g is participating in a select, so</span></span><br><span class="line">	<span class="comment">// g.selectDone must be CAS'd to win the wake-up race.</span></span><br><span class="line">	isSelect <span class="keyword">bool</span></span><br><span class="line">	next     *sudog</span><br><span class="line">	prev     *sudog</span><br><span class="line">	elem     unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// The following fields are never accessed concurrently.</span></span><br><span class="line">	<span class="comment">// For channels, waitlink is only accessed by g.</span></span><br><span class="line">	<span class="comment">// For semaphores, all fields (including the ones above)</span></span><br><span class="line">	<span class="comment">// are only accessed when holding a semaRoot lock.</span></span><br><span class="line"></span><br><span class="line">	acquiretime <span class="keyword">int64</span></span><br><span class="line">	releasetime <span class="keyword">int64</span></span><br><span class="line">	ticket      <span class="keyword">uint32</span></span><br><span class="line">	parent      *sudog <span class="comment">// semaRoot binary tree</span></span><br><span class="line">	waitlink    *sudog <span class="comment">// g.waiting list or semaRoot</span></span><br><span class="line">	waittail    *sudog <span class="comment">// semaRoot</span></span><br><span class="line">	c           *hchan <span class="comment">// channel</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/uuu.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ooo.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ppp.png" alt></p>
<blockquote>
<p>通过两个游标（其实就是读取、接收数据的位置）来确定数据的位置，对应sendx/recvx</p>
<p>速度快，预先读取，类型唯一，大小固定</p>
</blockquote>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/vvvvv.png" alt></p>
<blockquote>
<p>两个双向链表(sendq、recvq)和一个环状队列(buf 基于数组的指针存储)来实现的</p>
</blockquote>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/bbbbb.png" alt></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//typecheck.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typecheck1</span><span class="params">(n *Node, top <span class="keyword">int</span>)</span> <span class="params">(res *Node)</span> <span class="title">case</span> <span class="title">OMAKE</span>:     <span class="title">n</span>.<span class="title">Op</span> = <span class="title">OMAKECHAN</span> </span></span><br><span class="line"><span class="function">//<span class="title">walk</span>.<span class="title">go</span>  </span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span>    <span class="title">case</span> <span class="title">OMAKECHAN</span>:   <span class="title">makechan</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">	elem := t.elem</span><br><span class="line"></span><br><span class="line">	<span class="comment">// compiler checks this but be safe.</span></span><br><span class="line">	<span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">		throw(<span class="string">"makechan: invalid channel element type"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">		throw(<span class="string">"makechan: bad alignment"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mem, overflow := math.MulUintptr(elem.size, <span class="keyword">uintptr</span>(size))</span><br><span class="line">	<span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"makechan: size out of range"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line">	<span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line">	<span class="comment">// SudoG's are referenced from their owning thread so they can't be collected.</span></span><br><span class="line">	<span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line">	<span class="keyword">var</span> c *hchan</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Queue or element size is zero.</span></span><br><span class="line">    <span class="comment">//缓冲区大小为0</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		<span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">		c.buf = c.raceaddr()</span><br><span class="line">	<span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line">		<span class="comment">// Elements do not contain pointers.</span></span><br><span class="line">		<span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">    <span class="comment">//连续内存空间</span></span><br><span class="line">		c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">		c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="comment">// Elements contain pointers.</span></span><br><span class="line">    <span class="comment">//指针类型</span></span><br><span class="line">		c = <span class="built_in">new</span>(hchan)</span><br><span class="line">		c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c.elemsize = <span class="keyword">uint16</span>(elem.size)</span><br><span class="line">	c.elemtype = elem</span><br><span class="line">	c.dataqsiz = <span class="keyword">uint</span>(size)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"makechan: chan="</span>, c, <span class="string">"; elemsize="</span>, elem.size, <span class="string">"; elemalg="</span>, elem.alg, <span class="string">"; dataqsiz="</span>, size, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####发送ch &lt;- i(往channel写)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//walk.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span>    <span class="title">case</span> <span class="title">OSEND</span>:   <span class="title">chansend</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">chan</span>.<span class="title">go</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是阻塞模式，就直接退出</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">// 情况1：当 chan 为 nil时, 阻塞,让出协程</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chansend: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line">	<span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line">	<span class="comment">// Because a closed channel cannot transition from 'ready for sending' to</span></span><br><span class="line">	<span class="comment">// 'not ready for sending', even if the channel is closed between the two observations,</span></span><br><span class="line">	<span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line">	<span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line">	<span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line">	<span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line">	<span class="comment">// channel wasn't closed during the first observation.</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">		(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lock(&amp;c.lock)  <span class="comment">//合法性检查完，锁住整个channel</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//向关闭的channel发送，抛出panic</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//情况2：如果当有 G 在接受队列上等待时，直接将消息发送给 G，</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line">		<span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">    <span class="comment">// send中有个goready(gp, skip+1)可以唤醒 G</span></span><br><span class="line">		send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//情况3缓存队列未满，则将消息复制到缓存队列上</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">		<span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">   <span class="comment">// 通过sendx确定可放入数据的位置， qp其实就是当前这条数据放入的位置</span></span><br><span class="line">		qp := chanbuf(c, c.sendx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//底层依赖于内存屏障来进行数据的拷贝操作</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">		c.sendx++</span><br><span class="line">   <span class="comment">// 这里面就是环状队列实现的关键点， 当发送指针等于队列长度就移位到0</span></span><br><span class="line">		<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">			c.sendx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount++</span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// 如果不是阻塞模式，就直接退出，什么时候会走到这里？，感觉是打了一个补丁</span></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">  <span class="comment">// 获取当前的goroutine</span></span><br><span class="line"> <span class="comment">//情况4： 缓存队列已满，将 G 加入到 send队列中</span></span><br><span class="line">	gp := getg()</span><br><span class="line">  <span class="comment">// 从当前m里面获取一个sudog,注意m里面如果不存在就会从当前m对应的p里面获取，如果还没有，就创建一个新的</span></span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	c.sendq.enqueue(mysg)</span><br><span class="line">  <span class="comment">// 将当前goroutine放入到sendq队列中，然后调用goparkunlock，通过gopark将当前goroutine暂停，然后释放锁</span></span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line">	<span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line">	<span class="comment">// stack object, but sudogs aren't considered as roots of the</span></span><br><span class="line">	<span class="comment">// stack tracer.</span></span><br><span class="line">	KeepAlive(ep)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up.</span></span><br><span class="line">  <span class="comment">// 被唤醒, 检查是否是被closechan唤醒，如果是就抛出异常,</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">"chansend: spurious wakeup"</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">  <span class="comment">//释放G</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/mmm.png" alt></p>
<p>同步情况下</p>
<p>查看Hchan结构体是否为空，步骤1，即是否有因为读该管道而阻塞的goroutine。</p>
<p>情况1，没有等待的g，阻塞，</p>
<p>情况2，又等待的g，直接走1.x流程，从目标带走目标，两种情况都是不带缓冲的channel</p>
<p>带缓冲的情况:</p>
<p>情况3，buf未满，丢如buf，走2.x</p>
<p>情况4，buf满的情况下阻塞，等待唤醒，唤醒之后检查状态，走3.x</p>
<h4 id="接收x-lt-ch-从channel读"><a href="#接收x-lt-ch-从channel读" class="headerlink" title="接收x &lt;- ch(从channel读)"></a>接收x &lt;- ch(从channel读)</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// raceenabled: don't need to check ep, as it is always on the stack</span></span><br><span class="line">	<span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugChan &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"chanrecv: chan="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//nil状态的chan，阻塞</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line">		<span class="keyword">if</span> !block &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//阻塞，nil的chan，挂起goroutine</span></span><br><span class="line">		gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">		throw(<span class="string">"unreachable"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line">	<span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line">	<span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line">	<span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line">	<span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line">	<span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line">	<span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line">	<span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">  <span class="comment">//带缓存，无数据，未关闭channel，直接返回(false, false)</span></span><br><span class="line">	<span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">		c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//同步锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">  </span><br><span class="line">	<span class="comment">//向close且为空的chan中获取消息时，返回空值。</span></span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, ep)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//send 队列不为空,什么时候send队列不为空呢？ 只有两种可能 1. 无缓存chan  2. 缓存队列已满</span></span><br><span class="line">	<span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line">		<span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line">		<span class="comment">// and add sender's value to the tail of the queue (both map to</span></span><br><span class="line">		<span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">    <span class="comment">// CASE 2.1: 无缓存chan,直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line">    <span class="comment">// CASE 2.2: 缓存队列已满, 从队列获取头元素,唤醒send 将其消息加入队列尾部</span></span><br><span class="line">    <span class="comment">//（由于是环线队列，所以尾部和头部是同一位置）移动recvx</span></span><br><span class="line">    <span class="comment">// 同样在recv中有goready(gp, skip+1)可以唤醒G</span></span><br><span class="line">		recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 缓存队列不会空，直接从队列获取元素，移动头索引</span></span><br><span class="line">	<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Receive directly from queue</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		typedmemclr(c.elemtype, qp)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.qcount--</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !block &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">  <span class="comment">// 缓存队列为空， 将当前 G 加入接收队列中， 休眠</span></span><br><span class="line">	gp := getg()</span><br><span class="line">	mysg := acquireSudog()</span><br><span class="line">	mysg.releasetime = <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">		mysg.releasetime = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line">	<span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">	mysg.elem = ep</span><br><span class="line">	mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">	gp.waiting = mysg</span><br><span class="line">	mysg.g = gp</span><br><span class="line">	mysg.isSelect = <span class="literal">false</span></span><br><span class="line">	mysg.c = c</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将当前 G 加入 接收队列中</span></span><br><span class="line">	c.recvq.enqueue(mysg)</span><br><span class="line">  <span class="comment">// 休眠</span></span><br><span class="line">	goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// someone woke us up</span></span><br><span class="line">	<span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">		throw(<span class="string">"G waiting list is corrupted"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	closed := gp.param == <span class="literal">nil</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	mysg.c = <span class="literal">nil</span></span><br><span class="line">	releaseSudog(mysg)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recv processes a receive operation on a full channel c.</span></span><br><span class="line"><span class="comment">// There are 2 parts:</span></span><br><span class="line"><span class="comment">// 1) The value sent by the sender sg is put into the channel</span></span><br><span class="line"><span class="comment">//    and the sender is woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// 2) The value received by the receiver (the current G) is</span></span><br><span class="line"><span class="comment">//    written to ep.</span></span><br><span class="line"><span class="comment">// For synchronous channels, both values are the same.</span></span><br><span class="line"><span class="comment">// For asynchronous channels, the receiver gets its data from</span></span><br><span class="line"><span class="comment">// the channel buffer and the sender's data is put in the</span></span><br><span class="line"><span class="comment">// channel buffer.</span></span><br><span class="line"><span class="comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller's stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span>, <span class="title">skip</span> <span class="title">int</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			racesync(c, sg)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// copy data from sender</span></span><br><span class="line">			recvDirect(c.elemtype, sg, ep)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line">		<span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line">		<span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line">		<span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">		qp := chanbuf(c, c.recvx)</span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquire(qp)</span><br><span class="line">			racerelease(qp)</span><br><span class="line">			raceacquireg(sg.g, qp)</span><br><span class="line">			racereleaseg(sg.g, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// copy data from queue to receiver</span></span><br><span class="line">		<span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// copy data from sender to queue</span></span><br><span class="line">		typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">		c.recvx++</span><br><span class="line">		<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">			c.recvx = <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">	&#125;</span><br><span class="line">	sg.elem = <span class="literal">nil</span></span><br><span class="line">	gp := sg.g</span><br><span class="line">	unlockf()</span><br><span class="line">	gp.param = unsafe.Pointer(sg)</span><br><span class="line">	<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">		sg.releasetime = cputicks()</span><br><span class="line">	&#125;</span><br><span class="line">	goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5种不同的情况：</p>
<ol>
<li>nil状态的chan，阻塞，申明未初始化的状态，初始化内存后继续</li>
<li>带缓存，无数据，被关闭的channel，直接返回</li>
<li><p>send 队列不为空的情况，recv处理两者情况</p>
<ol>
<li><p>不带缓存的 ，send获取数据</p>
</li>
<li><p>带缓存 ，缓存已满 ，从队列获取头元素</p>
</li>
</ol>
</li>
<li>send为空，缓存队列不会空，直接从队列获取元素，移动头索引</li>
<li>sned为空，缓存队列为空，将当前 G 加入接收队列中， 休眠</li>
</ol>
<h4 id="关闭closed"><a href="#关闭closed" class="headerlink" title="关闭closed"></a>关闭closed</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line"><span class="comment">// 关闭一个 nil channel，panic</span></span><br><span class="line">	<span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of nil channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//上锁</span></span><br><span class="line">	lock(&amp;c.lock)</span><br><span class="line">	<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;c.lock)</span><br><span class="line">		<span class="built_in">panic</span>(plainError(<span class="string">"close of closed channel"</span>))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		callerpc := getcallerpc()</span><br><span class="line">		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">		racerelease(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//修改状态</span></span><br><span class="line">	c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all readers</span></span><br><span class="line">   <span class="comment">// 将 channel 所有等待接收队列的里 sudog 释放</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">     <span class="comment">// 从接收队列里出队一个 sudog</span></span><br><span class="line">		sg := c.recvq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">			sg.elem = <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// release all writers (they will panic)</span></span><br><span class="line">  <span class="comment">// 将 channel 等待发送队列里的 sudog 释放</span></span><br><span class="line">  <span class="comment">// 如果存在，这些 goroutine 将会 panic，想关闭的chan发送数据</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		sg := c.sendq.dequeue()</span><br><span class="line">		<span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.elem = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = cputicks()</span><br><span class="line">		&#125;</span><br><span class="line">		gp := sg.g</span><br><span class="line">		gp.param = <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">			raceacquireg(gp, c.raceaddr())</span><br><span class="line">		&#125;</span><br><span class="line">		glist.push(gp)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Ready all Gs now that we've dropped the channel lock.</span></span><br><span class="line">  <span class="comment">// 遍历链表,唤醒</span></span><br><span class="line">	<span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">		gp := glist.pop()</span><br><span class="line">		gp.schedlink = <span class="number">0</span></span><br><span class="line">		goready(gp, <span class="number">3</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>上锁</p>
</li>
<li><p>设置状态，关闭状态</p>
</li>
<li><p>接着把所有挂在这个 channel 上的 sender 和 receiver 全都连成一个 sudog 链表</p>
</li>
<li><p>解锁</p>
</li>
<li><p>所有的 sudog 全都唤醒执行(发送的sender出panic，receiver正常)</p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/iii.png" alt></p>
</li>
</ol>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>###定义：监听多个channel的读写事件，只能和通道连用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">example</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 准备好几个通道。</span></span><br><span class="line">	intChannels := [<span class="number">3</span>]<span class="keyword">chan</span> <span class="keyword">int</span>&#123;</span><br><span class="line">		<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">		<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 随机选择一个通道，并向它发送元素值。</span></span><br><span class="line">	index := rand.Intn(<span class="number">1</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"The index: %d\n"</span>, index)</span><br><span class="line">	intChannels[index] &lt;- index</span><br><span class="line">	<span class="comment">// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。</span></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"default"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-intChannels[<span class="number">0</span>]:</span><br><span class="line">		fmt.Println(<span class="string">"11111111111"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-intChannels[<span class="number">1</span>]:</span><br><span class="line">		fmt.Println(<span class="string">"2222222222"</span>)</span><br><span class="line">	<span class="keyword">case</span> elem := &lt;-intChannels[<span class="number">2</span>]:</span><br><span class="line">		fmt.Printf(<span class="string">"3333333"</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###使用规则和注意点：</p>
<ol>
<li><p>如果select存在默认分支，select就不会被阻塞，默认分支只能有一个，默认分支可以任何位置。</p>
</li>
<li><p>没有默认分支，select被阻塞，直到有一个case表达式满足条件，这个时候select才会被唤醒执行；</p>
<p>Ps： 如果外层有for语句的，break是无法跳出的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func example2() &#123;</span><br><span class="line">	intChan := make(chan int, 1)</span><br><span class="line">	// 一秒后关闭通道。</span><br><span class="line">	time.AfterFunc(time.Second, func() &#123;</span><br><span class="line">		close(intChan)</span><br><span class="line">	&#125;)</span><br><span class="line">	select &#123;</span><br><span class="line">	case _, ok := &lt;-intChan:</span><br><span class="line">		if !ok &#123;</span><br><span class="line">			fmt.Println(&quot;通道关闭&quot;)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>select语句里面的case表达式求值顺序是从上到下，从左到右</p>
</li>
<li>多个case满足条件的时候，是随机选一个，伪随机算法</li>
<li>要关注表达式和语句本身是否有并发安全的问题。</li>
</ol>
<p>###源码分析</p>
<p>src/runtime/select.go</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const (</span><br><span class="line">  selectDir = iota  /// 0 ：表示case 为nil；在send 或者 recv 发生在一个 nil channel 上,通道如果已经关闭，屏蔽分支，设置为nil</span><br><span class="line">  selectSend              // case Chan &lt;- Send 接收通道</span><br><span class="line">  selectRecv              // case &lt;-Chan:  发送通道</span><br><span class="line">  selectDefault           // default</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//选择器的核心结构</span><br><span class="line">type runtimeSelect struct &#123;</span><br><span class="line">	dir selectDir</span><br><span class="line">	typ unsafe.Pointer // channel type (not used here)</span><br><span class="line">	ch  *hchan         // 指向每个case里面的chan操作</span><br><span class="line">	val unsafe.Pointer // 发送或者接收数据缓冲区</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//select每一条case的描述</span><br><span class="line">type scase struct &#123;</span><br><span class="line">	c           *hchan         // 当前case所对应的chan引用，一个case只对应一个chan</span><br><span class="line">	elem        unsafe.Pointer // 读或者些的缓冲区数据指针</span><br><span class="line">	kind        uint16 //类型读，写，默认</span><br><span class="line">	pc          uintptr // 用于指示当前将要执行的下一条机器指令的内存地址</span><br><span class="line">	releasetime int64</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###源码执行顺序</p>
<p>/refect/value.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Select executes a select operation described by the list of cases.</span></span><br><span class="line"><span class="comment">// Like the Go select statement, it blocks until at least one of the cases</span></span><br><span class="line"><span class="comment">// can proceed, makes a uniform pseudo-random choice,</span></span><br><span class="line"><span class="comment">// and then executes that case. It returns the index of the chosen case</span></span><br><span class="line"><span class="comment">// and, if that case was a receive operation, the value received and a</span></span><br><span class="line"><span class="comment">// boolean indicating whether the value corresponds to a send on the channel</span></span><br><span class="line"><span class="comment">// (as opposed to a zero value received because the channel is closed).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Select</span><span class="params">(cases []SelectCase)</span> <span class="params">(chosen <span class="keyword">int</span>, recv Value, recvOK <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> Do not trust that caller is not modifying cases data underfoot.</span></span><br><span class="line">	<span class="comment">// The range is safe because the caller cannot modify our copy of the len</span></span><br><span class="line">	<span class="comment">// and each iteration makes its own copy of the value c.</span></span><br><span class="line">	runcases := <span class="built_in">make</span>([]runtimeSelect, <span class="built_in">len</span>(cases))</span><br><span class="line">	haveDefault := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> i, c := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		rc := &amp;runcases[i]</span><br><span class="line">		rc.dir = c.Dir</span><br><span class="line">		<span class="keyword">switch</span> c.Dir &#123;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">panic</span>(<span class="string">"reflect.Select: invalid Dir"</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SelectDefault: <span class="comment">// default</span></span><br><span class="line">			<span class="keyword">if</span> haveDefault &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: multiple default cases"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			haveDefault = <span class="literal">true</span></span><br><span class="line">			<span class="keyword">if</span> c.Chan.IsValid() &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: default case has Chan value"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.Send.IsValid() &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: default case has Send value"</span>)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SelectSend:</span><br><span class="line">			ch := c.Chan</span><br><span class="line">			<span class="keyword">if</span> !ch.IsValid() &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ch.mustBe(Chan)</span><br><span class="line">			ch.mustBeExported()</span><br><span class="line">			tt := (*chanType)(unsafe.Pointer(ch.typ))</span><br><span class="line">			<span class="keyword">if</span> ChanDir(tt.dir)&amp;SendDir == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: SendDir case using recv-only channel"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			rc.ch = ch.pointer()</span><br><span class="line">			rc.typ = &amp;tt.rtype</span><br><span class="line">			v := c.Send</span><br><span class="line">			<span class="keyword">if</span> !v.IsValid() &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: SendDir case missing Send value"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			v.mustBeExported()</span><br><span class="line">			v = v.assignTo(<span class="string">"reflect.Select"</span>, tt.elem, <span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">if</span> v.flag&amp;flagIndir != <span class="number">0</span> &#123;</span><br><span class="line">				rc.val = v.ptr</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				rc.val = unsafe.Pointer(&amp;v.ptr)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> SelectRecv:</span><br><span class="line">			<span class="keyword">if</span> c.Send.IsValid() &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: RecvDir case has Send value"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			ch := c.Chan</span><br><span class="line">			<span class="keyword">if</span> !ch.IsValid() &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			ch.mustBe(Chan)</span><br><span class="line">			ch.mustBeExported()</span><br><span class="line">			tt := (*chanType)(unsafe.Pointer(ch.typ))</span><br><span class="line">			<span class="keyword">if</span> ChanDir(tt.dir)&amp;RecvDir == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">"reflect.Select: RecvDir case using send-only channel"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			rc.ch = ch.pointer()</span><br><span class="line">			rc.typ = &amp;tt.rtype</span><br><span class="line">			rc.val = unsafe_New(tt.elem)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	chosen, recvOK = rselect(runcases)</span><br><span class="line">	<span class="keyword">if</span> runcases[chosen].dir == SelectRecv &#123;</span><br><span class="line">		tt := (*chanType)(unsafe.Pointer(runcases[chosen].typ))</span><br><span class="line">		t := tt.elem</span><br><span class="line">		p := runcases[chosen].val</span><br><span class="line">		fl := flag(t.Kind())</span><br><span class="line">		<span class="keyword">if</span> ifaceIndir(t) &#123;</span><br><span class="line">			recv = Value&#123;t, p, fl | flagIndir&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			recv = Value&#123;t, *(*unsafe.Pointer)(p), fl&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> chosen, recv, recvOK</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本处的初始化，调用调用rselect</span></span><br></pre></td></tr></table></figure>
<p>runtime/select.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rselect具体实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_rselect</span><span class="params">(cases []runtimeSelect)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//没有case阻塞</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cases) == <span class="number">0</span> &#123;</span><br><span class="line">		block()</span><br><span class="line">	&#125;</span><br><span class="line">	sel := <span class="built_in">make</span>([]scase, <span class="built_in">len</span>(cases))</span><br><span class="line">	order := <span class="built_in">make</span>([]<span class="keyword">uint16</span>, <span class="number">2</span>*<span class="built_in">len</span>(cases))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> cases &#123;</span><br><span class="line">		rc := &amp;cases[i]</span><br><span class="line">		<span class="keyword">switch</span> rc.dir &#123;</span><br><span class="line">		<span class="keyword">case</span> selectDefault:</span><br><span class="line">			sel[i] = scase&#123;kind: caseDefault&#125;</span><br><span class="line">		<span class="keyword">case</span> selectSend:</span><br><span class="line">			sel[i] = scase&#123;kind: caseSend, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">		<span class="keyword">case</span> selectRecv:</span><br><span class="line">			sel[i] = scase&#123;kind: caseRecv, c: rc.ch, elem: rc.val&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> raceenabled || msanenabled &#123;</span><br><span class="line">			selectsetpc(&amp;sel[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> selectgo(&amp;sel[<span class="number">0</span>], &amp;order[<span class="number">0</span>], <span class="built_in">len</span>(cases))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前两步基本上都是初始化之类的，核心实现在selectgo中</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectgo</span><span class="params">(cas0 *scase, order0 *<span class="keyword">uint16</span>, ncases <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"select: cas0="</span>, cas0, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一步</span></span><br><span class="line"><span class="comment"> 1.初始化</span></span><br><span class="line"><span class="comment"> 2.随机生成一个遍历的轮询顺序 pollOrder 并根据 Channel 地址生成一个用于遍历的锁定顺序 lockOrder</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">	cas1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]scase)(unsafe.Pointer(cas0))</span><br><span class="line">	order1 := (*[<span class="number">1</span> &lt;&lt; <span class="number">17</span>]<span class="keyword">uint16</span>)(unsafe.Pointer(order0))</span><br><span class="line"></span><br><span class="line">	scases := cas1[:ncases:ncases]</span><br><span class="line">	pollorder := order1[:ncases:ncases]</span><br><span class="line">	lockorder := order1[ncases:][:ncases:ncases]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Replace send/receive cases involving nil channels with</span></span><br><span class="line">	<span class="comment">// caseNil so logic below can assume non-nil channel.</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> scases &#123;</span><br><span class="line">		cas := &amp;scases[i]</span><br><span class="line">		<span class="keyword">if</span> cas.c == <span class="literal">nil</span> &amp;&amp; cas.kind != caseDefault &#123;</span><br><span class="line">			*cas = scase&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> t0 <span class="keyword">int64</span></span><br><span class="line">	<span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">		t0 = cputicks()</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">			scases[i].releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The compiler rewrites selects that statically have</span></span><br><span class="line">	<span class="comment">// only 0 or 1 cases plus default into simpler constructs.</span></span><br><span class="line">	<span class="comment">// The only way we can end up with such small sel.ncase</span></span><br><span class="line">	<span class="comment">// values here is for a larger select in which most channels</span></span><br><span class="line">	<span class="comment">// have been nilled out. The general code handles those</span></span><br><span class="line">	<span class="comment">// cases correctly, and they are rare enough not to bother</span></span><br><span class="line">	<span class="comment">// optimizing (and needing to test).</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// generate permuted order</span></span><br><span class="line">  <span class="comment">//打乱随机</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		j := fastrandn(<span class="keyword">uint32</span>(i + <span class="number">1</span>))</span><br><span class="line">		pollorder[i] = pollorder[j]</span><br><span class="line">		pollorder[j] = <span class="keyword">uint16</span>(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// sort the cases by Hchan address to get the locking order.</span></span><br><span class="line">	<span class="comment">// simple heap sort, to guarantee n log n time and constant stack footprint.</span></span><br><span class="line">  <span class="comment">// 按 hchan 的地址来进行排序，以生成加锁顺序</span></span><br><span class="line">  <span class="comment">// 用堆排序来保证 nLog(n) 的时间复杂度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">    <span class="comment">// 初始化 lockorder 数组</span></span><br><span class="line">		j := i</span><br><span class="line">		<span class="comment">// Start with the pollorder to permute cases on the same channel.</span></span><br><span class="line">		c := scases[pollorder[i]].c</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &amp;&amp; scases[lockorder[(j<span class="number">-1</span>)/<span class="number">2</span>]].c.sortkey() &lt; c.sortkey() &#123;</span><br><span class="line">			k := (j - <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">			lockorder[j] = lockorder[k]</span><br><span class="line">			j = k</span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = pollorder[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := ncases - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">    <span class="comment">//堆排序</span></span><br><span class="line">		o := lockorder[i]</span><br><span class="line">		c := scases[o].c</span><br><span class="line">		lockorder[i] = lockorder[<span class="number">0</span>]</span><br><span class="line">		j := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			k := j*<span class="number">2</span> + <span class="number">1</span></span><br><span class="line">			<span class="keyword">if</span> k &gt;= i &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> k+<span class="number">1</span> &lt; i &amp;&amp; scases[lockorder[k]].c.sortkey() &lt; scases[lockorder[k+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				k++</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.sortkey() &lt; scases[lockorder[k]].c.sortkey() &#123;</span><br><span class="line">				lockorder[j] = lockorder[k]</span><br><span class="line">				j = k</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		lockorder[j] = o</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i+<span class="number">1</span> &lt; ncases; i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> scases[lockorder[i]].c.sortkey() &gt; scases[lockorder[i+<span class="number">1</span>]].c.sortkey() &#123;</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">"i="</span>, i, <span class="string">" x="</span>, lockorder[i], <span class="string">" y="</span>, lockorder[i+<span class="number">1</span>], <span class="string">"\n"</span>)</span><br><span class="line">				throw(<span class="string">"select: broken sort"</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// lock all the channels involved in the select</span></span><br><span class="line">  <span class="comment">//对所有的channel枷锁</span></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		gp     *g</span><br><span class="line">		sg     *sudog</span><br><span class="line">		c      *hchan</span><br><span class="line">		k      *scase</span><br><span class="line">		sglist *sudog</span><br><span class="line">		sgnext *sudog</span><br><span class="line">		qp     unsafe.Pointer</span><br><span class="line">		nextp  **sudog</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">	<span class="comment">// pass 1 - look for something already waiting</span></span><br><span class="line">	<span class="keyword">var</span> dfli <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> dfl *scase</span><br><span class="line">	<span class="keyword">var</span> casi <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> cas *scase</span><br><span class="line">	<span class="keyword">var</span> recvOK <span class="keyword">bool</span></span><br><span class="line">  <span class="comment">//for遍历，ready的直接goto跳出去</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; ncases; i++ &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(pollorder[i])</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		c = cas.c</span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseNil:</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">      <span class="comment">// &lt;- ch</span></span><br><span class="line">			sg = c.sendq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> recv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufrecv</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> rclose</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">      <span class="comment">//ch &lt;- 1</span></span><br><span class="line">			<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">				racereadpc(c.raceaddr(), cas.pc, chansendpc)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> sclose</span><br><span class="line">			&#125;</span><br><span class="line">			sg = c.recvq.dequeue()</span><br><span class="line">			<span class="keyword">if</span> sg != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">goto</span> send</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">				<span class="keyword">goto</span> bufsend</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseDefault:</span><br><span class="line">			dfli = casi</span><br><span class="line">			dfl = cas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//进了 caseDefault 才会走到</span></span><br><span class="line">	<span class="keyword">if</span> dfl != <span class="literal">nil</span> &#123;</span><br><span class="line">		selunlock(scases, lockorder)</span><br><span class="line">		casi = dfli</span><br><span class="line">		cas = dfl</span><br><span class="line">		<span class="keyword">goto</span> retc</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 2 - enqueue on all chans</span></span><br><span class="line">  <span class="comment">//没有任何一个 case 满足，且没有 default</span></span><br><span class="line">	gp = getg()</span><br><span class="line">	<span class="keyword">if</span> gp.waiting != <span class="literal">nil</span> &#123;</span><br><span class="line">		throw(<span class="string">"gp.waiting != nil"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	nextp = &amp;gp.waiting</span><br><span class="line">  <span class="comment">//按照加锁的顺序把 gorutine 入每一个 channel 的等待队列</span></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		casi = <span class="keyword">int</span>(casei)</span><br><span class="line">		cas = &amp;scases[casi]</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		c = cas.c</span><br><span class="line">		sg := acquireSudog()</span><br><span class="line">		sg.g = gp</span><br><span class="line">		sg.isSelect = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// No stack splits between assigning elem and enqueuing</span></span><br><span class="line">		<span class="comment">// sg on gp.waiting where copystack can find it.</span></span><br><span class="line">		sg.elem = cas.elem</span><br><span class="line">		sg.releasetime = <span class="number">0</span></span><br><span class="line">		<span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">			sg.releasetime = <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		sg.c = c</span><br><span class="line">		<span class="comment">// Construct waiting list in lock order.</span></span><br><span class="line">		*nextp = sg</span><br><span class="line">		nextp = &amp;sg.waitlink</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//不同的类型进入不同的队列</span></span><br><span class="line">		<span class="keyword">switch</span> cas.kind &#123;</span><br><span class="line">		<span class="keyword">case</span> caseRecv:</span><br><span class="line">			c.recvq.enqueue(sg)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> caseSend:</span><br><span class="line">			c.sendq.enqueue(sg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// wait for someone to wake us up</span></span><br><span class="line">  <span class="comment">//当前 goroutine 进入休眠，等待被唤醒</span></span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line">	gopark(selparkcommit, <span class="literal">nil</span>, waitReasonSelect, traceEvGoBlockSelect, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	sellock(scases, lockorder)</span><br><span class="line"></span><br><span class="line">	gp.selectDone = <span class="number">0</span></span><br><span class="line">	sg = (*sudog)(gp.param)</span><br><span class="line">	gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// pass 3 - dequeue from unsuccessful chans</span></span><br><span class="line">	<span class="comment">// otherwise they stack up on quiet channels</span></span><br><span class="line">	<span class="comment">// record the successful case, if any.</span></span><br><span class="line">	<span class="comment">// We singly-linked up the SudoGs in lock order.</span></span><br><span class="line">  <span class="comment">//被唤醒</span></span><br><span class="line">	casi = <span class="number">-1</span></span><br><span class="line">	cas = <span class="literal">nil</span></span><br><span class="line">	sglist = gp.waiting</span><br><span class="line">	<span class="comment">// Clear all elem before unlinking from gp.waiting.</span></span><br><span class="line">	<span class="keyword">for</span> sg1 := gp.waiting; sg1 != <span class="literal">nil</span>; sg1 = sg1.waitlink &#123;</span><br><span class="line">		sg1.isSelect = <span class="literal">false</span></span><br><span class="line">		sg1.elem = <span class="literal">nil</span></span><br><span class="line">		sg1.c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	gp.waiting = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, casei := <span class="keyword">range</span> lockorder &#123;</span><br><span class="line">		k = &amp;scases[casei]</span><br><span class="line">		<span class="keyword">if</span> k.kind == caseNil &#123;</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sglist.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">			k.releasetime = sglist.releasetime</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> sg == sglist &#123;</span><br><span class="line">			<span class="comment">// sg has already been dequeued by the G that woke us up.</span></span><br><span class="line">			casi = <span class="keyword">int</span>(casei)</span><br><span class="line">			cas = k</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			c = k.c</span><br><span class="line">			<span class="keyword">if</span> k.kind == caseSend &#123;</span><br><span class="line">				c.sendq.dequeueSudoG(sglist)</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				c.recvq.dequeueSudoG(sglist)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		sgnext = sglist.waitlink</span><br><span class="line">		sglist.waitlink = <span class="literal">nil</span></span><br><span class="line">		releaseSudog(sglist)</span><br><span class="line">		sglist = sgnext</span><br><span class="line">	&#125;</span><br><span class="line">   <span class="comment">//唤醒的时候，param = nil 没有合适的再次loop</span></span><br><span class="line">	<span class="keyword">if</span> cas == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// We can wake up with gp.param == nil (so cas == nil)</span></span><br><span class="line">		<span class="comment">// when a channel involved in the select has been closed.</span></span><br><span class="line">		<span class="comment">// It is easiest to loop and re-run the operation;</span></span><br><span class="line">		<span class="comment">// we'll see that it's now closed.</span></span><br><span class="line">		<span class="comment">// Maybe some day we can signal the close explicitly,</span></span><br><span class="line">		<span class="comment">// but we'd have to distinguish close-on-reader from close-on-writer.</span></span><br><span class="line">		<span class="comment">// It's easiest not to duplicate the code and just recheck above.</span></span><br><span class="line">		<span class="comment">// We know that something closed, and things never un-close,</span></span><br><span class="line">		<span class="comment">// so we won't block again.</span></span><br><span class="line">		<span class="keyword">goto</span> loop</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	c = cas.c</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"wait-return: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">" cas="</span>, cas, <span class="string">" kind="</span>, cas.kind, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cas.kind == caseRecv &#123;</span><br><span class="line">		recvOK = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.kind == caseRecv &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> cas.kind == caseSend &#123;</span><br><span class="line">			msanread(cas.elem, c.elemtype.size)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufrecv:</span><br><span class="line">	<span class="comment">// can receive from buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">			raceWriteObjectPC(c.elemtype, cas.elem, cas.pc, chanrecvpc)</span><br><span class="line">		&#125;</span><br><span class="line">		raceacquire(chanbuf(c, c.recvx))</span><br><span class="line">		racerelease(chanbuf(c, c.recvx))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &amp;&amp; cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		msanwrite(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	qp = chanbuf(c, c.recvx)</span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemmove(c.elemtype, cas.elem, qp)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemclr(c.elemtype, qp)</span><br><span class="line">	c.recvx++</span><br><span class="line">	<span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">		c.recvx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount--</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">bufsend:</span><br><span class="line">	<span class="comment">// can send to buffer</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(chanbuf(c, c.sendx))</span><br><span class="line">		racerelease(chanbuf(c, c.sendx))</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	typedmemmove(c.elemtype, chanbuf(c, c.sendx), cas.elem)</span><br><span class="line">	c.sendx++</span><br><span class="line">	<span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">		c.sendx = <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	c.qcount++</span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">recv:</span><br><span class="line">	<span class="comment">// can receive from sleeping sender (sg)</span></span><br><span class="line">	recv(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncrecv: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	recvOK = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">rclose:</span><br><span class="line">	<span class="comment">// read at end of closed channel</span></span><br><span class="line">  <span class="comment">//读取关闭的channel</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	recvOK = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> cas.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">		typedmemclr(c.elemtype, cas.elem)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceacquire(c.raceaddr())</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">send:</span><br><span class="line">	<span class="comment">// can send to a sleeping receiver (sg)</span></span><br><span class="line">	<span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">		raceReadObjectPC(c.elemtype, cas.elem, cas.pc, chansendpc)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">		msanread(cas.elem, c.elemtype.size)</span><br><span class="line">	&#125;</span><br><span class="line">	send(c, sg, cas.elem, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; selunlock(scases, lockorder) &#125;, <span class="number">2</span>)</span><br><span class="line">	<span class="keyword">if</span> debugSelect &#123;</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">"syncsend: cas0="</span>, cas0, <span class="string">" c="</span>, c, <span class="string">"\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> retc</span><br><span class="line"></span><br><span class="line">retc:</span><br><span class="line">	<span class="keyword">if</span> cas.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">		blockevent(cas.releasetime-t0, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> casi, recvOK</span><br><span class="line"></span><br><span class="line">sclose:</span><br><span class="line">	<span class="comment">// send on closed channel</span></span><br><span class="line">  <span class="comment">//向关闭的channel发送数据，触发panic</span></span><br><span class="line">	selunlock(scases, lockorder)</span><br><span class="line">	<span class="built_in">panic</span>(plainError(<span class="string">"send on closed channel"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###总结</p>
<ol>
<li><p>初始化，核心就是把case实例打乱</p>
</li>
<li><p>锁住所有的channel</p>
</li>
<li><p>循环，查找准备就绪的channel，四种不同的情况处理 <code>select</code> 中的多个 <code>case</code>：</p>
<ol>
<li><code>caseNil</code> — 当前 <code>case</code> 不包含任何的 Channel，就直接会被跳过；</li>
<li><code>caseRecv</code> — 当前 <code>case</code> 会从 Channel 中接收数据；<ul>
<li>如果当前 Channel 的 <code>sendq</code> 上有等待的 Goroutine 就会直接跳到 <code>recv</code> 标签所在的代码段，从 Goroutine 中获取最新发送的数据；</li>
<li>如果当前 Channel 的缓冲区不为空就会跳到 ` 标签处从缓冲区中获取数据；</li>
<li>如果当前 Channel 已经被关闭就会跳到 <code>rclose</code> 做一些清除的收尾工作；</li>
</ul>
</li>
<li>caseSend — 当前 case 会向 Channel 发送数据；<ul>
<li>如果当前 Channel 已经被关闭就会直接跳到 <code>sclose</code> 代码段；</li>
<li>如果当前 Channel 的 <code>recvq</code> 上有等待的 Goroutine 就会跳到 <code>send</code> 代码段向 Channel 直接发送数据；</li>
</ul>
</li>
</ol>
</li>
<li><p>caseDefault  如果循环执行到了这种情况就表示前面的所有 <code>case</code> 都没有被执行，所以这里会直接解锁所有的 Channel 并退出 <code>selectgo</code> 函数，这时也就意味着当前 <code>select</code> 结构中的其他收发语句都是非阻塞的。</p>
</li>
</ol>
<p>   <img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/111111.png" alt></p>
<ol start="5">
<li><p>阻塞状态，进入下一个循环，加入c.sendq.dequeueSudoG(sglist)/c.recvq.dequeueSudoG(sglist)</p>
</li>
<li><p><code>sudog</code> 结构体都会被串成链表附着在当前 Goroutine 上，在入队之后会调用 <code>gopark</code> 函数挂起当前的 Goroutine 等待调度器的唤醒。</p>
<p>gopark(selparkcommit, nil, waitReasonSelect, traceEvGoBlockSelect, 1)</p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/22222222.png" alt></p>
</li>
<li><p>根据 lockOrder 遍历全部 case 的过程中，我们会先获取 Goroutine 接收到的参数 param，这个参数其实就是被唤醒的 sudog 结构，其他的全部释放掉releaseSudog(sglist)</p>
</li>
<li><p>跳到不同的状态执行</p>
</li>
</ol>
<p>   ####回顾整个过程：</p>
<h3 id><a href="#" class="headerlink" title></a><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/aaa.png" alt></h3><p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/bbb.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ccc.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ddd.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/fff.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/ggg.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/hhh.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/jjj.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/kkk.png" alt></p>
<p><img src="//chiqtv.cn/2019/07/01/深入浅出channel-select/lll.png" alt></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/协程/" rel="tag"># 协程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/01/深入浅出goroutine/" rel="next" title="深入浅出goroutine">
                <i class="fa fa-chevron-left"></i> 深入浅出goroutine
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="三鱼">
            
              <p class="site-author-name" itemprop="name">三鱼</p>
              <p class="site-description motion-element" itemprop="description">挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xyiot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:softstarxy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/5419866199/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#深入浅出channel-select"><span class="nav-number">1.</span> <span class="nav-text">深入浅出channel/select</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel"><span class="nav-number">2.</span> <span class="nav-text">channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优雅的关闭channel"><span class="nav-number">2.1.</span> <span class="nav-text">优雅的关闭channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决办法："><span class="nav-number">2.2.</span> <span class="nav-text">解决办法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题-并发安全的问题"><span class="nav-number">2.3.</span> <span class="nav-text">问题:并发安全的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单粗暴的方法"><span class="nav-number">2.3.1.</span> <span class="nav-text">简单粗暴的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#带来的问题"><span class="nav-number">2.4.</span> <span class="nav-text">带来的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更多人采用的方式-sync-Once"><span class="nav-number">2.5.</span> <span class="nav-text">更多人采用的方式 sync.Once/</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#更优雅的方案"><span class="nav-number">2.6.</span> <span class="nav-text">更优雅的方案</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一个接收者，N个发送者"><span class="nav-number">2.6.0.1.</span> <span class="nav-text">一个接收者，N个发送者</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#M-个接收者，N-个发送者"><span class="nav-number">2.6.0.2.</span> <span class="nav-text">M 个接收者，N 个发送者</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">2.6.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#初始化"><span class="nav-number">2.6.2.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收x-lt-ch-从channel读"><span class="nav-number">2.6.3.</span> <span class="nav-text">接收x &lt;- ch(从channel读)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关闭closed"><span class="nav-number">2.6.4.</span> <span class="nav-text">关闭closed</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#select"><span class="nav-number">3.</span> <span class="nav-text">select</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构-1"><span class="nav-number">3.1.</span> <span class="nav-text">数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">3.2.</span> <span class="nav-text"></span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三鱼</span>
  
</div>









        
<div class="busuanzi-count">
     <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
