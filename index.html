<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="三余无梦生" type="application/atom+xml">






<meta name="description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">
<meta property="og:type" content="website">
<meta property="og:title" content="三余无梦生">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="三余无梦生">
<meta property="og:description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三余无梦生">
<meta name="twitter:description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>三余无梦生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三余无梦生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/begin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/begin/" itemprop="url">缺舟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T18:00:00+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"><a href="#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。" class="headerlink" title="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"></a>思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/01/ssl-pinning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/ssl-pinning/" itemprop="url">ssl pinning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-01T08:59:58+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ssl-pinning-mode"><a href="#ssl-pinning-mode" class="headerlink" title="ssl pinning mode"></a>ssl pinning mode</h1><p>https抓包的问题，工作的一个小争论引发的，不相信https可以抓包分析数据，非要我演示一次。https抓包其实早就已经烂大街，本着用事实说话的方式，安装了Charles，发现竟然有部分如淘宝，支付宝的包无法解析，jd的是正常的，好奇的查了一下，才知道现在有ssl pinning mode这个东西。</p>
<h2 id="简述一下https的连接过程"><a href="#简述一下https的连接过程" class="headerlink" title="简述一下https的连接过程"></a>简述一下https的连接过程</h2><p><img src="/2017/10/01/ssl-pinning/1.gif" alt></p>
<h3 id="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"><a href="#上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。" class="headerlink" title="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"></a>上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。</h3><p>1、client hello和 server hello表示双方要建立一个加密会话。</p>
<p>2、服务器把数字证书传输给客户端，证书中包含服务器公钥，客户端用公钥解析证书中的数字签名，可以验证服务器的身份。</p>
<p>3、Server Hello Done表示hello 流程结束。</p>
<p>4、客户端生成一个对称加密密钥，用于实际数据的加密传输，并用服务器的公钥加密，把对生成的密钥传递给服务器。同时携带一个用刚刚生成的加密密钥加密的“client finished”。</p>
<p>5、服务器收到对称加密密钥，并尝试用该密钥解密加密字段，如能得到明文“client finished”，认为该密钥有效，可以用于之后的数据加密传输。同时用该密钥加密“server finished”，传递给客户端。</p>
<p>6、客户端用对称机密密钥解密，如能得到明文“server finished”，客户端认为该服务器已经正确的接收到对称密钥。</p>
<p>7、加密数据传输开始。</p>
<blockquote>
<p>虚线部分是服务器端要求验证客户身份,和双向认证有关。</p>
</blockquote>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ol>
<li>内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。 </li>
<li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持 </li>
<li>数据完整性。防止内容被第三方冒充或者篡改。</li>
</ol>
<h3 id="带来的问题：中间人攻击（MITM）"><a href="#带来的问题：中间人攻击（MITM）" class="headerlink" title="带来的问题：中间人攻击（MITM）"></a>带来的问题：中间人攻击（MITM）</h3><p><img src="/2017/10/01/ssl-pinning/2.jpeg" alt></p>
<ol>
<li>客户端首先要向远程的服务器发送建立连接的请求，并带有自己的支持的加解密的方式级别，这个过程经过了中间人的窃听，中间人把消息修改后发给了真正的目的地——服务端</li>
<li>服务端收到了要建立https链接的请求后，会发送当时从证书签发机构签发的公钥证书。这个过程中中间人又窃听了，然后中间人替换上自己的证书后又转发给了客户端。</li>
<li>客户端收到了中间人发过来的公钥证书，验证证书的真伪，并产生随机的对称加密的密钥，用中间人发的公钥加密后发给了中间人。由于刚才客户端收到的公钥证书本身就是中间人产生的，所以中间人用相应的私钥就解开了，拿到了客户端产生的那个随机产生的对称加密密钥。中间人再用刚才服务端返回的公钥证书加密这个客户端产生的用来对称加密的密钥，发给服务端。</li>
<li>服务端收到了当时用自己下发的公钥的证书加密的对称加密密钥，用自己的私钥解密，也得到了对称加密的密钥。</li>
</ol>
<blockquote>
<p>用Charles来搞是比较常见的，网上的教程也是一把一把的，大部分https的数据包都的可以解析出来，但是阿里系的不行。</p>
</blockquote>
<h3 id="解决中间人攻击的办法：ssl-pinning-mode"><a href="#解决中间人攻击的办法：ssl-pinning-mode" class="headerlink" title="解决中间人攻击的办法：ssl pinning mode"></a>解决中间人攻击的办法：ssl pinning mode</h3><ol>
<li>简单点说就是：ssl pinning就是client能够把server的证书和一个已知的server的证书的拷贝做对比，通过把server的ssl 证书捆绑到程序中就可以达到目的</li>
<li>如果还是想获取接口请求参数估计只能从客户端逆向入手了，类似于iOS上的Snoop-it一类的工具，网上实际上也有很完整的解决方案了，实际上就是hook的方式将此次校验的结果返回true或者干脆不让其做校验，前提是手机一定要越狱，开源<a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">方案地址</a>，具体原理可以<a href="https://nabla-c0d3.github.io/blog/2016/02/21/ssl-kill-switch-twitter/" target="_blank" rel="noopener">参考</a>。</li>
<li>其实做到https+强制pinning就很少有人搞的动了，还担心就加上双向认证，关键还有就是客户端的代码质量。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/01/Android-Facede/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/01/Android-Facede/" itemprop="url">Android Facede</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-01T08:59:58+08:00">
                2016-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android外观模式的应用"><a href="#Android外观模式的应用" class="headerlink" title="Android外观模式的应用"></a>Android外观模式的应用</h1><pre><code>这是一个`app`最初的项目结构  
</code></pre><p><img src="/2016/08/01/Android-Facede/1.png" alt></p>
<p>所有的页面都放在<code>activities</code>，自定义<code>view</code>放在<code>widget</code>，网络相关的封装在<code>network</code>，所有工具类放在<code>utils</code>，少数的<code>xxxManager</code>单例藏在某个包下面，因为少没必要过度提炼就这样吧…<br>没什么问题，项目上线！  </p>
<p>随着项目迭代，越来越多的页面来了，数据库的表也多起来了，工具类更是爆炸性增长，还不排除有些工具类还在<code>activity</code>里面没来得及提炼出来，<code>xxxManager</code>散落一地，<code>callback</code>到处都是…各个包的类都在快速增长</p>
<p>如果用线来表示相互间的调用，那么整个项目就是一个毛线团，找代码都开始难找了<br>那么这时候就改理一理这个线团了</p>
<p>之前app没有一个明确的职责分层，横向依赖很严重，小改伤筋动骨</p>
<h5 id="AppContext与外观模式的应用"><a href="#AppContext与外观模式的应用" class="headerlink" title="AppContext与外观模式的应用"></a>AppContext与外观模式的应用</h5><p>随着业务的发展，<code>app</code>里面的组件，业务线也会逐渐的增多。<br>每个业务线一个<code>module</code>，那么新的问题就来了，<code>module</code>之间的通信问题，横向依赖问题。  </p>
<p>每个<code>module</code>除了在自己的地盘处理业务，还有可能给其他module提供服务，或者这个<code>module</code>就是一个<code>plugin</code>风格的业务组件。<br>比较粗暴的做法，直接引用<code>module</code>，想调谁就引用谁，那么这和之前单<code>module</code>，类的横向引用又有什么本质上的区别呢？<br>这里我们可以借鉴下<code>Android</code>的<code>Context</code>类的设计，<code>Context</code>就是封装了一大堆<code>Android</code>的子系统（通过<code>getSystemService</code>获取），处理在Android环境下的通信问题。<br>那么我们可以依葫芦画瓢的设计一个我们自己的<code>AppContext</code>，我们的业务<code>module</code>或者组件都是在<code>AppContext</code>环境下，他们之间的通信就通过<code>AppContext</code>，具体业务就交给具体的<code>modul</code>e实现.<br>如果设计多个业务<code>module</code>的协作，那么也应该由<code>AppContext</code>屏蔽协作的细节，这是一个很典型的外观模式的应用。<br>在面向对象编程范式内，很多问题都可以通过引入额外的一层来解决<br><img src="/2016/08/01/Android-Facede/2.png" alt>  </p>
<p>有些基础组件<code>module</code>或通用性非常高的<code>module</code>，可以下沉到<code>AppContext</code>下面</p>
<p><code>AppContext</code>的核心职责就是封装好<code>app</code>所用到的子系统（审视下以前代码里面的单例<code>manager</code>，思考一下他是不是能作为<code>app</code>的一个子系统工作）来统一管理服务，无论该服务是基于<code>Android</code>，还是业务<code>module</code>，还是其他第三方组件。当然这里也应该<code>module</code>与<code>app</code>通信，一些app级别的配置也可以在这里处理</p>
<p>在实际操作中，一定要渐进式的处理，主要是因为：</p>
<ul>
<li>互联网时代不能让飞机停下来，做到在天上就给飞机动了手术</li>
<li>可以逐渐验证自己的方案，不要一开始就置自己于险境</li>
</ul>
<blockquote>
<p>比如目前工程中moduleA直接依赖moduleB调用接口，重构过程中不必直接取消依赖（不要影响目前的业务），在AppContext中添加一个moduleB的service，这个service代理moduleB提供的接口服务，然后moduleA调用接口逐渐的转向AppContext提供的方式，当转得差不多的时候就断掉moduleA与moduleB之间的依赖。</p>
</blockquote>
<p>对于有些业务线的<code>module</code>，完全可以把他当做一个app来对待  </p>
<p><img src="/2016/08/01/Android-Facede/3.png" alt>  </p>
<h5 id="AppContext只是解决了module之间的通信或者是子系统的管理"><a href="#AppContext只是解决了module之间的通信或者是子系统的管理" class="headerlink" title="AppContext只是解决了module之间的通信或者是子系统的管理"></a>AppContext只是解决了module之间的通信或者是子系统的管理</h5><blockquote>
<p>由多收缩到一的问题（统一依赖AppContext），只限于单进程，还没有跨进程，跨app，关于跨进程local，remote的问题，另开一贴讲设计思路与实现</p>
</blockquote>
<p>一个<code>App</code>除了通信，还有一些工具类，一些的<code>style</code>，<code>theme</code>，<code>resource</code>相关的定义。  </p>
<p>很多<code>app</code>都会搞一个类似<code>core</code>，<code>common</code>的<code>module</code>，一股脑儿的扔里面，这玩意儿到后面绝对是一锅东北菜，乱炖的感觉。  </p>
<p>对于<code>module</code>层级下面的<code>util</code>，只能是高度通用的<code>util</code>才放到下面，命名一定要体现其具体功能，千万不要直接<code>utils</code>，<code>StringUtils</code>等很模糊的命名，推荐<code>Logger</code>，<code>DeviceUtil</code>，<code>UrlUtil</code>等一眼就能看出其具体功能的<code>util</code>。  </p>
<p>对于<code>resource</code>相关的定义，单独一个<code>module</code><br>这些<code>module</code>都会逐渐沉淀下来，以后<code>app</code>按需依赖.<br><img src="/2016/08/01/Android-Facede/4.png" alt><br>黑线一下的就是业务线开发的基础，是不是有点类似<code>android.jar</code>的感觉</p>
<h4 id="UserCase"><a href="#UserCase" class="headerlink" title="UserCase"></a>UserCase</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">人之所以聪明，是因为人会创造工具并使用</span><br><span class="line"></span><br><span class="line">重构的基础是人员，如何照顾开发的情绪，如何渐进式的进行重构，</span><br><span class="line">如何借助工具进行重构，重构不等于重写，重构不等于业务都给我停下让路</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/08/libco/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/08/libco/" itemprop="url">libco</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-08T22:39:02+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方源码库/" itemprop="url" rel="index">
                    <span itemprop="name">第三方源码库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="co-create-初始化相关"><a href="#co-create-初始化相关" class="headerlink" title="co_create  初始化相关"></a>co_create  初始化相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,</span><br><span class="line">			   pfn_co_routine_t pfn,void *arg )</span><br><span class="line"></span><br><span class="line">static stCoRoutineEnv_t* g_arrCoEnvPerThread[ 204800 ] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">void co_init_curr_thread_env()</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将Env_t信息保存在全局变量g_arrCoEnvPerThread中对应于threadId的位置</p>
</li>
<li><p>创建一个空协程，被设置为当前Env_t的main routine，用于运行该线程的主逻辑</p>
</li>
<li><p>Epoll_t相关的信息初始化，管理时间片相关</p>
</li>
<li><p>stCoRoutine_t 保存每个协程的信息</p>
</li>
</ol>
<ol>
<li><p>co_create_env</p>
<p>创建协程的函数是co_create_env()，每个协程有自己密切相关的结构stCoRoutine_t</p>
</li>
<li><p>支持共享栈</p>
<p>所以共享栈采用的方式就是每次发生协程切换的时候，把实际用到的栈内容stack_bp   stack_sp通过save_stack_buffer来保存到malloc的内存中去，然后调用coctx_swap进行寄存器信息的切换，再把切换进来的新协程之前以相同方式保存的栈数据再拷贝到上面的共享栈空间的对应的内存位置上去(栈指针在coctx_swap已经更新完了，这里只是填补数据的作用，而且每个协程切换前后一直使用相同的共享栈，即使有局部指针也没有问题)，从而大大增加了内存的利用效率。</p>
</li>
</ol>
<h2 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h2><p>协程 = 回调 + 栈内存</p>
<p>协程执行实际是协程的切换，包括协程上下文（寄存器状态）的切换，回调执行之后会再次切换回来</p>
<p>如果协程中创建了新的协程，则会有嵌套的协程切换</p>
<p>co_resume</p>
<p>同时创建的协程第一次启动也是使用这个接口，并且在第一次启动的时候会初始化特殊的coctx_t结构，在协程执行结束后，会自动设置cEnd=1，同时将自己yield出去</p>
<p>栈帧stack frame layout：</p>
<p><img src="/2016/04/08/libco/illustration-1.png" alt></p>
<p>调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2</p>
<p><img src="/2016/04/08/libco/illustration-2.png" alt></p>
<p>libco程序的第一个协程呢，假如第一个协程yield时，CPU控制权让给谁呢？关于这个问题，我们首先要明白这“第一个”协程是什么。实际上，libco的第一个协程，即执行main函数的协程，是一个特殊的协程。这个协程又可以称作主协程，它负责协调其他协程的调度执行（后文我们会看到，还有网络 </p>
<p>I/O以及定时事件的驱动），它自己则永远不会yield，不会主动让出 </p>
<p>CPU。不让出CPU，不等于说它一直霸占着CPU。我们知道CPU执行权有两种转移途径，一是通过yield让给调用者，其二则是resume启动其他协程运行。</p>
<h4 id="阻塞调用Hook"><a href="#阻塞调用Hook" class="headerlink" title="阻塞调用Hook"></a>阻塞调用Hook</h4><p>通过glibc中dlfcn.h的dlsym和RTLD_NEXT结合起来，从而给标准库函数添加钩子</p>
<p>#define HOOK_SYS_FUNC(name) if( !g_sys_##name##_func ) { g_sys_##name##_func = (name##_pfn_t)dlsym(RTLD_NEXT,#name); }</p>
<p>epoll 基于事件驱动的IO多路复用技术，1. mmap，2. 红黑树，33. rdlist</p>
<p><strong>int</strong> <strong>epoll_create(**</strong>int<strong> </strong>size);**</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>epoll的事件注册函数 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<p>等待事件的产生</p>
<h4 id="协程的事件管理"><a href="#协程的事件管理" class="headerlink" title="协程的事件管理"></a>协程的事件管理</h4><ol>
<li><p>初始化 AllocEpoll</p>
</li>
<li><p>添加监听事件 co_poll</p>
</li>
<li><p>轮询 co_eventloop</p>
</li>
</ol>
<h4 id="感受"><a href="#感受" class="headerlink" title="感受:"></a>感受:</h4><blockquote>
<p>总体代码质量并不是特别好，总感觉为了使用C++而使用C++，甚至有些命名都不是 特别规范，最好理解的协程库还是云风c语言版本的，强力推荐，libco最大的优势就是作为微信内部框架的底层库，在线上也承受了巨大的流量，稳定跑到几千台服务器上，其他的都不重要。</p>
</blockquote>
<p>libco github ：<a href="https://github.com/Tencent/libco" target="_blank" rel="noopener">地址</a></p>
<p>云风 github： <a href="https://github.com/cloudwu/coroutine/" target="_blank" rel="noopener">地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/08/09/c-11学习笔记-智能指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/09/c-11学习笔记-智能指针/" itemprop="url">c++ 11学习笔记--智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-09T18:14:25+08:00">
                2014-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常高，很多地方都会使用到，只存在一份拷贝显然是最好的，这个时候对象生命周期的管理就会很复杂，所以c++引入了智能指针。</p>
<p>任何事物都会有两面性。</p>
</blockquote>
<h2 id="Shared-ptr"><a href="#Shared-ptr" class="headerlink" title="Shared_ptr"></a>Shared_ptr</h2><h3 id="摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）"><a href="#摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）" class="headerlink" title="摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）"></a>摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;construct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    ~Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;destruct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int priority()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;22222&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processWidget(int priority,std::shared_ptr&lt;Widget&gt; pw)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;111111&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    processWidget(priority(),std::shared_ptr&lt;Widget&gt;(new Widget));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processWidget运行的过程应该是</p>
<ol>
<li><p>New Widget</p>
</li>
<li><p>shared_ptr constructor</p>
</li>
<li><p>Priority()</p>
</li>
</ol>
<p>我在llvm上测试的结果也是这个执行顺序</p>
<p>也许某些编译器上可能执行的顺序是</p>
<ol>
<li><p>New Widget</p>
</li>
<li><p>Priority() //发生异常</p>
</li>
<li>shared_ptr constructor</li>
</ol>
<p>就有可能有内存泄露</p>
<blockquote>
<p><strong>所以最好的办法还是应该把new widget提到外面来写，所以好的编码习惯很重要。</strong></p>
</blockquote>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BPtr b;</span><br><span class="line">    ~A () &#123;</span><br><span class="line">         cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    APtr a;</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b; // 1</span><br><span class="line">    b-&gt;a = a; // 2</span><br><span class="line">    </span><br><span class="line">     cout &lt;&lt; &quot;over!!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr"><a href="#要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr" class="headerlink" title="要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr"></a>要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line"></span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line">typedef std::weak_ptr&lt;A&gt; AWeakPtr;</span><br><span class="line">typedef std::weak_ptr&lt;B&gt; BWeakPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BWeakPtr b; // 注意这里</span><br><span class="line">    ~A () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    AWeakPtr a; // 注意这里</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两种指针其实和oc里面的 strong, weak非常相识。</p>
<p> weak_ptr的另外一种用法</p>
<p>使用情景：当类对象被 shared_ptr 管理时，需要在类自己定义的函数里把当前类对象作为参数传给其他函数时，这时需要传递一个 shared_ptr ，否则就不能保持 shared_ptr 管理这个类对象的语义（因为有一个 raw pointer 指向这个类对象，而 shared_ptr 对类对象的这个引用没有计数，很有可能 shared_ptr 已经把类对象资源释放了，而那个调用函数还在使用类对象——显然，这肯定会产生错误）。《摘录：<a href="http://blog.csdn.net/zhongguoren666/article/details/8617436》" target="_blank" rel="noopener">http://blog.csdn.net/zhongguoren666/article/details/8617436》</a></p>
<p>直接看官网的例子吧：</p>
<p>《<a href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Good: std::enable_shared_from_this&lt;Good&gt;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; getptr() &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bad</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CObj: public std::enable_shared_from_this&lt;CObj&gt; &#123;</span><br><span class="line">    friend class CObjMgr;</span><br><span class="line">protected:</span><br><span class="line">    CObj() &#123;&#125;   // 只有CObjMgr可以创建与删除</span><br><span class="line">    ~CObj()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // Good: the two shared_ptr&apos;s share the same object</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1(new Good);</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;gp2.use_count() = &quot; &lt;&lt; gp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    </span><br><span class="line">    // Bad, each shared_ptr thinks it&apos;s the only owner of the object</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad);</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; // UB: double-delete of Bad</span><br></pre></td></tr></table></figure>
<ol>
<li>绝对不能在构造函数中调用shared_from_this()</li>
</ol>
<p>​      因为shared_ptr里面初始化enable_shared_from_this的成员weak_ptr，      这个时候weak_ptr还是空值。</p>
<ol start="2">
<li>为什么内部不能用this指针</li>
</ol>
<p>​      因为我们程序中用shared_ptr来管理指针，如果我们在类的内部传递的过程中用原始指针，这样类内部的引用shared_ptr不会察觉到，因为有可能我们传进去的时候已经被shared_ptr释放掉了</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><blockquote>
<p>相对就要单纯许多了，unique_ptr“唯一”拥有其所指对象，只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p>
</blockquote>
<h3 id="代替普通指针"><a href="#代替普通指针" class="headerlink" title="代替普通指针"></a>代替普通指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo()  </span><br><span class="line">&#123;//不安全的代码  </span><br><span class="line">    X *px = new X;  </span><br><span class="line">    // do something, exception may occurs  </span><br><span class="line">delete px; // may not go here     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unique_ptr&lt;X&gt; px(new X);</span><br></pre></td></tr></table></figure>
<h3 id="在函数中返回对象"><a href="#在函数中返回对象" class="headerlink" title="在函数中返回对象"></a>在函数中返回对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;X&gt; foo()  </span><br><span class="line">&#123;  </span><br><span class="line">    unique_ptr&lt;X&gt; px(new X);  </span><br><span class="line">    // do something  </span><br><span class="line">    return px; //移动语义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="放入容器中"><a href="#放入容器中" class="headerlink" title="放入容器中"></a>放入容器中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“1111”&#125;, new string&#123;“2222”&#125;，new string&#123;“3333”&#125;  &#125;;  </span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; test(new string(&quot;11111&quot;));  </span><br><span class="line">v.push_back(std::move(test));//使用移动语法</span><br></pre></td></tr></table></figure>
<h3 id="支持直接持有数组"><a href="#支持直接持有数组" class="headerlink" title="支持直接持有数组"></a>支持直接持有数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],</span><br><span class="line">    [](int* p)&#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;);</span><br><span class="line">//或者使用helper</span><br><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/" itemprop="url">c++ 11学习笔记--Lambda 表达式（对比测试Lambda ，bind，Function Object）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-09T18:02:37+08:00">
                2014-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。</p>
<p>还是直接看对比栗子吧，抄袭的是msdn的官网</p>
<p>该示例使用 for_each 函数调用中嵌入的 lambda 向控制台打印 vector 对象中的每个元素是偶数还是奇数。</p>
</blockquote>
<h3 id="使用lambda"><a href="#使用lambda" class="headerlink" title="使用lambda"></a>使用lambda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">   // Create a vector object that contains 10 elements.</span><br><span class="line">   vector&lt;int&gt; v;</span><br><span class="line">   for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">      v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Count the number of even numbers in the vector by </span><br><span class="line">   // using the for_each function and a lambda.</span><br><span class="line">   int evenCount = 0;</span><br><span class="line">   for_each(v.begin(), v.end(),[&amp;evenCount] (int n) &#123;</span><br><span class="line">      cout &lt;&lt; n;</span><br><span class="line">      if (n % 2 == 0) &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">         ++evenCount;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // Print the count of even numbers to the console.</span><br><span class="line">   cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Function-Object"><a href="#使用Function-Object" class="headerlink" title="使用Function Object"></a>使用Function Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(int&amp; evenCount) </span><br><span class="line">        : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">            ++m_evenCount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line"></span><br><span class="line">    int&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    // Create a vector object that contains 10 elements.</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Count the number of even numbers in the vector by </span><br><span class="line">    // using the for_each function and a function object.</span><br><span class="line">    int evenCount = 0;</span><br><span class="line">    for_each(v.begin(), v.end(), FunctorClass(evenCount));</span><br><span class="line"></span><br><span class="line">    // Print the count of even numbers to the console.</span><br><span class="line">    cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正如微软文档所言，这两种在效率上并没有实质性的差距，我自己也测试了，不管在debug模式下还是release模式下，果然没有差距。</p>
<p>无意中我在晚上发现了bind和Lambda对比测试，前三种方式是网上的，后面两种是我自己加的，结果绝对让我蛋碎了一地。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdint&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(uint64_t&amp; evenCount)</span><br><span class="line">    : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">         m_evenCount += n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line">    </span><br><span class="line">    uint64_t&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef std::chrono::high_resolution_clock clock;</span><br><span class="line">    typedef clock::time_point                  time_point;</span><br><span class="line">    typedef clock::duration                    duration;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    timer()</span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void reset()</span><br><span class="line">    &#123;</span><br><span class="line">        _starttime = clock::now();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    duration elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">        return clock::now() - _starttime;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    time_point _starttime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool test_timer()</span><br><span class="line">&#123;</span><br><span class="line">    using std::chrono::milliseconds;</span><br><span class="line">    typedef timer::duration duration;</span><br><span class="line">    </span><br><span class="line">    const milliseconds sleep_time(500);</span><br><span class="line">    </span><br><span class="line">    timer t;</span><br><span class="line">    std::this_thread::sleep_for(sleep_time);</span><br><span class="line">    duration recorded = t.elapsed();</span><br><span class="line">    </span><br><span class="line">    // make sure the clock and this_thread::sleep_for is precise within one millisecond (or at least in agreement as to</span><br><span class="line">    // how inaccurate they are)</span><br><span class="line">    return (recorded - milliseconds(1) &lt; sleep_time)</span><br><span class="line">    &amp;&amp; (recorded + milliseconds(1) &gt; sleep_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void volatile_write(const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    volatile T* p = new T;</span><br><span class="line">    *p = x;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void run_test(const std::string&amp; name, Function func)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line">    timer t;</span><br><span class="line">    volatile_write(func());</span><br><span class="line">    timer::duration duration = t.elapsed();</span><br><span class="line">    std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; duration.count() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void do_test_loop(Function func, const uint64_t upper_limit = 100000000ULL)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t i;</span><br><span class="line">    for (i = 0; i &lt; upper_limit; ++i)</span><br><span class="line">        func(i);</span><br><span class="line">    if(i == upper_limit)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = [&amp;x] (uint64_t i) &#123; x += i;</span><br><span class="line"> &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_accumulate_bind_function(uint64_t&amp; x, uint64_t i)</span><br><span class="line">&#123;</span><br><span class="line">    x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_class_function()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line"></span><br><span class="line">    do_test_loop(FunctorClass(x));</span><br><span class="line">   // for_each(v.begin(), v.end(), FunctorClass(x));</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind_auto()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">uint64_t test_accumulate_boost_bind()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    </span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = boost::bind(&amp;test_accumulate_bind_function, boost::ref(x), _1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_boost_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!test_timer())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed timer test.&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run_test(&quot;Accumulate (lambda)            &quot;, &amp;test_accumulate_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (bind)              &quot;, &amp;test_accumulate_bind);</span><br><span class="line">    run_test(&quot;Accumulate (bound lambda)      &quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (Function Object)    &quot;, &amp;test_accumulate_class_function);</span><br><span class="line">    run_test(&quot;Accumulate (bind auto)    &quot;, &amp;test_accumulate_bind_auto);</span><br><span class="line">#if USE_BOOST</span><br><span class="line">    run_test(&quot;Accumulate (boost bind)        &quot;, &amp;test_accumulate_boost_bind);</span><br><span class="line">    run_test(&quot;Accumulate (boost bound lambda)&quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="debug模式："><a href="#debug模式：" class="headerlink" title="debug模式："></a>debug模式：</h3><p><strong>Accumulate (lambda)            100000000  422885105</strong></p>
<p><strong>Accumulate (bind)              100000000   4346676523</strong></p>
<p><strong>Accumulate (bound lambda)      100000000 1707092933</strong></p>
<p><strong>Accumulate (class function)    100000000   494674507</strong></p>
<p><strong>Accumulate (bind auto)         100000000 3381097610</strong></p>
<h3 id="Release模式"><a href="#Release模式" class="headerlink" title="Release模式"></a>Release模式</h3><p><strong>Accumulate (lambda)            100000000  17978</strong></p>
<p><strong>Accumulate (bind)              100000000   607188485</strong></p>
<p><strong>Accumulate (bound lambda)      100000000 520421500</strong></p>
<p><strong>Accumulate (Function Object)    100000000  1925</strong></p>
<p><strong>Accumulate (bind auto)         100000000 1726</strong></p>
<blockquote>
<p>编译器：APPLE LLVM5.1</p>
<p>c++就是这样让人蛋疼，随便一个东西，初学者都可以写5中写法，那大神下，至少可以写10种以上，效率上的差距也是大的惊人，我还是那句话c++应该做减法了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/09/c-11学习笔记-右值引用和移动构造语义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/09/c-11学习笔记-右值引用和移动构造语义/" itemprop="url">c++ 11学习笔记--右值引用和移动构造语义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-09T17:42:12+08:00">
                2014-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"><a href="#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。" class="headerlink" title="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"></a>今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const char* rhs)            // 普通赋值构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const myStr&amp; rhs)             // 拷贝构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs.str_);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str copy constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(myStr&amp;&amp; rhs)</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(rhs);</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str move constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~myStr()                          // 析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        if (!str_) return;</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str destructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">        delete [] str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const myStr&amp; operator=(myStr rhs)   // 赋值操作符重载</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.swap(*this);            // 使用copy-and-swap惯用法获得数据</span><br><span class="line">        return (*this);             // 避免重复撰写operator=</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void swap(myStr&amp; rhs)             // 交换算法</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(str_, rhs.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operator char*(void) const</span><br><span class="line">    &#123;</span><br><span class="line">        return str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr&amp; operator+=(const char* rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs) strcat(str_, rhs);</span><br><span class="line">        return (*this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行下面的代码"><a href="#执行下面的代码" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myStr ss(&quot;000&quot;);</span><br><span class="line">    myStr s1(&quot;11111&quot;), s2(&quot;22222&quot;), s3(&quot;3333333&quot;), s4(&quot;4444444&quot;);</span><br><span class="line">    cout &lt;&lt; std::endl;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line">    </span><br><span class="line">    const long long max = 30000000;</span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i&lt;max; i++) &#123;</span><br><span class="line">        ss = s1 + s2 + s3 + s4;</span><br><span class="line">    &#125;</span><br><span class="line">     time(&amp;timestamp2);</span><br><span class="line">    </span><br><span class="line"> timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure>
<h3 id="下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。"><a href="#下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。" class="headerlink" title="下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。"></a>下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="再找一个例子"><a href="#再找一个例子" class="headerlink" title="再找一个例子"></a>再找一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class MemoryBlock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    // 构造器（初始化资源）</span><br><span class="line">    explicit MemoryBlock(size_t length)</span><br><span class="line">    : _length(length)</span><br><span class="line">    , _data(new int[length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 析构器（释放资源）</span><br><span class="line">    ~MemoryBlock()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_data != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _data;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock destructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝构造器（实现拷贝语义：拷贝that）</span><br><span class="line">    MemoryBlock(const MemoryBlock&amp; that)</span><br><span class="line">    // 拷贝that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(new int[that._length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        std::cout &lt;&lt; &quot;copy constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝赋值运算符（实现拷贝语义：释放this ＋ 拷贝that）</span><br><span class="line">    MemoryBlock&amp; operator=(const MemoryBlock&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 拷贝that对象所拥有的资源</span><br><span class="line">            _length = that._length;</span><br><span class="line">            _data = new int[_length];</span><br><span class="line">            std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动构造器（实现移动语义：移动that）</span><br><span class="line">    MemoryBlock(MemoryBlock&amp;&amp; that)</span><br><span class="line">    // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(that._data)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">        that._data = nullptr;</span><br><span class="line">        that._length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动赋值运算符（实现移动语义：释放this ＋ 移动that）</span><br><span class="line">    MemoryBlock&amp; operator=(MemoryBlock&amp;&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">            _data = that._data;</span><br><span class="line">            _length = that._length;</span><br><span class="line">            </span><br><span class="line">            // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">            that._data = nullptr;</span><br><span class="line">            that._length = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _length; // 资源的长度</span><br><span class="line">    int* _data; // 指向资源的指针，代表资源本身</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MemoryBlock f() &#123; return MemoryBlock(50); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行下面的代码-1"><a href="#执行下面的代码-1" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const long long max = 100000;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line"></span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line">    for (long long i = 0; i&lt;max; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryBlock a = MemoryBlock(50);</span><br><span class="line"></span><br><span class="line">        MemoryBlock c = std::move(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time(&amp;timestamp2);</span><br><span class="line">timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果把MemoryBlock c = std::move(a)换成MemoryBlock c = a;</p>
<p>性能上大概也有30%的差距。</p>
<p>这就是右值引用和移动构造语义带来的好处，我理解就是以前只能引用左值，而右值是不能引用的，新语法的加入实现了右值的引用，减少了零时对象的产生销毁，但是也带来了更多怪异的语法，明显增加了c++的学习成本，如果语法设计角度，像oc一样增加类似引用计数器来管理对象，会不会更加优雅一下，至少让上层的码农不会那么累，其实通智能指针也能达到同样的效果。</p>
<p>这么多年了c++都在做加法，让学习，使用成本太高了，标准委员为的大爷些什么时候考虑一下做点减法呢，不要让c++那么学院派或者满地都是陷阱，也不要让实现一种技术有10种方法，但是有5种都是陷阱。靠！</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/06/c-11学习笔记-explicit构造函数和private/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/06/c-11学习笔记-explicit构造函数和private/" itemprop="url">c++ 11学习笔记--explicit构造函数和private</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-06T17:58:32+08:00">
                2014-06-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>某天写一个用特定数据类型才能构造的类，就习惯性的声明了一个默认的构造函数，并声明为了private，避免勿调用默认的构造函数去声明这个类。但是却收到涛哥的一封邮件，建议用explicit去申明就行了，不建议用private.</p>
<p>处于懒惰的习惯，我回了一个ok，今天无意中看到邮件了，发现不对，靠</p>
<p>还是用代码说话吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(int i)                       //带int类型构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不管我是调用    myStr s = ‘A’;还是调用    myStr s = 1；都会去调用到myStr(int i)这个构造函数，默认的做了类型转.特别是这种看上去还合理的转换，换个离谱点的myStr s = “test”,还是可以编译，也最多只是收到一个警告：Multi-character character constant，也许某些编译上不允许，或者把警告等级打高了会报错，但是这都不是我想要的转换，c++就是这样充满了各种坑的语言，</p>
<p>如果加上explicit，表示不允许编译器做这种转换。</p>
<p>总结来说就是所有单参数的构造函数都应该声明explicit，避免编译器做各种明明奇妙的类型转换。</p>
<p>引用effective c++：被声明为explicit的构造函数通常比其non-explicit兄弟更受欢迎。因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好理由允许构造函数被用于隐式类型转换，否则我会把它声明为explicit。我鼓励你遵循相同的政策。</p>
<p>把默认构造函数申明为private,我认为很简单，就是要么是单例，要么就是希望只调用我提供的构造函数来声明对象。</p>
<p>大多数时候，我觉得更好的做法就是将拷贝构造函数和operator=(赋值操作符重载)声明成private。</p>
<p>禁止一个类的外部用户对这个类的对象进行复制动作，有需要的时候再去打开这些。</p>
<p>为什么编译器就不能提供一个默认安全封闭的类呢，当我们需要的时候再去申请各种特性。不要把类的安全都交给不靠谱的码农，大多数时候我们自己写代码的时候也不清楚自己代码的危险性。c++太相信码农了，其实大部分码农都是极度不靠谱的。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/05/19/撸京东APP学到的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/05/19/撸京东APP学到的/" itemprop="url">撸京东APP学到的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-05-19T18:30:38+08:00">
                2014-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="登陆http请求："><a href="#登陆http请求：" class="headerlink" title="登陆http请求："></a>登陆http请求：</h3><p>d_model=iPhone3%2C1&amp;networkType=wifi&amp;adid=A7F435E4-9C29-4540-8AE9-4657FAD20A05&amp;st=1405680657333&amp;body=%7B%22loginname%22%3A%22softstarxy%22%2C%22loginpwd%22%3A%2211fa12f3adacd2ec366d807d4b09467a%22%7D&amp;osVersion=7.0.6&amp;d_brand=apple&amp;client=apple&amp;screen=640%2A960&amp;sv=1&amp;area=22_1930_50947_0&amp;sign=BXQbIzs8p7vKLnjcCtAwMg&amp;uuid=hjudwgohxzVu96krv%2FT6Hg%3D%3D&amp;clientVersion=3.6.1&amp;openudid=97bfb35f56b144250ce8aa0fc500c085ae5eac66&amp;partner=apple</p>
<p>md5加密，对于稍微复杂点的密码基本上就无解了，但是稍微简单点的密码还是可以通过彩虹表之类的东西穷举，破解还是很容易的。</p>
<p>所以加密两次或者混不同的机密算法应该是最安全的做法。</p>
<p>出于好奇，顺便测试了一下重置密码的http请求，结果，我无耻的发现自己的密码</p>
<p><img src="/2014/05/19/撸京东APP学到的/1.png" alt></p>
<h3 id="查看app内部数据保存"><a href="#查看app内部数据保存" class="headerlink" title="查看app内部数据保存"></a>查看app内部数据保存</h3><p><img src="/2014/05/19/撸京东APP学到的/2.png" alt></p>
<blockquote>
<p>用keyChain保存的敏感信息，也是用的md5加密密码，那就把keyChain数据导出来看看。。。。</p>
<p><a href="https://github.com/ptoomey3/Keychain-Dumper" target="_blank" rel="noopener">https://github.com/ptoomey3/Keychain-Dumper</a></p>
<p>Service: com.360buy.jdmobile</p>
<p>Account: softstarxy</p>
<p>Entitlement Group: SE98WUL95S.com.360buy.jdmobile</p>
<p>Label: com.360buy.jdmobile</p>
<p>Generic Field: (null)</p>
<p>Keychain Data: 0a053fc0987fb679965db9d099381672</p>
<p>保存的也是加密后的md5值，所以基本上无解，除非密码非常简单，可见任何时候稍微复杂的密码是必须的</p>
<p>这个方法可以看见手机里的所以wifi热点密码</p>
<p>需要注意的是使用Keychain-Dumper的时候需要赋予可读的权限</p>
<p>Jack-xiaode-iPhone:/private/var/Keychains root# chmod +r keychain-2.db</p>
<p>还需要给Keychain-Dumper添加执行权限</p>
<p>chmod +x /bin/keychain_dumper</p>
<p>剩下的就是</p>
<p>Jack-xiaode-iPhone:/private/var/Keychains root# /bin/Keychain-Dumper/keychain_dumper &gt; keychain-export.txt</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/05/13/撸文轩APP学到的/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/05/13/撸文轩APP学到的/" itemprop="url">撸文轩APP学到的</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-05-13T18:30:38+08:00">
                2014-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>因为我的朋友在文轩上班，那就撸一下他们公司的app</p>
<p><img src="/2014/05/13/撸文轩APP学到的/1.png" alt></p>
<p>找到要撸的app，并生成要解密的ipa</p>
<p> 找到这个文件，先解压再</p>
<p><img src="/2014/05/13/撸文轩APP学到的/2.png" alt></p>
<p>再用class-dump-z来导出类的信息</p>
<p><img src="/2014/05/13/撸文轩APP学到的/3.png" alt></p>
<p>现在就可以把文件导入电脑上来看看到底有些什么信息了</p>
<p>在看类信息之前习惯性的看看plist，很悲剧的看见了我的用户名和密码</p>
<p>还是明文的。。。。。突然间就有了千万只草泥马在心中奔腾</p>
<p><img src="/2014/05/13/撸文轩APP学到的/4.png" alt></p>
<p>好奇的抓包试了试，http请求也是</p>
<p><a href="http://auth.winxuan.com/accessToken?password=111111&amp;username=cccccc&amp;appkey=100046&amp;appsecret=16f31b66f828c1bf237db288b106ccce&quot;" target="_blank" rel="noopener">http://auth.winxuan.com/accessToken?password=111111&amp;username=cccccc&amp;appkey=100046&amp;appsecret=16f31b66f828c1bf237db288b106ccce&quot;</a>,</p>
<p>算了，看看class的信息</p>
<p>他竟然http请求是自己封装的，还专门封装为了同步方法和异步的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@interface QAsyncHttp : NSObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id)httpPostWithFile:(id)file url:(id)url queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">-(id)httpPost:(id)post queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">-(id)httpGet:(id)get queryString:(id)string delegate:(id)delegate;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">@interface QSyncHttp : NSObject &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(id)httpPostWithFile:(id)file url:(id)url queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)httpPost:(id)post queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)httpGet:(id)get queryString:(id)string;</span><br><span class="line"></span><br><span class="line">-(id)getResponseWithRequest:(id)request;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有必要这样嘛，个人觉得只封装一种就够了，需要同步的时候，自己在UI上处理一下，让用户感觉是同步的方式就可以了</p>
<p>实在是太多了，也懒得看</p>
<p>资源文件就是一堆图片，cache文件里面就是各种书籍的缓存图片，反正里面的东西都没有加密，也就一目了然了，并不是很能理解这种做法。</p>
<p>软件某些功能都无法正常使用，分享，升级检测，支付功能也相当难用，对于如此恶心的app,突然失去继续撸下去的必要。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="三鱼">
            
              <p class="site-author-name" itemprop="name">三鱼</p>
              <p class="site-description motion-element" itemprop="description">挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xyiot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:softstarxy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/5419866199/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三鱼</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
