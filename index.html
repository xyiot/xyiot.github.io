<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="三余无梦生" type="application/atom+xml">






<meta name="description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">
<meta property="og:type" content="website">
<meta property="og:title" content="三余无梦生">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="三余无梦生">
<meta property="og:description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="三余无梦生">
<meta name="twitter:description" content="挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>三余无梦生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">三余无梦生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/begin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/begin/" itemprop="url">缺舟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T18:00:00+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"><a href="#思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。" class="headerlink" title="思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。"></a>思绪总是一闪而过，如梦幻泡影，皆为虚妄，不执着，冷眼看。</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/09/Redis4源码阅读学习-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/09/Redis4源码阅读学习-2/" itemprop="url">redis4源码阅读学习-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-09T18:02:37+08:00">
                2019-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方源码库/" itemprop="url" rel="index">
                    <span itemprop="name">第三方源码库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="redis客户端和服务器的相关代码"><a href="#redis客户端和服务器的相关代码" class="headerlink" title="redis客户端和服务器的相关代码"></a>redis客户端和服务器的相关代码</h1><h2 id="ae-c（Redis-的事件处理器实现（基于-Reactor-模式））"><a href="#ae-c（Redis-的事件处理器实现（基于-Reactor-模式））" class="headerlink" title="ae.c（Redis 的事件处理器实现（基于 Reactor 模式））"></a>ae.c（Redis 的事件处理器实现（基于 Reactor 模式））</h2><p><img src="/2019/02/09/Redis4源码阅读学习-2/1.png" alt></p>
<p>handle_events()</p>
<p>在Redis中，对于文件事件，相应的处理函数为Ae.c/aeProcessEvents</p>
<p>register_handler/remove_handler 对应Redis中，相关的处理函数也在Ae.c文件中方法</p>
<p>select对应不同平台的io复用的函数库</p>
<p>handle对应fd资源，文件描述符</p>
<p>event handler  事件处理器的接口</p>
<p>Concrete Event Handler 事件处理器的实际实现，绑定handle，比如acceptTcpHandler  这些</p>
<h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><h5 id="aeFileEvent"><a href="#aeFileEvent" class="headerlink" title="aeFileEvent"></a>aeFileEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件事件结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line">    aeFileProc *rfileProc;  <span class="comment">//读文件事件回调</span></span><br><span class="line">    aeFileProc *wfileProc;  <span class="comment">//写文件事件回调</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<h5 id="aeTimeEvent"><a href="#aeTimeEvent" class="headerlink" title="aeTimeEvent"></a>aeTimeEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间事件结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc *timeProc;<span class="comment">//定时回调函数指针</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;<span class="comment">// 定时事件清理函数，当删除定时事件的时候会被调用</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; <span class="comment">//指向 redisClient 的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span><span class="comment">//时间事件表指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure>
<h5 id="aeFiredEvent"><a href="#aeFiredEvent" class="headerlink" title="aeFiredEvent"></a>aeFiredEvent</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 触发事件</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">//表示事件发生在哪个文件描述符上面</span></span><br><span class="line">    <span class="keyword">int</span> mask;<span class="comment">//被触发事件的类型</span></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure>
<h5 id="aeEventLoop"><a href="#aeEventLoop" class="headerlink" title="aeEventLoop"></a>aeEventLoop</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件循环结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">//记录最大的定时事件 id </span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; </span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">//用于系统时间的矫正</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">//文件表</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">//触发事件表</span></span><br><span class="line">    aeTimeEvent *timeEventHead;<span class="comment">//定时事件表</span></span><br><span class="line">    <span class="keyword">int</span> stop; <span class="comment">//事件循环停止标志</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">//统一接口，屏蔽不同平台io服用机制，</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">//进入poll之前需要处理的事情</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">//进入poll之后需要处理的事情</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    aeCreateEventLoop    <span class="comment">/* 创建总的事件管理结构 */</span></span><br><span class="line">    aeCreateTimeEvent    <span class="comment">/* 创建定时器事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> inet socket    <span class="comment">/* 创建网络事件的管理结构 */</span></span><br><span class="line">    aeCreateFileEvent <span class="keyword">for</span> unix socket    <span class="comment">/* 内部通信事件的管理结构 */</span></span><br><span class="line">    aeSetBeforeSleepProc    <span class="comment">/* 设置beforeSleep处理函数 */</span></span><br><span class="line">    aeSetAfterSleepProc    <span class="comment">/* 设置afterSleep处理函数 */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> (!stop)  <span class="comment">//aeMain</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//aeProcessEvents</span></span><br><span class="line">        beforeSleep                <span class="comment">/* 调用beforeSleep处理函数 */</span></span><br><span class="line">        aeApiPoll                <span class="comment">/* 进入poll函数 */</span></span><br><span class="line">        afterSleep                <span class="comment">/* 调用afterSleep处理函数 */</span></span><br><span class="line">        process file events    <span class="comment">/* 处理file events */</span></span><br><span class="line">        process time events    <span class="comment">/* 处理time events */</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="aeCreateEventLoop-initServer调用初始化"><a href="#aeCreateEventLoop-initServer调用初始化" class="headerlink" title="aeCreateEventLoop  //initServer调用初始化"></a>aeCreateEventLoop  //initServer调用初始化</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">aeEventLoop *aeCreateEventLoop(int setsize) &#123; </span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if ((eventLoop = zmalloc(sizeof(*eventLoop))) == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(sizeof(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(sizeof(aeFiredEvent)*setsize);</span><br><span class="line">    if (eventLoop-&gt;events == NULL || eventLoop-&gt;fired == NULL) goto err;</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(NULL);</span><br><span class="line">    eventLoop-&gt;timeEventHead = NULL;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = 0;</span><br><span class="line">    eventLoop-&gt;stop = 0;</span><br><span class="line">    eventLoop-&gt;maxfd = -1;</span><br><span class="line">    eventLoop-&gt;beforesleep = NULL;</span><br><span class="line">    eventLoop-&gt;aftersleep = NULL;</span><br><span class="line">    if (aeApiCreate(eventLoop) == -1) goto err;</span><br><span class="line">    /* Events with mask == AE_NONE are not set. So let&apos;s initialize the</span><br><span class="line">     * vector with it. */</span><br><span class="line">    for (i = 0; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    return eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    if (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h6><p>server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</p>
<p>setsize = server.maxclients+CONFIG_FDSET_INCR = 10000 + CONFIG_MIN_RESERVED_FDS+96</p>
<p>CONFIG_MIN_RESERVED_FDS = 32 是Sentinel保留的用于额外的的操作，如listening sockets, log files 等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/fs/file-max 查看系统级别的能够打开的文件句柄的数量</span><br><span class="line">ulimit -a 1024 查看用户进程级的能够打开文件句柄的数量</span><br></pre></td></tr></table></figure>
<h6 id="相关的案例事件……"><a href="#相关的案例事件……" class="headerlink" title="相关的案例事件……"></a>相关的案例事件……</h6><p>9554:M 24 Mar 10:40:25.869 # Error registering fd event for the new client: Numerical result out of range (fd=10128)</p>
<p>系统内存不足以fork子进程时，AOF重写就无法启动，而此之前已打开的pipe也永远不会关闭，并在下一次尝试AOF重写时又创建新的pipe，从而造成fd泄漏。</p>
<p>具体代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR; <span class="comment">// 创建pipe</span></span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">//……</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">//子进程启动出错处理</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Can't rewrite append only file in background: fork: %s"</span>,</span><br><span class="line">                strerror(errno)); <span class="comment">// 最初内存不足正是这里打出的错误log</span></span><br><span class="line">            aofClosePipes();<span class="comment">//fix bug issues/2857</span></span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//……</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h5><h5 id="1-文件事件"><a href="#1-文件事件" class="headerlink" title="1. 文件事件"></a>1. 文件事件</h5><p>在一般情况下，<code>aeProcessEvents</code> 都会先<strong>计算最近的时间事件发生所需要等待的时间</strong>，然后调用 <code>aeApiPoll</code> 方法在这段时间中等待事件的发生，在这段时间中如果发生了文件事件，就会优先处理文件事件，否则就会一直等待，直到最近的时间事件需要触发：</p>
<pre><code>numevents = aeApiPoll(eventLoop, tvp);

/* After sleep callback. */
if (eventLoop-&gt;aftersleep != NULL &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)
    eventLoop-&gt;aftersleep(eventLoop);

for (j = 0; j &lt; numevents; j++) {
    aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];
    int mask = eventLoop-&gt;fired[j].mask;
    int fd = eventLoop-&gt;fired[j].fd;
    int fired = 0; /* Number of events fired for current fd. */

    int invert = fe-&gt;mask &amp; AE_BARRIER;
</code></pre><p>​           </p>
<h2 id="文件事件注册-aeCreateFileEvent"><a href="#文件事件注册-aeCreateFileEvent" class="headerlink" title="文件事件注册  aeCreateFileEvent"></a>文件事件注册  aeCreateFileEvent</h2><h2 id="监听实现"><a href="#监听实现" class="headerlink" title="监听实现"></a>监听实现</h2><p>1.<code>initServer()</code>中完成了对事件循环的初始化操作</p>
<p>listenToPort</p>
<p>2.完成了监听套接字的初始化，<code>initServer()</code>还需要为所有监听套接字注册读事件</p>
<p>acceptTcpHandler/acceptUnixHandler  //回调监听到新连接请求时</p>
<p>acceptTcpHandler()-&gt;acceptCommonHandler  </p>
<p>在与客户端成功建立连接之后，调用了<code>acceptCommonHandler()</code>函数，其作用为：<br> 1、 建立并保存服务器与客户端的连接信息，将信息保存到一个struct redisClient 中；<br> 2、为客户端的cfd（已连接的socket）注册读事件，相应的回调函数为<code>readQueryFromClient()</code>，其作用是从socket读取数据，执行相应操作，并回复给客户端(而acceptCommonHandler是为监听socket的读事件回调函数)</p>
<h2 id="事件循环aeMain"><a href="#事件循环aeMain" class="headerlink" title="事件循环aeMain"></a>事件循环aeMain</h2><p>1、根据时间事件链表计算需要等待的最短事件；<br>2、调用<code>redis aeApiPoll()</code> 进入监听轮询，如果没有事件发生就进入睡眠状态，其实就是进行I/O多路复用函数调用。<br>3、如果有事件发生，处理事件。</p>
<h2 id="事件触发"><a href="#事件触发" class="headerlink" title="事件触发"></a>事件触发</h2><p>aeApiPoll //多路复用函数阻塞监听</p>
<h5 id="2-时间事件"><a href="#2-时间事件" class="headerlink" title="2.时间事件"></a>2.时间事件</h5><p>在 Redis 中会发生两种时间事件：</p>
<ul>
<li>一种是定时事件，每隔一段时间会执行一次；</li>
<li>另一种是非定时事件，只会在某个时间点执行一次；</li>
</ul>
<p>aeProcessEvents -&gt;processTimeEvents</p>
<p><img src="/2019/02/09/Redis4源码阅读学习-2/2.png" alt></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>1时间事件分为定时时间和周期事件，周期事件serverCron  100毫秒</p>
<p>2时间事件和文件事件合并到一起处理，分开；</p>
<p>3.时间事件晚于预设</p>
<p><img src="/2019/02/09/Redis4源码阅读学习-2/aeEventLoop.png" alt></p>
<h4 id="networking-c"><a href="#networking-c" class="headerlink" title="networking.c"></a>networking.c</h4><p>readQueryFromClient   processCommand</p>
<p>clientsCronHandleTimeout //keep_alive，ping,异常处理</p>
<p>三类方法</p>
<p>1.addReply API  往数据结构里面写东西</p>
<p>2.Client API 客户端创建释放</p>
<p>3.工具方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listMatchObjects</span><br><span class="line">disconnectSlaves</span><br><span class="line">flushSlavesOutputBuffers</span><br><span class="line">acceptTcpHandler</span><br><span class="line">copyClientOutputBuffer</span><br></pre></td></tr></table></figure>
<h4 id="server-c"><a href="#server-c" class="headerlink" title="server.c"></a>server.c</h4><p>1.Globals</p>
<p>2.Utility functions</p>
<p>3.Hash table</p>
<p>4.Cron</p>
<p>trackInstantaneousMetric  bug</p>
<p>writeToClient    server.stat_net_output_bytes += totwritten;</p>
<pre><code>5.0
//缓冲区大于32K，且远大于查询缓冲区数据峰值
//询缓冲区大于32K，且客户端当前处于非活跃状态
int clientsCronResizeQueryBuffer(client *c)

if (querybuf_size &gt; PROTO_MBULK_BIG_ARG &amp;&amp;
     ((querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2 ||
      idletime &gt; 2))
{
    /* Only resize the query buffer if it is actually wasting
     * at least a few kbytes. */
    if (sdsavail(c-&gt;querybuf) &gt; 1024*4) {
        c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);
    }
}

4.0
// 查询缓冲区大于32K，且远大于查询缓冲区数据峰值
// 查询缓冲区大于1K，且客户端当前处于非活跃状态
if (((querybuf_size &gt; PROTO_MBULK_BIG_ARG) &amp;&amp;
    (querybuf_size/(c-&gt;querybuf_peak+1)) &gt; 2) ||
    (querybuf_size &gt; 1024 &amp;&amp; idletime &gt; 2))
{
        /* Only resize the query buffer if it is actually wasting space. */
        if (sdsavail(c-&gt;querybuf) &gt; 1024) {
            c-&gt;querybuf = sdsRemoveFreeSpace(c-&gt;querybuf);
        }
 }

//c-&gt;querybuf = sdsMakeRoomFor(c-&gt;querybuf, readlen);
初始化默认分配的大小就是32k
如果客户端数量比较多，且刚好比较空闲，需要一次处理很多客户端的输入缓冲区，阻塞或者崩溃
</code></pre><p>5.serverCron 相关的知识点</p>
<p>1）.信息更新，统计</p>
<p>2).  XXXXCron</p>
<p>3). 持久化</p>
<p>4). 集群</p>
<p>6.Server initialization</p>
<p>7.Redis OP Array API  持久化复制的时候命令数组</p>
<p>8.Commands lookup and execution</p>
<p>9.Shutdown</p>
<p>10.Commands</p>
<ol start="11">
<li><strong>linux</strong></li>
</ol>
<p>12.main</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/Redis4源码阅读学习-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/Redis4源码阅读学习-1/" itemprop="url">redis4源码阅读学习-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T18:02:37+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方源码库/" itemprop="url" rel="index">
                    <span itemprop="name">第三方源码库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="zmalloc-c"><a href="#zmalloc-c" class="headerlink" title="zmalloc.c"></a>zmalloc.c</h2><h2 id="tcmalloc"><a href="#tcmalloc" class="headerlink" title="tcmalloc"></a><a href="https://github.com/gperftools/gperftools" target="_blank" rel="noopener">tcmalloc</a></h2><h2 id="jemalloc"><a href="#jemalloc" class="headerlink" title="jemalloc"></a><a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener">jemalloc</a></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 申请新的_n大小的内存，用新的gcc原子方法（__atomic_add_fetch）代替之前的 代替自定义的线程安全方法和不安全方法*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) do &#123; \</span></span><br><span class="line">    <span class="keyword">size_t</span> _n = (__n); \</span><br><span class="line">    <span class="keyword">if</span> (_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)) _n += <span class="keyword">sizeof</span>(<span class="keyword">long</span>)-(_n&amp;(<span class="keyword">sizeof</span>(<span class="keyword">long</span>)<span class="number">-1</span>)); \</span><br><span class="line">    atomicIncr(used_memory,__n); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure>
<h3 id="详情可以参考GCC官方文档链接"><a href="#详情可以参考GCC官方文档链接" class="headerlink" title="详情可以参考GCC官方文档链接"></a>详情可以参考GCC官方文档<a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">链接</a></h3><ol>
<li>分配内存大小为size+PREFIX_SIZE的大小，zmalloc实际分配比需要多一些的内存，这一部分用于存储size信息。</li>
<li>zmalloc_oom_handler用来处理内存申请异常</li>
<li>(_n&amp;(sizeof(long)-1)) _n += sizeof(long)-(_n&amp;(sizeof(long)-1)); = if(_n&amp;7) _n += 8 - (_n&amp;7);  32位4字节对齐，64位下8字节对齐</li>
</ol>
<h1 id="数据结构：objcet"><a href="#数据结构：objcet" class="headerlink" title="数据结构：objcet"></a>数据结构：objcet</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time).  </span></span><br><span class="line"><span class="comment">              16 bits      8 bits</span></span><br><span class="line"><span class="comment">      +------------------+--------+</span></span><br><span class="line"><span class="comment">      + Last access time | LOG_C  |</span></span><br><span class="line"><span class="comment">      +------------------+--------+*/</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">//通过引用计数的方式来管理内存，c++11，oc</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">//指向具体实现的具体区域和数据结构</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type字段表示数据类型，有以下几种定义：</span><br><span class="line">OBJ_STRING   <span class="comment">// 字符串</span></span><br><span class="line">OBJ_LIST  <span class="comment">// 链表</span></span><br><span class="line">OBJ_SET  <span class="comment">// 集合</span></span><br><span class="line">OBJ_ZSET  <span class="comment">// 有序集合</span></span><br><span class="line">OBJ_HASH  <span class="comment">// HASH结构（注意，此处不同于传统意义上的哈希表（如stl::hash_map），这里的hash仅有字段散列的语义）</span></span><br><span class="line">REDIS_VMPOINTER  <span class="comment">// VM指针，已经废弃，翻看了一下VM相关实现和历史</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Redis采用VM机制是希望把存储做成如同Oracle一样的方式，具备自动淘汰冷热数据功能，但是，它采用了RDB文件和VM机制来分别实现二进制存储、冷热淘汰的功能，期望是既节约内存又达到完美性能的地步</span></span><br><span class="line"><span class="comment">redis之所以高性能最本质的原因是数据都cache到内存里。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//encoding则对应了 Redis 中的10种编码方式</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>数据类型</th>
<th style="text-align:right">一般情况</th>
<th style="text-align:center">少量情况</th>
<th style="text-align:right">特殊情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>STRING</td>
<td style="text-align:right">RAW</td>
<td style="text-align:center">EMBSTR</td>
<td style="text-align:right">INT</td>
</tr>
<tr>
<td>LIST</td>
<td style="text-align:right">LINKEDLIST</td>
<td style="text-align:center">ZIPLIST</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>HASH</td>
<td style="text-align:right">HT</td>
<td style="text-align:center">ZIPLIST</td>
</tr>
</tbody>
</table>
<h3 id="refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"><a href="#refcount-引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较" class="headerlink" title="refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的引用计数与垃圾收集之比较"></a>refcount 引用计数的方式管理内存，自动化的管理除了引用技术，就是垃圾回收，相关可以参考云风写的<a href="https://blog.codingnow.com/2008/06/gc.html" target="_blank" rel="noopener">引用计数与垃圾收集之比较</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objcet.c基本上就是提供了一堆对象操作，初始化等相关的api接口</span></span><br><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span></span>&#123; <span class="comment">/* 最初的创建robj对象方法，后面的创建方法与此类似 */</span>	</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">        <span class="comment">//lru lfu算法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK(); <span class="comment">//都记录下该对象的LRU时钟</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongDouble</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> value)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">dupStringObject</span><span class="params">(robj *o)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createListObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//正常释放</span></span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);<span class="comment">//异常</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法"><a href="#Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU-LFU算法" class="headerlink" title="Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法"></a>Redis中采用两种算法进行内存达到上限时内存回收，引用计数算法以及LRU/LFU算法</h2><ol>
<li>引用计数  refcount</li>
<li>lru （Least Recently Used）//最长时间未被使用<br><img src="/2018/11/09/Redis4源码阅读学习-1/5.png" alt="Image text"></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_MAX ((1<span class="meta-string">&lt;&lt;LRU_BITS)-1) = 2^24 - 1 单位毫秒 /* Max value of obj-&gt;lru */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_CLOCK_RESOLUTION 1000  <span class="comment">//代表LRU算法的精度，即一个LRU的单位是多长时间，1秒</span></span></span><br><span class="line"><span class="comment">//LRU时钟的时间粒度高于serverCron刷新的时间粒度，那么就主动获取最新的时间，否则使用server缓存的时间</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        atomicGet(server.lruclock,lruclock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">    <span class="comment">//如果定时器执行的频率高于LRU算法的精度时，可以直接将server.lruclock直接在对象创建时赋值过去，避免了函数调用的内存开销以及时间开销</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLRUClock</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (mstime()/LRU_CLOCK_RESOLUTION) &amp; LRU_CLOCK_MAX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定时循环执行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">.........</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lruclock = getLRUClock();</span><br><span class="line">    atomicSet(server.lruclock,lruclock);</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算数据的空闲时间</span></span><br><span class="line">evictionPoolPopulate-&gt;estimateObjectIdleTime-&gt;LRU_CLOCK</span><br><span class="line">objectCommand(idletime) -&gt; estimateObjectIdleTime</span><br></pre></td></tr></table></figure>
<p>3.LFU（Least Frequently Used） 最不常用页面置换算法，基于LFU的热点key发现机制  4.0<br>counter：基于概率的对数计数器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">      <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX; <span class="comment">//RAND_MAX c语言宏，rand最大上限值</span></span><br><span class="line">      <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL; <span class="comment">//LFU_INIT_VAL = 5</span></span><br><span class="line">      <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);<span class="comment">//默认server.lfu_log_factor=10，概率因子</span></span><br><span class="line">      <span class="keyword">if</span> (r &lt; p) counter++;   <span class="comment">//baseval增加后，p&lt;r的概率非线形增长</span></span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span><span class="comment">//从db-&gt;dict字典中获取key的val，并更新val的lru/lfu</span></span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/11/09/Redis4源码阅读学习-1/1.png" alt="Image text"></p>
<h3 id="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"><a href="#counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万" class="headerlink" title="counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万"></a>counter增长函数LFULogIncr中我们可以看到，随着key的访问量增长，counter最终都会收敛为255，一百万</h3><h1 id="动态配置"><a href="#动态配置" class="headerlink" title="动态配置"></a>动态配置</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lfu-<span class="built_in">log</span>-factor <span class="number">10</span> 概率因子</span><br><span class="line">lfu-decay-time <span class="number">1</span>  每分钟衰减<span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新对象的访问时间和计数器值,减少，每分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">//获取lru时间  分钟   </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">//获取使用频次</span></span><br><span class="line">    <span class="comment">//时间超过了lfu_decay_time的话，那么将使用频次减少</span></span><br><span class="line">    <span class="keyword">if</span> (LFUTimeElapsed(ldt) &gt;= server.lfu_decay_time &amp;&amp; counter) &#123;</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; LFU_INIT_VAL*<span class="number">2</span>) &#123;</span><br><span class="line">            counter /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; LFU_INIT_VAL*<span class="number">2</span>) counter = LFU_INIT_VAL*<span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            counter--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新时间和频次</span></span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次访问该数据对象已经过去了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前的分钟计数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUGetTimeInMinutes</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (server.unixtime/<span class="number">60</span>) &amp; <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="redis内存达到上限后的释放内存原则"><a href="#redis内存达到上限后的释放内存原则" class="headerlink" title="redis内存达到上限后的释放内存原则"></a>redis内存达到上限后的释放内存原则</h3><ol>
<li>释放内存的标准是释放之后使用内存的大小小于maxmemory的大小</li>
<li>每次释放的数量，redis.conf配置</li>
<li>超过限制后redis策略</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis.conf配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-lru -&gt; 从设置了过期时间的键中选择空转时间最长的键值对清除掉</span><br><span class="line"><span class="keyword">volatile</span>-lfu -&gt; 从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</span><br><span class="line"><span class="keyword">volatile</span>-random -&gt; 从设置了过期时间的键中，随机选择键进行清除.</span><br><span class="line"></span><br><span class="line">allkeys-lru -&gt; 从所有的键中选择空转时间最长的键值对清除</span><br><span class="line">allkeys-lfu -&gt; 从所有的键中选择某段时间之内使用频次最少的键值对清除.</span><br><span class="line">allkeys-random -&gt; 从所有的key中随机删除</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span>-ttl -&gt; 从已设置过期时间的数据集合中挑选即将过期的数据淘汰</span><br><span class="line">noeviction -&gt;不做任何的清理工作，禁止写入，报错</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># The <span class="keyword">default</span> of <span class="number">5</span> produces good enough results. <span class="number">10</span> Approximates very closely</span><br><span class="line"><span class="meta"># true LRU but costs more CPU. 3 is faster but not very accurate.</span></span><br><span class="line">#</span><br><span class="line"><span class="meta"># maxmemory-samples 5 lru，lfu每次采样数，5最佳</span></span><br></pre></td></tr></table></figure>
<h1 id="如何筛选释放的key"><a href="#如何筛选释放的key" class="headerlink" title="如何筛选释放的key"></a>如何筛选释放的key</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16 <span class="comment">//存储待释放的键相关信息的存储空间能够容纳的键的个数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255 <span class="comment">//cached中的最大的键的长度    512mb</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span> <span class="comment">//存储待释放的键所在内存的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化EvictionPoolLRU</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolAlloc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">ep</span>;</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    ep = zmalloc(<span class="keyword">sizeof</span>(*ep)*EVPOOL_SIZE);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; EVPOOL_SIZE; j++) &#123;</span><br><span class="line">        ep[j].idle = <span class="number">0</span>;</span><br><span class="line">        ep[j].key = <span class="literal">NULL</span>;</span><br><span class="line">        ep[j].cached = sdsnewlen(<span class="literal">NULL</span>,EVPOOL_CACHED_SDS_SIZE);</span><br><span class="line">        ep[j].dbid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    EvictionPoolLRU = ep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"><a href="#根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中" class="headerlink" title="根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中"></a>根据配置策略的LRU、LFU以及volatile-ttl策略转换成的idle值将待删除的键相关的信息按照idle值从小到大的顺序从前向后存储在evctionPoolLRU中</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//从sampledict中最多选取server.maxmemory_samples个指向sampledict的指针存放在放入到samples中,</span></span><br><span class="line">	<span class="comment">//server.maxmemory_samples配置5</span></span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the dictionary we are sampling from is not the main</span></span><br><span class="line"><span class="comment">         * dictionary (but the expires one) we need to lookup the key</span></span><br><span class="line"><span class="comment">         * again in the key dictionary to obtain the value object. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//如果maxmemory_policy为MAXMEMORY_VOLATILE_TTL，证明需要将距离过期时间最近的键清除掉;那么直接从redisDB-&gt;expire对应的字典中获取键对应的过期时间值即可，此时不需要改变已经存在的de。</span></span><br><span class="line">   <span class="comment">//如果maxmemory_policy != MAXMEMORY_VOLATILE_TTL且不是从redisDB-&gt;dict中获取键的值(使用redisDB-&gt;expire中获取的键),</span></span><br><span class="line">  那么需要从redisDB-&gt;dict中获取键对应的值的对象，才能够获取lru字段 </span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//lru，lfu，ttl 统一用idle来衡量</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            <span class="comment">/* When we use an LRU policy, we sort the keys by idle time</span></span><br><span class="line"><span class="comment">             * so that we expire keys starting from greater idle time.</span></span><br><span class="line"><span class="comment">             * However when the policy is an LFU one, we have a frequency</span></span><br><span class="line"><span class="comment">             * estimation, and we want to evict keys with lower frequency</span></span><br><span class="line"><span class="comment">             * first. So inside the pool we put objects using the inverted</span></span><br><span class="line"><span class="comment">             * frequency subtracting the actual frequency to the maximum</span></span><br><span class="line"><span class="comment">             * frequency of 255. */</span></span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o); <span class="comment">//LFUDecrAndReturn返回 counter</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">         </span><br><span class="line">  		<span class="comment">//EvictionPoolLRU中的元素全部按照元素对应的idle值按照从小到大的顺序</span></span><br><span class="line"> 	   <span class="comment">//idle越大，位置越靠后，当然也就最先被清除掉。</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//寻找元素的插入位置</span></span><br><span class="line">        <span class="comment">//pool中所有的元素都不为空，且其中元素的最小的idle大于等于idle</span></span><br><span class="line">        <span class="comment">//EVPOOL_SIZE 16</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">               <span class="comment">//满了</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Inserting in the middle. Now k points to the first element</span></span><br><span class="line"><span class="comment">             * greater than the element to insert.  */</span></span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to reuse the cached SDS string allocated in the pool entry,</span></span><br><span class="line"><span class="comment">         * because allocating and deallocating this object is costly</span></span><br><span class="line"><span class="comment">         * (according to the profiler, not my fantasy. Remember:</span></span><br><span class="line"><span class="comment">         * premature optimizbla bla bla bla. */</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用"><a href="#统计内存是否超过server-maxmemory，去掉AOF，slaves缓冲区内存占用" class="headerlink" title="统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用"></a>统计内存是否超过server.maxmemory，去掉AOF，slaves缓冲区内存占用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment"> * count of used memory. */</span></span><br><span class="line">mem_used = mem_reported;</span><br><span class="line"><span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line"><span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br></pre></td></tr></table></figure>
<h3 id="内存管理策略的入口函数—freeMemoryIfNeeded"><a href="#内存管理策略的入口函数—freeMemoryIfNeeded" class="headerlink" title="内存管理策略的入口函数—freeMemoryIfNeeded()"></a>内存管理策略的入口函数—freeMemoryIfNeeded()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">     <span class="comment">//在阻塞状态，并且阻塞时间未到，应该是和阻塞状态有关</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">     <span class="comment">// 如果没有超过限制，那么没必要进行内存的清理工作</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (mem_reported &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    <span class="comment">// 排查aof，slaves</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">     <span class="comment">//在进行比较</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//默认情况，不搞了</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i, keys_freed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">          <span class="comment">//如果策略是TTL，设置了过期时间的LRU，LRU</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">     </span><br><span class="line">                <span class="comment">//针对server中的所有db中选出最佳的可以被淘汰的键进行淘汰 </span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="comment">//从EvctionPoolLRU中的最后一个元素(idle值最大）开始释放内存</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line">					<span class="comment">//如果是allkeys开头的删除策略，从dict字典中获取对象; 否则从expire字典中获取对象</span></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="comment">//获取了bestid和de，释放EvctionPoolLRU里面key对应的内存</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="comment">//如果使用random相关的空间管理策略，则直接随机从dict或者expire中获取一个键进行删除</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">             <span class="comment">//每次选不同db的一个元素</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="comment">//最终删除选择的bestkey</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">            <span class="comment">/* We compute the amount of memory freed by db*Delete() alone.</span></span><br><span class="line"><span class="comment">             * It is possible that actually the memory needed to propagate</span></span><br><span class="line"><span class="comment">             * the DEL in AOF and replication link is greater than the one</span></span><br><span class="line"><span class="comment">             * we are freeing removing the key, but we can't account for</span></span><br><span class="line"><span class="comment">             * that otherwise we would never exit the loop.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * AOF and Output buffer memory will be freed eventually so</span></span><br><span class="line"><span class="comment">             * we only care about memory used by the key space. */</span></span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            latencyRemoveNestedEvent(latency,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the memory to free starts to be big enough, we may</span></span><br><span class="line"><span class="comment">             * start spending so much time here that is impossible to</span></span><br><span class="line"><span class="comment">             * deliver data to the slaves fast enough, so we force the</span></span><br><span class="line"><span class="comment">             * transmission here inside the loop. */</span></span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally our stop condition is the ability to release</span></span><br><span class="line"><span class="comment">             * a fixed, pre-computed amount of memory. However when we</span></span><br><span class="line"><span class="comment">             * are deleting objects in another thread, it's better to</span></span><br><span class="line"><span class="comment">             * check, from time to time, if we already reached our target</span></span><br><span class="line"><span class="comment">             * memory, since the "mem_freed" amount is computed only</span></span><br><span class="line"><span class="comment">             * across the dbAsyncDelete() call, while the thread can</span></span><br><span class="line"><span class="comment">             * release the memory all the time. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">                mem_used = zmalloc_used_memory();</span><br><span class="line">                mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) &#123;</span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keys_freed) &#123;</span><br><span class="line">            latencyEndMonitor(latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((mem_reported - zmalloc_used_memory()) + mem_freed) &gt;= mem_tofree)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        usleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后续优化方向"><a href="#后续优化方向" class="headerlink" title="后续优化方向"></a>后续优化方向</h3><ol>
<li>淘汰算法的优化，更有效的需要淘汰的key</li>
<li>算法对性能，内存的影响</li>
</ol>
<h2 id="过期key删除策略"><a href="#过期key删除策略" class="headerlink" title="过期key删除策略"></a>过期key删除策略</h2><h3 id="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"><a href="#惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；" class="headerlink" title="惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；"></a>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，那就返回该键；</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key); <span class="comment">//获取过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">     <span class="comment">//执行lua脚本，先阻塞</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">     <span class="comment">//主从同步，从不删除，只删除主节点，从节点同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">//没过期</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">//过期数量++	</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">//失效记录，aof记录等</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);  <span class="comment">//lazy机制</span></span><br><span class="line">    <span class="comment">//发送删除通知从数据库</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//删除方式选择，异步或者同步</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">     <span class="comment">//删除待清理key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">     <span class="comment">//返回数据库字典中包含key的条目指针，并从数据库字典中摘除该条目</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);<span class="comment">//评估代价</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If releasing the object is too much work, let's put it into the</span></span><br><span class="line"><span class="comment">         * lazy free list. */</span></span><br><span class="line">         <span class="comment">//判断大小，是否需要后台删除，大于64的再丢给后台线程bio后台处理</span></span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD) &#123;</span><br><span class="line">            </span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);<span class="comment">//待处理对象增加1</span></span><br><span class="line">            </span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//丢给bio后台子线程弄</span></span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="comment">//集群模式下</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">redis.conf </span><br><span class="line">lazyfree-lazy-eviction no  <span class="comment">//内存满  freeMemoryIfNeeded</span></span><br><span class="line">lazyfree-lazy-expire no  <span class="comment">//过期     expireIfNeeded</span></span><br><span class="line">lazyfree-lazy-server-del no  <span class="comment">//del命令  dbDelete</span></span><br><span class="line">slave-lazy-flush no   <span class="comment">//slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己的数据场景   readSyncBulkPayload</span></span><br></pre></td></tr></table></figure>
<p><strong>lazyfree机制  删除大数据的键值，导致redis阻塞，4.0引入的，将删除键或数据库的操作放在后台线程里执行， 从而尽可能地避免服务器阻塞。</strong></p>
<h4 id="redis-思考"><a href="#redis-思考" class="headerlink" title="redis 思考"></a>redis 思考</h4><ol>
<li>redis4.0引入的命令 unlink（unlinkCommand）</li>
<li>FLUSHALL/FLUSHDB ASYNC  线上禁用</li>
<li>Lazy 应该全开</li>
</ol>
<h3 id="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长"><a href="#定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。-如何确定频率时长" class="headerlink" title="定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长"></a>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于删除多少过期键，以及要检查多少个数据库，则由算法决定。 如何确定频率时长</h3><ol>
<li>databasesCron -&gt;  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_SLOW);分多次<br>遍历各个数据库，从expires字典中随机检查一部分过期键的过期时间，删除其中的过期键</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_SLOW 0</span></span><br><span class="line"><span class="number">1000000</span>*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/<span class="number">100</span>;  </span><br><span class="line"><span class="comment">//server.hz  10 默认值，conf，serverCron任务的执行周期执行周期，空闲每秒执行10次，清理时间最大为25ms</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACTIVE_EXPIRE_CYCLE_FAST 1   <span class="comment">//1000微秒</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = ACTIVE_EXPIRE_CYCLE_FAST_DURATION; <span class="comment">/* in microseconds. */</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (num &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP)</span><br><span class="line">                num = ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (num--) &#123;</span><br><span class="line">                dictEntry *de;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line">               <span class="comment">//随机取，过期删除</span></span><br><span class="line">                <span class="keyword">if</span> ((de = dictGetRandomKey(db-&gt;expires)) == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">                ttl = dictGetSignedIntegerVal(de)-now;</span><br><span class="line">                <span class="keyword">if</span> (activeExpireCycleTryExpire(db,de,now)) expired++;</span><br><span class="line">                </span><br><span class="line"><span class="keyword">while</span> (expired &gt; ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP/<span class="number">4</span><span class="comment">//删除5个就遍历下一个db</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>事件处理函数aeMain    beforeSleep  activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</li>
<li>访问key 判断lookupKeyRead，过期删除</li>
</ol>
<h2 id="持久化rdb-aof"><a href="#持久化rdb-aof" class="headerlink" title="持久化rdb/aof"></a>持久化rdb/aof</h2><h3 id="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"><a href="#rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态" class="headerlink" title="rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态"></a>rdbrdb程序就是将内存中的数据库的数据结构以rdb文件形式保存到磁盘；在redis重启时，rdb程序就通过载入rdb文件来还原重启前的数据库状态</h3><ol>
<li>RDB文件创建两个命令可以生成RDB文件：SAVE和BGSAVE。</li>
</ol>
<p><img src="/2018/11/09/Redis4源码阅读学习-1/2.png" alt="Image text"><br>   SAVE命令会阻塞redis的服务器进程，直到RDB文件创建完毕为止。在阻塞过程中，server不能处理任何请求    saveCommand-&gt;rdbSave-&gt;rdbSaveRio-&gt;rdbSaveKeyValuePair<br>   REDIS // RDB协议约束的固定字符串<br>   0006 // redis的版本<br>   FE 00 // 表示当前接下来的key都是db=0中的key;<br>   FC 1506327609 // 表示key失效时间点为1506327609<br>   0 // 表示key的属性是string类型<br>   username // key<br>   afei // value<br>   FF // 表示遍历完成<br>   y73e9iq1 // checksum  , CRC64</p>
<p>   <img src="/2018/11/09/Redis4源码阅读学习-1/3.jpeg" alt="Image text"><br>   BGSAVE则会fork出一个子进程，然后子进程负责RDB文件的创建，父进程继续处理请求。<br>   fork()系统调用我们可以创建一个和当前进程一样的新进程，继承了父进程的整个地址空间,其中包括了进程上下文,堆栈地址,内存信息进程控制块<br>   bgsaveCommand-&gt;rdbSaveBackground-&gt; rdbSave<br>   <a href="https://blog.codingnow.com/2011/01/fork_multi_thread.html" target="_blank" rel="noopener">fork危害，多进程的多线程程序</a><br>   自动执行bgsave，配置redis.conf  </p>
<h1 id="save-“”"><a href="#save-“”" class="headerlink" title="save “”"></a>save “”</h1><p>   save 900 1<br>   save 300 10<br>   save 60 10000<br>   只要这三个条件中的任意一条符合，那么服务器就会执行BGSAVE。配置保存在 redisServer saveparam中，serverCron中判断执行<br>   rdb加载，loadDataFromDisk -&gt; rdbLoad（），阻塞</p>
<ol start="2">
<li><p>aof记录服务器所处理的所有的除查询意外的操作，以文本的方式记录<br>原理是：处理文件事件执行写命令，使得命令被追加到aof_buf中，，然后在处理时间事件执行serverCron函数会调用flushAppendOnlyFile函数进行文件的写入和同步。<br> appendonly yes<br> appendfilename “appendonly.aof”<br> appendfsync everysec<br> always：将aof_buf中的所有内容写入并同步到aof文件。<br> everysec：将aof_buf中的所有内容写入到aof文件，如果上次同步的时间距离现在超过1s，那么对aof文件进行同步，同步操作由一个线程专门负责执行<br> no：将aof_buf中的所有内容写入到aof文件，但不对aof文件同步，同步有操作系统执行。</p>
<p> aof流程主要函数：<br> //函数1：将command写入aof_buff  propagate-&gt; feedAppendOnlyFile，数据修改更新到AOF缓存中<br> //函数2：启动子进程，后台用于整理aof的数据 serverCron-&gt; rewriteAppendOnlyFileBackground<br> //函数3：刷一遍server.db[16],依次将对象写入磁盘临时文件tmpfile，rewriteAppendOnlyFile -&gt;rewriteAppendOnlyFileRio<br> //函数4：将aof_buff内容持久化flushAppendOnlyFile<br> //函数5：将backgroundRewriteDoneHandler 更新子进程同步期间产生的修改</p>
<p><img src="https://img-blog.csdn.net/20160503161237360" alt="Image text">   </p>
<p> aof_rewrite 解决AOF文件体积膨胀的问题<br> 触发条件  </p>
<ol>
<li>被动： 当AOF文件尺寸超过conf：auto-aof-rewrite-min-size 64mb &amp; 达到一定增长比，<br>指当前aof文件比上次重写的增长比例大小 auto-aof-rewrite-percentage 100； </li>
<li>主动： 调用BGREWRITEAOF命令；<br><img src="https://img-blog.csdn.net/20160503161309698" alt="Image text"><br>对应bgrewriteaofCommand逻辑  </li>
</ol>
</li>
<li><p>混合持久化 conf aof-use-rdb-preamble no， aof rewrite 的时候就直接把 rdb 的内容写到 aof 文件开头     </p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |          RDB           |   </span><br><span class="line">            |         FORMAT         |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            |                        |   </span><br><span class="line">            +------------------------+</span><br><span class="line">            |                        |   </span><br><span class="line">            |        AOF             |   </span><br><span class="line">            |       FORMAT           |   </span><br><span class="line">            +------------------------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (server.aof_use_rdb_preamble) &#123;</span><br><span class="line">       <span class="keyword">int</span> error;</span><br><span class="line">       <span class="keyword">if</span> (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,<span class="literal">NULL</span>) == C_ERR) &#123;</span><br><span class="line">           errno = error;</span><br><span class="line">           <span class="keyword">goto</span> werr;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) <span class="keyword">goto</span> werr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>rdb优缺点：二进制文件，速度快，存在数据丢失，性能消耗低<br>aof优缺点：数据丢失小，性能消耗大，4.0管道优化相对好些<br>混合持久化：加载速度快，避免丢失数据</p>
<h3 id="事故案例：陌陌争霸"><a href="#事故案例：陌陌争霸" class="headerlink" title="事故案例：陌陌争霸"></a>事故案例：陌陌争霸</h3><p>32 个数据仓库部署到 4 台物理机上即可，每台机器上启动 8 个 Redis 进程。使用 64G 内存的机器，后来增加到了 96G 内存。实测每个 Redis 服务会占到 4~5 G 内存，四台配置相同的从主机进行主从备份。  </p>
<p>事故1：有一台数据服务主机无法被游戏服务器访问到，影响了部分用户登陆，运维维护时发现，一台从机的内存耗尽，导致了从机的数据库服务重启。在从机重新对主机连接，8 个 Redis 同时发送 SYNC 的冲击下，把主机击毁了。<br>问题1：从主机为什么出现内存不足<br>原因：redis 服务同时做 BGSAVE，概率性 ，而导致 fork 多个进程需要消耗太多内存<br>问题2：重新进行 SYNC 操作会导致主机过载<br>原因：重启后，8 个 slave redis 同时开启同步，等于瞬间在主机上 fork 出 8 个 redis 进程<br>解决方案：取消主从，脚本控制bgsave</p>
<p>事故2:内存内存不足<br>原因：定期备份redis数据库文件，拷贝数据库文件时，系统使用大量的内存做为cache，释放不及时，脚本控制bgsave，内存不住，使用交换分区，脚本保证30分钟内必须执行一次bgsave</p>
<p>思考：1.备份方案的选择。2.使用leveldb做redis的持久化存储 3.redis内存上限设置一半  </p>
<h1 id="hyperloglog-c"><a href="#hyperloglog-c" class="headerlink" title="hyperloglog.c"></a>hyperloglog.c</h1><h2 id="在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"><a href="#在-Redis-里面，每个-HyperLogLog-键只需要花费-12-KB-内存，就可以计算接近-2-64-个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身" class="headerlink" title="在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身"></a>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。HyperLogLog只会根据输入元素来计算基数，而不会储存输入元素本身</h2><p>##看到第一句话就知道这个已经完全没有了解的必要了，逆天的算法，用于比如ip访问数的基数统计。</p>
<h2 id="动态字符串-sds-h和sds-c"><a href="#动态字符串-sds-h和sds-c" class="headerlink" title="+ 动态字符串 sds.h和sds.c"></a>+ 动态字符串 sds.h和sds.c</h2><h2 id="双端链表-adlist-c和adlist-h"><a href="#双端链表-adlist-c和adlist-h" class="headerlink" title="+ 双端链表 adlist.c和adlist.h"></a>+ 双端链表 adlist.c和adlist.h</h2><h2 id="字典-dict-h和dict-c"><a href="#字典-dict-h和dict-c" class="headerlink" title="+ 字典 dict.h和dict.c"></a>+ 字典 dict.h和dict.c</h2><h2 id="跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。"><a href="#跳跃表-server-h文件里面关于zskiplist结构和zskiplistNode结构，以及t-zset-c中所有zsl开头的函数，比如-zslCreate、zslInsert、zslDeleteNode等等。" class="headerlink" title="+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。"></a>+ 跳跃表 server.h文件里面关于zskiplist结构和zskiplistNode结构，以及t_zset.c中所有zsl开头的函数，比如 zslCreate、zslInsert、zslDeleteNode等等。</h2><h2 id="intset-c和intset-h"><a href="#intset-c和intset-h" class="headerlink" title="+intset.c和intset.h"></a>+intset.c和intset.h</h2><ol>
<li>intset 是一种有序的整型集合，共有 <code>INTSET_ENC_INT16</code>、<code>INTSET_ENC_INT32</code>、<code>INTSET_ENC_INT64</code> 编码类型。</li>
<li>intset <code>length</code> 属性记了录集合的大小。</li>
<li>intset 内部采用<code>二分查找算法</code> 定位元素。</li>
<li>intset 只会升级，不会降级。当将一个高位元素添加到低编码集合时，此时，需要对集合进行升级。</li>
</ol>
<h2 id="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"><a href="#这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。" class="headerlink" title="这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。"></a>这几个百度一下基本上能理解实现原理，唯一的用途估计也就是面试的时候拿来测试为难或者测试一下面试者的底线。</h2><h2 id="ziplist-c和ziplist-h"><a href="#ziplist-c和ziplist-h" class="headerlink" title="ziplist.c和ziplist.h"></a>ziplist.c和ziplist.h</h2><ol>
<li>实在是不想看实现了，估计也看不懂，看名字就知道是一种极节内存内存的链表，redis是内存性数据库，肯定还是要能省则省，代码肯定是有的，肯定是性能稍微差一点，但是应该差的不多，大神撸出来的东西是不用有任何怀疑的。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/09/DDoS防护的方案和演进/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/DDoS防护的方案和演进/" itemprop="url">DDoS防护的方案和演进</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-09T18:02:37+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>国内某一线公司的DDoS防护方案迭代    </p>
</blockquote>
<blockquote>
<p>单点故障</p>
<p>单点资源瓶颈</p>
<p>主要解决办法：程序识别或运营通过调度DNS来解决</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/1.png" alt></p>
<blockquote>
<p>LVS+KEEPALIVED+JLB</p>
<p>高效率</p>
<p>易部署</p>
<p>易管理</p>
<p>能充分利用机房资源（所有计算机、以及所有带宽资源）</p>
<p>上行带宽瓶颈</p>
<p>数据报文转发瓶颈</p>
<p>无抵御攻击能力</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/2.png" alt></p>
<blockquote>
<p>架构图：DPVS+Firewall+keepalived+JLB</p>
<p>增加了抵御L4攻击的能力</p>
<p>增加了数据包的转发能力</p>
<p>引入问题：</p>
<p>开发、调试、部署相对麻烦</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/3.png" alt></p>
<blockquote>
<p>架构图：ECMP+DPVS+Firewall+JLB</p>
<p>解决了上行瓶颈问题</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/4.png" alt></p>
<blockquote>
<p>WAN/LAN Anycast +ECMP+Firewall&amp;LoadBalancer（XDP+eBPF）</p>
<p>机房整体资源充分利用，整体上无明显的缺点</p>
<p>需要开发很多周边控制程序</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/5.png" alt></p>
<blockquote>
<p>WAN/LAN Anycast +ECMP+Firewall（XDP+eBPF）</p>
<p>机房整体资源利用</p>
<p>避免引入了故障点（LB，firewall）</p>
<p>需要开发很多周边控制程序</p>
</blockquote>
<p><img src="/2018/10/09/DDoS防护的方案和演进/6.png" alt></p>
<blockquote>
<p>个人感受：从框架的迭代进化来看，其实没有什么技术上的难点，用一句很简单的话来说就是，所以99%的计算机问题都可以通过加入一个中间层来解决，和今天的大公司的移动端，后端框架一样，无非是变的的越来越重，越来越层，把问题细分化来解决。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/01/ssl-pinning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/ssl-pinning/" itemprop="url">ssl pinning</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-01T08:59:58+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安全/" itemprop="url" rel="index">
                    <span itemprop="name">安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ssl-pinning-mode"><a href="#ssl-pinning-mode" class="headerlink" title="ssl pinning mode"></a>ssl pinning mode</h1><p>https抓包的问题，工作的一个小争论引发的，不相信https可以抓包分析数据，非要我演示一次。https抓包其实早就已经烂大街，本着用事实说话的方式，安装了Charles，发现竟然有部分如淘宝，支付宝的包无法解析，jd的是正常的，好奇的查了一下，才知道现在有ssl pinning mode这个东西。</p>
<h2 id="简述一下https的连接过程"><a href="#简述一下https的连接过程" class="headerlink" title="简述一下https的连接过程"></a>简述一下https的连接过程</h2><p><img src="/2017/10/01/ssl-pinning/1.gif" alt></p>
<h3 id="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"><a href="#上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。" class="headerlink" title="上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。"></a>上图中实线部分是必须的，虚线部分是可选的。该流程完成了两个任务：服务器身份的验证、加密传输对称加密密钥。</h3><p>1、client hello和 server hello表示双方要建立一个加密会话。</p>
<p>2、服务器把数字证书传输给客户端，证书中包含服务器公钥，客户端用公钥解析证书中的数字签名，可以验证服务器的身份。</p>
<p>3、Server Hello Done表示hello 流程结束。</p>
<p>4、客户端生成一个对称加密密钥，用于实际数据的加密传输，并用服务器的公钥加密，把对生成的密钥传递给服务器。同时携带一个用刚刚生成的加密密钥加密的“client finished”。</p>
<p>5、服务器收到对称加密密钥，并尝试用该密钥解密加密字段，如能得到明文“client finished”，认为该密钥有效，可以用于之后的数据加密传输。同时用该密钥加密“server finished”，传递给客户端。</p>
<p>6、客户端用对称机密密钥解密，如能得到明文“server finished”，客户端认为该服务器已经正确的接收到对称密钥。</p>
<p>7、加密数据传输开始。</p>
<blockquote>
<p>虚线部分是服务器端要求验证客户身份,和双向认证有关。</p>
</blockquote>
<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ol>
<li>内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。 </li>
<li>身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持 </li>
<li>数据完整性。防止内容被第三方冒充或者篡改。</li>
</ol>
<h3 id="带来的问题：中间人攻击（MITM）"><a href="#带来的问题：中间人攻击（MITM）" class="headerlink" title="带来的问题：中间人攻击（MITM）"></a>带来的问题：中间人攻击（MITM）</h3><p><img src="/2017/10/01/ssl-pinning/2.jpeg" alt></p>
<ol>
<li>客户端首先要向远程的服务器发送建立连接的请求，并带有自己的支持的加解密的方式级别，这个过程经过了中间人的窃听，中间人把消息修改后发给了真正的目的地——服务端</li>
<li>服务端收到了要建立https链接的请求后，会发送当时从证书签发机构签发的公钥证书。这个过程中中间人又窃听了，然后中间人替换上自己的证书后又转发给了客户端。</li>
<li>客户端收到了中间人发过来的公钥证书，验证证书的真伪，并产生随机的对称加密的密钥，用中间人发的公钥加密后发给了中间人。由于刚才客户端收到的公钥证书本身就是中间人产生的，所以中间人用相应的私钥就解开了，拿到了客户端产生的那个随机产生的对称加密密钥。中间人再用刚才服务端返回的公钥证书加密这个客户端产生的用来对称加密的密钥，发给服务端。</li>
<li>服务端收到了当时用自己下发的公钥的证书加密的对称加密密钥，用自己的私钥解密，也得到了对称加密的密钥。</li>
</ol>
<blockquote>
<p>用Charles来搞是比较常见的，网上的教程也是一把一把的，大部分https的数据包都的可以解析出来，但是阿里系的不行。</p>
</blockquote>
<h3 id="解决中间人攻击的办法：ssl-pinning-mode"><a href="#解决中间人攻击的办法：ssl-pinning-mode" class="headerlink" title="解决中间人攻击的办法：ssl pinning mode"></a>解决中间人攻击的办法：ssl pinning mode</h3><ol>
<li>简单点说就是：ssl pinning就是client能够把server的证书和一个已知的server的证书的拷贝做对比，通过把server的ssl 证书捆绑到程序中就可以达到目的</li>
<li>如果还是想获取接口请求参数估计只能从客户端逆向入手了，类似于iOS上的Snoop-it一类的工具，网上实际上也有很完整的解决方案了，实际上就是hook的方式将此次校验的结果返回true或者干脆不让其做校验，前提是手机一定要越狱，开源<a href="https://github.com/nabla-c0d3/ssl-kill-switch2" target="_blank" rel="noopener">方案地址</a>，具体原理可以<a href="https://nabla-c0d3.github.io/blog/2016/02/21/ssl-kill-switch-twitter/" target="_blank" rel="noopener">参考</a>。</li>
<li>其实做到https+强制pinning就很少有人搞的动了，还担心就加上双向认证，关键还有就是客户端的代码质量。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/08/01/Android-Facede/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/01/Android-Facede/" itemprop="url">Android Facede</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-01T08:59:58+08:00">
                2016-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android外观模式的应用"><a href="#Android外观模式的应用" class="headerlink" title="Android外观模式的应用"></a>Android外观模式的应用</h1><pre><code>这是一个`app`最初的项目结构  
</code></pre><p><img src="/2016/08/01/Android-Facede/1.png" alt></p>
<p>所有的页面都放在<code>activities</code>，自定义<code>view</code>放在<code>widget</code>，网络相关的封装在<code>network</code>，所有工具类放在<code>utils</code>，少数的<code>xxxManager</code>单例藏在某个包下面，因为少没必要过度提炼就这样吧…<br>没什么问题，项目上线！  </p>
<p>随着项目迭代，越来越多的页面来了，数据库的表也多起来了，工具类更是爆炸性增长，还不排除有些工具类还在<code>activity</code>里面没来得及提炼出来，<code>xxxManager</code>散落一地，<code>callback</code>到处都是…各个包的类都在快速增长</p>
<p>如果用线来表示相互间的调用，那么整个项目就是一个毛线团，找代码都开始难找了<br>那么这时候就改理一理这个线团了</p>
<p>之前app没有一个明确的职责分层，横向依赖很严重，小改伤筋动骨</p>
<h5 id="AppContext与外观模式的应用"><a href="#AppContext与外观模式的应用" class="headerlink" title="AppContext与外观模式的应用"></a>AppContext与外观模式的应用</h5><p>随着业务的发展，<code>app</code>里面的组件，业务线也会逐渐的增多。<br>每个业务线一个<code>module</code>，那么新的问题就来了，<code>module</code>之间的通信问题，横向依赖问题。  </p>
<p>每个<code>module</code>除了在自己的地盘处理业务，还有可能给其他module提供服务，或者这个<code>module</code>就是一个<code>plugin</code>风格的业务组件。<br>比较粗暴的做法，直接引用<code>module</code>，想调谁就引用谁，那么这和之前单<code>module</code>，类的横向引用又有什么本质上的区别呢？<br>这里我们可以借鉴下<code>Android</code>的<code>Context</code>类的设计，<code>Context</code>就是封装了一大堆<code>Android</code>的子系统（通过<code>getSystemService</code>获取），处理在Android环境下的通信问题。<br>那么我们可以依葫芦画瓢的设计一个我们自己的<code>AppContext</code>，我们的业务<code>module</code>或者组件都是在<code>AppContext</code>环境下，他们之间的通信就通过<code>AppContext</code>，具体业务就交给具体的<code>modul</code>e实现.<br>如果设计多个业务<code>module</code>的协作，那么也应该由<code>AppContext</code>屏蔽协作的细节，这是一个很典型的外观模式的应用。<br>在面向对象编程范式内，很多问题都可以通过引入额外的一层来解决<br><img src="/2016/08/01/Android-Facede/2.png" alt>  </p>
<p>有些基础组件<code>module</code>或通用性非常高的<code>module</code>，可以下沉到<code>AppContext</code>下面</p>
<p><code>AppContext</code>的核心职责就是封装好<code>app</code>所用到的子系统（审视下以前代码里面的单例<code>manager</code>，思考一下他是不是能作为<code>app</code>的一个子系统工作）来统一管理服务，无论该服务是基于<code>Android</code>，还是业务<code>module</code>，还是其他第三方组件。当然这里也应该<code>module</code>与<code>app</code>通信，一些app级别的配置也可以在这里处理</p>
<p>在实际操作中，一定要渐进式的处理，主要是因为：</p>
<ul>
<li>互联网时代不能让飞机停下来，做到在天上就给飞机动了手术</li>
<li>可以逐渐验证自己的方案，不要一开始就置自己于险境</li>
</ul>
<blockquote>
<p>比如目前工程中moduleA直接依赖moduleB调用接口，重构过程中不必直接取消依赖（不要影响目前的业务），在AppContext中添加一个moduleB的service，这个service代理moduleB提供的接口服务，然后moduleA调用接口逐渐的转向AppContext提供的方式，当转得差不多的时候就断掉moduleA与moduleB之间的依赖。</p>
</blockquote>
<p>对于有些业务线的<code>module</code>，完全可以把他当做一个app来对待  </p>
<p><img src="/2016/08/01/Android-Facede/3.png" alt>  </p>
<h5 id="AppContext只是解决了module之间的通信或者是子系统的管理"><a href="#AppContext只是解决了module之间的通信或者是子系统的管理" class="headerlink" title="AppContext只是解决了module之间的通信或者是子系统的管理"></a>AppContext只是解决了module之间的通信或者是子系统的管理</h5><blockquote>
<p>由多收缩到一的问题（统一依赖AppContext），只限于单进程，还没有跨进程，跨app，关于跨进程local，remote的问题，另开一贴讲设计思路与实现</p>
</blockquote>
<p>一个<code>App</code>除了通信，还有一些工具类，一些的<code>style</code>，<code>theme</code>，<code>resource</code>相关的定义。  </p>
<p>很多<code>app</code>都会搞一个类似<code>core</code>，<code>common</code>的<code>module</code>，一股脑儿的扔里面，这玩意儿到后面绝对是一锅东北菜，乱炖的感觉。  </p>
<p>对于<code>module</code>层级下面的<code>util</code>，只能是高度通用的<code>util</code>才放到下面，命名一定要体现其具体功能，千万不要直接<code>utils</code>，<code>StringUtils</code>等很模糊的命名，推荐<code>Logger</code>，<code>DeviceUtil</code>，<code>UrlUtil</code>等一眼就能看出其具体功能的<code>util</code>。  </p>
<p>对于<code>resource</code>相关的定义，单独一个<code>module</code><br>这些<code>module</code>都会逐渐沉淀下来，以后<code>app</code>按需依赖.<br><img src="/2016/08/01/Android-Facede/4.png" alt><br>黑线一下的就是业务线开发的基础，是不是有点类似<code>android.jar</code>的感觉</p>
<h4 id="UserCase"><a href="#UserCase" class="headerlink" title="UserCase"></a>UserCase</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">人之所以聪明，是因为人会创造工具并使用</span><br><span class="line"></span><br><span class="line">重构的基础是人员，如何照顾开发的情绪，如何渐进式的进行重构，</span><br><span class="line">如何借助工具进行重构，重构不等于重写，重构不等于业务都给我停下让路</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/04/08/libco/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/08/libco/" itemprop="url">libco</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-08T22:39:02+08:00">
                2016-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方源码库/" itemprop="url" rel="index">
                    <span itemprop="name">第三方源码库</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="co-create-初始化相关"><a href="#co-create-初始化相关" class="headerlink" title="co_create  初始化相关"></a>co_create  初始化相关</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int co_create( stCoRoutine_t **ppco,const stCoRoutineAttr_t *attr,</span><br><span class="line">			   pfn_co_routine_t pfn,void *arg )</span><br><span class="line"></span><br><span class="line">static stCoRoutineEnv_t* g_arrCoEnvPerThread[ 204800 ] = &#123; 0 &#125;;</span><br><span class="line"></span><br><span class="line">void co_init_curr_thread_env()</span><br></pre></td></tr></table></figure>
<ol>
<li><p>将Env_t信息保存在全局变量g_arrCoEnvPerThread中对应于threadId的位置</p>
</li>
<li><p>创建一个空协程，被设置为当前Env_t的main routine，用于运行该线程的主逻辑</p>
</li>
<li><p>Epoll_t相关的信息初始化，管理时间片相关</p>
</li>
<li><p>stCoRoutine_t 保存每个协程的信息</p>
</li>
</ol>
<ol>
<li><p>co_create_env</p>
<p>创建协程的函数是co_create_env()，每个协程有自己密切相关的结构stCoRoutine_t</p>
</li>
<li><p>支持共享栈</p>
<p>所以共享栈采用的方式就是每次发生协程切换的时候，把实际用到的栈内容stack_bp   stack_sp通过save_stack_buffer来保存到malloc的内存中去，然后调用coctx_swap进行寄存器信息的切换，再把切换进来的新协程之前以相同方式保存的栈数据再拷贝到上面的共享栈空间的对应的内存位置上去(栈指针在coctx_swap已经更新完了，这里只是填补数据的作用，而且每个协程切换前后一直使用相同的共享栈，即使有局部指针也没有问题)，从而大大增加了内存的利用效率。</p>
</li>
</ol>
<h2 id="协程执行"><a href="#协程执行" class="headerlink" title="协程执行"></a>协程执行</h2><p>协程 = 回调 + 栈内存</p>
<p>协程执行实际是协程的切换，包括协程上下文（寄存器状态）的切换，回调执行之后会再次切换回来</p>
<p>如果协程中创建了新的协程，则会有嵌套的协程切换</p>
<p>co_resume</p>
<p>同时创建的协程第一次启动也是使用这个接口，并且在第一次启动的时候会初始化特殊的coctx_t结构，在协程执行结束后，会自动设置cEnd=1，同时将自己yield出去</p>
<p>栈帧stack frame layout：</p>
<p><img src="/2016/04/08/libco/illustration-1.png" alt></p>
<p>调用子函数时，父函数从右到左将函数入栈，最后将返回地址入栈保存后，跳到子函数的地址执行。子函数压栈保存父函数的 %ebp，并将 %ebp 设置为当前 %esp。子函数通过 %ebp + 4 读取参数1，%ebp + 8 读取参数2</p>
<p><img src="/2016/04/08/libco/illustration-2.png" alt></p>
<p>libco程序的第一个协程呢，假如第一个协程yield时，CPU控制权让给谁呢？关于这个问题，我们首先要明白这“第一个”协程是什么。实际上，libco的第一个协程，即执行main函数的协程，是一个特殊的协程。这个协程又可以称作主协程，它负责协调其他协程的调度执行（后文我们会看到，还有网络 </p>
<p>I/O以及定时事件的驱动），它自己则永远不会yield，不会主动让出 </p>
<p>CPU。不让出CPU，不等于说它一直霸占着CPU。我们知道CPU执行权有两种转移途径，一是通过yield让给调用者，其二则是resume启动其他协程运行。</p>
<h4 id="阻塞调用Hook"><a href="#阻塞调用Hook" class="headerlink" title="阻塞调用Hook"></a>阻塞调用Hook</h4><p>通过glibc中dlfcn.h的dlsym和RTLD_NEXT结合起来，从而给标准库函数添加钩子</p>
<p>#define HOOK_SYS_FUNC(name) if( !g_sys_##name##_func ) { g_sys_##name##_func = (name##_pfn_t)dlsym(RTLD_NEXT,#name); }</p>
<p>epoll 基于事件驱动的IO多路复用技术，1. mmap，2. 红黑树，33. rdlist</p>
<p><strong>int</strong> <strong>epoll_create(**</strong>int<strong> </strong>size);**</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</p>
<p>epoll的事件注册函数 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<p>等待事件的产生</p>
<h4 id="协程的事件管理"><a href="#协程的事件管理" class="headerlink" title="协程的事件管理"></a>协程的事件管理</h4><ol>
<li><p>初始化 AllocEpoll</p>
</li>
<li><p>添加监听事件 co_poll</p>
</li>
<li><p>轮询 co_eventloop</p>
</li>
</ol>
<h4 id="感受"><a href="#感受" class="headerlink" title="感受:"></a>感受:</h4><blockquote>
<p>总体代码质量并不是特别好，总感觉为了使用C++而使用C++，甚至有些命名都不是 特别规范，最好理解的协程库还是云风c语言版本的，强力推荐，libco最大的优势就是作为微信内部框架的底层库，在线上也承受了巨大的流量，稳定跑到几千台服务器上，其他的都不重要。</p>
</blockquote>
<p>libco github ：<a href="https://github.com/Tencent/libco" target="_blank" rel="noopener">地址</a></p>
<p>云风 github： <a href="https://github.com/cloudwu/coroutine/" target="_blank" rel="noopener">地址</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/08/09/c-11学习笔记-智能指针/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/09/c-11学习笔记-智能指针/" itemprop="url">c++ 11学习笔记--智能指针</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-09T18:14:25+08:00">
                2014-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>C++ 98的 std::auto_ptr已经被彻底遗弃了，取而代之的是unique_ptr、shared_ptr与weak_ptr。大部分时候我们自己手动申请内存方式内存都是没有问题的，问题是如果程序很大了之后，一个复杂的对象，多次拷贝的代价非常高，很多地方都会使用到，只存在一份拷贝显然是最好的，这个时候对象生命周期的管理就会很复杂，所以c++引入了智能指针。</p>
<p>任何事物都会有两面性。</p>
</blockquote>
<h2 id="Shared-ptr"><a href="#Shared-ptr" class="headerlink" title="Shared_ptr"></a>Shared_ptr</h2><h3 id="摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）"><a href="#摘录于Effective-C-3rd-Edition-Item-17-在-standalone-statements（独立语句）中将-new-出来的-objects（对象）存入-smart-pointers（智能指针）" class="headerlink" title="摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）"></a>摘录于Effective C++, 3rd Edition, Item 17: 在 standalone statements（独立语句）中将 new 出来的 objects（对象）存入 smart pointers（智能指针）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;construct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">    ~Widget() &#123;</span><br><span class="line">        cout &lt;&lt; &quot;destruct Widget!!!&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int priority()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;22222&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void processWidget(int priority,std::shared_ptr&lt;Widget&gt; pw)</span><br><span class="line">&#123;</span><br><span class="line">   cout &lt;&lt; &quot;111111&quot; &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    processWidget(priority(),std::shared_ptr&lt;Widget&gt;(new Widget));</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processWidget运行的过程应该是</p>
<ol>
<li><p>New Widget</p>
</li>
<li><p>shared_ptr constructor</p>
</li>
<li><p>Priority()</p>
</li>
</ol>
<p>我在llvm上测试的结果也是这个执行顺序</p>
<p>也许某些编译器上可能执行的顺序是</p>
<ol>
<li><p>New Widget</p>
</li>
<li><p>Priority() //发生异常</p>
</li>
<li>shared_ptr constructor</li>
</ol>
<p>就有可能有内存泄露</p>
<blockquote>
<p><strong>所以最好的办法还是应该把new widget提到外面来写，所以好的编码习惯很重要。</strong></p>
</blockquote>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BPtr b;</span><br><span class="line">    ~A () &#123;</span><br><span class="line">         cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    APtr a;</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b; // 1</span><br><span class="line">    b-&gt;a = a; // 2</span><br><span class="line">    </span><br><span class="line">     cout &lt;&lt; &quot;over!!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr"><a href="#要解决这个问题就需要引入一个弱引用的智能指针了weak-ptr" class="headerlink" title="要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr"></a>要解决这个问题就需要引入一个弱引用的智能指针了weak_ptr</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class A;</span><br><span class="line">class B;</span><br><span class="line"></span><br><span class="line">typedef std::shared_ptr&lt;A&gt; APtr;</span><br><span class="line">typedef std::shared_ptr&lt;B&gt; BPtr;</span><br><span class="line">typedef std::weak_ptr&lt;A&gt; AWeakPtr;</span><br><span class="line">typedef std::weak_ptr&lt;B&gt; BWeakPtr;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">public:</span><br><span class="line">    BWeakPtr b; // 注意这里</span><br><span class="line">    ~A () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;A released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    AWeakPtr a; // 注意这里</span><br><span class="line">    ~B () &#123;</span><br><span class="line">        cout &lt;&lt; &quot;B released&quot; &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main () &#123;</span><br><span class="line">    APtr a(new A());</span><br><span class="line">    BPtr b(new B());</span><br><span class="line">    </span><br><span class="line">    a-&gt;b = b;</span><br><span class="line">    b-&gt;a = a;</span><br><span class="line">    </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两种指针其实和oc里面的 strong, weak非常相识。</p>
<p> weak_ptr的另外一种用法</p>
<p>使用情景：当类对象被 shared_ptr 管理时，需要在类自己定义的函数里把当前类对象作为参数传给其他函数时，这时需要传递一个 shared_ptr ，否则就不能保持 shared_ptr 管理这个类对象的语义（因为有一个 raw pointer 指向这个类对象，而 shared_ptr 对类对象的这个引用没有计数，很有可能 shared_ptr 已经把类对象资源释放了，而那个调用函数还在使用类对象——显然，这肯定会产生错误）。《摘录：<a href="http://blog.csdn.net/zhongguoren666/article/details/8617436》" target="_blank" rel="noopener">http://blog.csdn.net/zhongguoren666/article/details/8617436》</a></p>
<p>直接看官网的例子吧：</p>
<p>《<a href="http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/memory/enable_shared_from_this》</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">struct Good: std::enable_shared_from_this&lt;Good&gt;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Good&gt; getptr() &#123;</span><br><span class="line">        return shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Bad</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; getptr() &#123;</span><br><span class="line">        return std::shared_ptr&lt;Bad&gt;(this);</span><br><span class="line">    &#125;</span><br><span class="line">    ~Bad() &#123; std::cout &lt;&lt; &quot;Bad::~Bad() called\n&quot;; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class CObj: public std::enable_shared_from_this&lt;CObj&gt; &#123;</span><br><span class="line">    friend class CObjMgr;</span><br><span class="line">protected:</span><br><span class="line">    CObj() &#123;&#125;   // 只有CObjMgr可以创建与删除</span><br><span class="line">    ~CObj()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // Good: the two shared_ptr&apos;s share the same object</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp1(new Good);</span><br><span class="line">    std::shared_ptr&lt;Good&gt; gp2 = gp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;gp2.use_count() = &quot; &lt;&lt; gp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">    </span><br><span class="line">    // Bad, each shared_ptr thinks it&apos;s the only owner of the object</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp1(new Bad);</span><br><span class="line">    std::shared_ptr&lt;Bad&gt; bp2 = bp1-&gt;getptr();</span><br><span class="line">    std::cout &lt;&lt; &quot;bp2.use_count() = &quot; &lt;&lt; bp2.use_count() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125; // UB: double-delete of Bad</span><br></pre></td></tr></table></figure>
<ol>
<li>绝对不能在构造函数中调用shared_from_this()</li>
</ol>
<p>​      因为shared_ptr里面初始化enable_shared_from_this的成员weak_ptr，      这个时候weak_ptr还是空值。</p>
<ol start="2">
<li>为什么内部不能用this指针</li>
</ol>
<p>​      因为我们程序中用shared_ptr来管理指针，如果我们在类的内部传递的过程中用原始指针，这样类内部的引用shared_ptr不会察觉到，因为有可能我们传进去的时候已经被shared_ptr释放掉了</p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><blockquote>
<p>相对就要单纯许多了，unique_ptr“唯一”拥有其所指对象，只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。</p>
</blockquote>
<h3 id="代替普通指针"><a href="#代替普通指针" class="headerlink" title="代替普通指针"></a>代替普通指针</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void foo()  </span><br><span class="line">&#123;//不安全的代码  </span><br><span class="line">    X *px = new X;  </span><br><span class="line">    // do something, exception may occurs  </span><br><span class="line">delete px; // may not go here     </span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">unique_ptr&lt;X&gt; px(new X);</span><br></pre></td></tr></table></figure>
<h3 id="在函数中返回对象"><a href="#在函数中返回对象" class="headerlink" title="在函数中返回对象"></a>在函数中返回对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;X&gt; foo()  </span><br><span class="line">&#123;  </span><br><span class="line">    unique_ptr&lt;X&gt; px(new X);  </span><br><span class="line">    // do something  </span><br><span class="line">    return px; //移动语义  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="放入容器中"><a href="#放入容器中" class="headerlink" title="放入容器中"></a>放入容器中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt; vs &#123; new string&#123;“1111”&#125;, new string&#123;“2222”&#125;，new string&#123;“3333”&#125;  &#125;;  </span><br><span class="line"></span><br><span class="line">vector&lt;unique_ptr&lt;string&gt;&gt;v;  </span><br><span class="line">unique_ptr&lt;string&gt; test(new string(&quot;11111&quot;));  </span><br><span class="line">v.push_back(std::move(test));//使用移动语法</span><br></pre></td></tr></table></figure>
<h3 id="支持直接持有数组"><a href="#支持直接持有数组" class="headerlink" title="支持直接持有数组"></a>支持直接持有数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],</span><br><span class="line">    [](int* p)&#123;</span><br><span class="line">        delete[] p;</span><br><span class="line">    &#125;);</span><br><span class="line">//或者使用helper</span><br><span class="line">std::shared_ptr&lt;int&gt; p(new int[10],std::default_delete&lt;int[]&gt;());</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/08/09/c-11学习笔记-Lambda-表达式（对比测试Lambda-，bind，Function-Object）/" itemprop="url">c++ 11学习笔记--Lambda 表达式（对比测试Lambda ，bind，Function Object）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-08-09T18:02:37+08:00">
                2014-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>所有c++ coder都应该为这个语法感到高兴，说的直白一点，Lambda 表达式就是函数对象的语法糖。</p>
<p>还是直接看对比栗子吧，抄袭的是msdn的官网</p>
<p>该示例使用 for_each 函数调用中嵌入的 lambda 向控制台打印 vector 对象中的每个元素是偶数还是奇数。</p>
</blockquote>
<h3 id="使用lambda"><a href="#使用lambda" class="headerlink" title="使用lambda"></a>使用lambda</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">   // Create a vector object that contains 10 elements.</span><br><span class="line">   vector&lt;int&gt; v;</span><br><span class="line">   for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">      v.push_back(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   // Count the number of even numbers in the vector by </span><br><span class="line">   // using the for_each function and a lambda.</span><br><span class="line">   int evenCount = 0;</span><br><span class="line">   for_each(v.begin(), v.end(),[&amp;evenCount] (int n) &#123;</span><br><span class="line">      cout &lt;&lt; n;</span><br><span class="line">      if (n % 2 == 0) &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">         ++evenCount;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   // Print the count of even numbers to the console.</span><br><span class="line">   cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用Function-Object"><a href="#使用Function-Object" class="headerlink" title="使用Function Object"></a>使用Function Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(int&amp; evenCount) </span><br><span class="line">        : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; n;</span><br><span class="line"></span><br><span class="line">        if (n % 2 == 0) &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is even &quot; &lt;&lt; endl;</span><br><span class="line">            ++m_evenCount;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cout &lt;&lt; &quot; is odd &quot; &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line"></span><br><span class="line">    int&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    // Create a vector object that contains 10 elements.</span><br><span class="line">    vector&lt;int&gt; v;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i) &#123;</span><br><span class="line">        v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Count the number of even numbers in the vector by </span><br><span class="line">    // using the for_each function and a function object.</span><br><span class="line">    int evenCount = 0;</span><br><span class="line">    for_each(v.begin(), v.end(), FunctorClass(evenCount));</span><br><span class="line"></span><br><span class="line">    // Print the count of even numbers to the console.</span><br><span class="line">    cout &lt;&lt; &quot;There are &quot; &lt;&lt; evenCount </span><br><span class="line">        &lt;&lt; &quot; even numbers in the vector.&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>正如微软文档所言，这两种在效率上并没有实质性的差距，我自己也测试了，不管在debug模式下还是release模式下，果然没有差距。</p>
<p>无意中我在晚上发现了bind和Lambda对比测试，前三种方式是网上的，后面两种是我自己加的，结果绝对让我蛋碎了一地。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cstdint&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">#include &lt;boost/function.hpp&gt;</span><br><span class="line">#include &lt;boost/bind.hpp&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class FunctorClass</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    // The required constructor for this example.</span><br><span class="line">    explicit FunctorClass(uint64_t&amp; evenCount)</span><br><span class="line">    : m_evenCount(evenCount)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // The function-call operator prints whether the number is</span><br><span class="line">    // even or odd. If the number is even, this method updates</span><br><span class="line">    // the counter.</span><br><span class="line">    void operator()(int n) const</span><br><span class="line">    &#123;</span><br><span class="line">         m_evenCount += n;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    // Default assignment operator to silence warning C4512.</span><br><span class="line">    FunctorClass&amp; operator=(const FunctorClass&amp;);</span><br><span class="line">    </span><br><span class="line">    uint64_t&amp; m_evenCount; // the number of even variables in the vector.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class timer</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    typedef std::chrono::high_resolution_clock clock;</span><br><span class="line">    typedef clock::time_point                  time_point;</span><br><span class="line">    typedef clock::duration                    duration;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    timer()</span><br><span class="line">    &#123;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void reset()</span><br><span class="line">    &#123;</span><br><span class="line">        _starttime = clock::now();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    duration elapsed() const</span><br><span class="line">    &#123;</span><br><span class="line">        return clock::now() - _starttime;</span><br><span class="line">    &#125;</span><br><span class="line">protected:</span><br><span class="line">    time_point _starttime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bool test_timer()</span><br><span class="line">&#123;</span><br><span class="line">    using std::chrono::milliseconds;</span><br><span class="line">    typedef timer::duration duration;</span><br><span class="line">    </span><br><span class="line">    const milliseconds sleep_time(500);</span><br><span class="line">    </span><br><span class="line">    timer t;</span><br><span class="line">    std::this_thread::sleep_for(sleep_time);</span><br><span class="line">    duration recorded = t.elapsed();</span><br><span class="line">    </span><br><span class="line">    // make sure the clock and this_thread::sleep_for is precise within one millisecond (or at least in agreement as to</span><br><span class="line">    // how inaccurate they are)</span><br><span class="line">    return (recorded - milliseconds(1) &lt; sleep_time)</span><br><span class="line">    &amp;&amp; (recorded + milliseconds(1) &gt; sleep_time);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line">void volatile_write(const T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    volatile T* p = new T;</span><br><span class="line">    *p = x;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void run_test(const std::string&amp; name, Function func)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; name;</span><br><span class="line">    timer t;</span><br><span class="line">    volatile_write(func());</span><br><span class="line">    timer::duration duration = t.elapsed();</span><br><span class="line">    std::cout &lt;&lt; &apos;\t&apos; &lt;&lt; duration.count() &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template &lt;typename Function&gt;</span><br><span class="line">void do_test_loop(Function func, const uint64_t upper_limit = 100000000ULL)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t i;</span><br><span class="line">    for (i = 0; i &lt; upper_limit; ++i)</span><br><span class="line">        func(i);</span><br><span class="line">    if(i == upper_limit)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = [&amp;x] (uint64_t i) &#123; x += i;</span><br><span class="line"> &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void test_accumulate_bind_function(uint64_t&amp; x, uint64_t i)</span><br><span class="line">&#123;</span><br><span class="line">    x += i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    std::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_class_function()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line"></span><br><span class="line">    do_test_loop(FunctorClass(x));</span><br><span class="line">   // for_each(v.begin(), v.end(), FunctorClass(x));</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_bind_auto()</span><br><span class="line">&#123;</span><br><span class="line">    namespace arg = std::placeholders;</span><br><span class="line">    </span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    auto accumulator = std::bind(&amp;test_accumulate_bind_function, std::ref(x), arg::_1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#if USE_BOOST</span><br><span class="line">uint64_t test_accumulate_boost_bind()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    </span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = boost::bind(&amp;test_accumulate_bind_function, boost::ref(x), _1);</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uint64_t test_accumulate_boost_bound_lambda()</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t x = 0;</span><br><span class="line">    boost::function&lt;void (uint64_t)&gt; accumulator = [&amp;x] (uint64_t i) &#123; x += i; &#125;;</span><br><span class="line">    do_test_loop(accumulator);</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    if (!test_timer())</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Failed timer test.&quot; &lt;&lt; std::endl;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run_test(&quot;Accumulate (lambda)            &quot;, &amp;test_accumulate_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (bind)              &quot;, &amp;test_accumulate_bind);</span><br><span class="line">    run_test(&quot;Accumulate (bound lambda)      &quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">    run_test(&quot;Accumulate (Function Object)    &quot;, &amp;test_accumulate_class_function);</span><br><span class="line">    run_test(&quot;Accumulate (bind auto)    &quot;, &amp;test_accumulate_bind_auto);</span><br><span class="line">#if USE_BOOST</span><br><span class="line">    run_test(&quot;Accumulate (boost bind)        &quot;, &amp;test_accumulate_boost_bind);</span><br><span class="line">    run_test(&quot;Accumulate (boost bound lambda)&quot;, &amp;test_accumulate_bound_lambda);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="debug模式："><a href="#debug模式：" class="headerlink" title="debug模式："></a>debug模式：</h3><p><strong>Accumulate (lambda)            100000000  422885105</strong></p>
<p><strong>Accumulate (bind)              100000000   4346676523</strong></p>
<p><strong>Accumulate (bound lambda)      100000000 1707092933</strong></p>
<p><strong>Accumulate (class function)    100000000   494674507</strong></p>
<p><strong>Accumulate (bind auto)         100000000 3381097610</strong></p>
<h3 id="Release模式"><a href="#Release模式" class="headerlink" title="Release模式"></a>Release模式</h3><p><strong>Accumulate (lambda)            100000000  17978</strong></p>
<p><strong>Accumulate (bind)              100000000   607188485</strong></p>
<p><strong>Accumulate (bound lambda)      100000000 520421500</strong></p>
<p><strong>Accumulate (Function Object)    100000000  1925</strong></p>
<p><strong>Accumulate (bind auto)         100000000 1726</strong></p>
<blockquote>
<p>编译器：APPLE LLVM5.1</p>
<p>c++就是这样让人蛋疼，随便一个东西，初学者都可以写5中写法，那大神下，至少可以写10种以上，效率上的差距也是大的惊人，我还是那句话c++应该做减法了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/09/c-11学习笔记-右值引用和移动构造语义/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="三鱼">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三余无梦生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2014/06/09/c-11学习笔记-右值引用和移动构造语义/" itemprop="url">c++ 11学习笔记--右值引用和移动构造语义</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2014-06-09T17:42:12+08:00">
                2014-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"><a href="#今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。" class="headerlink" title="今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。"></a>今天我决定尝试用另外一种方式来表达，任何新语法的的产生都是为了解决某个问题，所以今天先看问题。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">class myStr</span><br><span class="line">&#123;</span><br><span class="line">protected:</span><br><span class="line">    char* str_;</span><br><span class="line">    </span><br><span class="line">public:</span><br><span class="line">    myStr(void)                       // 默认的构造函数，什么也不做</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const char* rhs)            // 普通赋值构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(const myStr&amp; rhs)             // 拷贝构造函数</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!rhs) return;</span><br><span class="line">        str_ = new char[1024];</span><br><span class="line">        strcpy(str_, rhs.str_);</span><br><span class="line">      //  cout &lt;&lt; &quot;Str copy constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr(myStr&amp;&amp; rhs)</span><br><span class="line">    : str_(nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(rhs);</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str move constructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~myStr()                          // 析构函数</span><br><span class="line">    &#123;</span><br><span class="line">        if (!str_) return;</span><br><span class="line">      //  std::cout &lt;&lt; &quot;Str destructor &quot; &lt;&lt; str_ &lt;&lt; std::endl;</span><br><span class="line">        delete [] str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    const myStr&amp; operator=(myStr rhs)   // 赋值操作符重载</span><br><span class="line">    &#123;</span><br><span class="line">        rhs.swap(*this);            // 使用copy-and-swap惯用法获得数据</span><br><span class="line">        return (*this);             // 避免重复撰写operator=</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void swap(myStr&amp; rhs)             // 交换算法</span><br><span class="line">    &#123;</span><br><span class="line">        std::swap(str_, rhs.str_);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    operator char*(void) const</span><br><span class="line">    &#123;</span><br><span class="line">        return str_;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    myStr&amp; operator+=(const char* rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        if (rhs) strcat(str_, rhs);</span><br><span class="line">        return (*this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">//    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行下面的代码"><a href="#执行下面的代码" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">myStr ss(&quot;000&quot;);</span><br><span class="line">    myStr s1(&quot;11111&quot;), s2(&quot;22222&quot;), s3(&quot;3333333&quot;), s4(&quot;4444444&quot;);</span><br><span class="line">    cout &lt;&lt; std::endl;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line">    </span><br><span class="line">    const long long max = 30000000;</span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line"></span><br><span class="line">    for (long long i = 0; i&lt;max; i++) &#123;</span><br><span class="line">        ss = s1 + s2 + s3 + s4;</span><br><span class="line">    &#125;</span><br><span class="line">     time(&amp;timestamp2);</span><br><span class="line">    </span><br><span class="line"> timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure>
<h3 id="下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。"><a href="#下面的代码是唯一不同的实现，但是却带来30-40-的性能差距。" class="headerlink" title="下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。"></a>下面的代码是唯一不同的实现，但是却带来30-40%的性能差距。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">//    &#123;</span><br><span class="line">//        return myStr(x) += y;</span><br><span class="line">//    &#125;</span><br><span class="line">    friend myStr operator+(const myStr&amp; x, const myStr&amp; y)</span><br><span class="line">    &#123;</span><br><span class="line">        return std::move(myStr(x) += y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="再找一个例子"><a href="#再找一个例子" class="headerlink" title="再找一个例子"></a>再找一个例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">class MemoryBlock</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    </span><br><span class="line">    // 构造器（初始化资源）</span><br><span class="line">    explicit MemoryBlock(size_t length)</span><br><span class="line">    : _length(length)</span><br><span class="line">    , _data(new int[length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 析构器（释放资源）</span><br><span class="line">    ~MemoryBlock()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_data != nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            delete[] _data;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; &quot;MemoryBlock destructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝构造器（实现拷贝语义：拷贝that）</span><br><span class="line">    MemoryBlock(const MemoryBlock&amp; that)</span><br><span class="line">    // 拷贝that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(new int[that._length])</span><br><span class="line">    &#123;</span><br><span class="line">        std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        std::cout &lt;&lt; &quot;copy constructor &quot;  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 拷贝赋值运算符（实现拷贝语义：释放this ＋ 拷贝that）</span><br><span class="line">    MemoryBlock&amp; operator=(const MemoryBlock&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 拷贝that对象所拥有的资源</span><br><span class="line">            _length = that._length;</span><br><span class="line">            _data = new int[_length];</span><br><span class="line">            std::copy(that._data, that._data + _length, _data);</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动构造器（实现移动语义：移动that）</span><br><span class="line">    MemoryBlock(MemoryBlock&amp;&amp; that)</span><br><span class="line">    // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">    : _length(that._length)</span><br><span class="line">    , _data(that._data)</span><br><span class="line">    &#123;</span><br><span class="line">        // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">        that._data = nullptr;</span><br><span class="line">        that._length = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 移动赋值运算符（实现移动语义：释放this ＋ 移动that）</span><br><span class="line">    MemoryBlock&amp; operator=(MemoryBlock&amp;&amp; that)</span><br><span class="line">    &#123;</span><br><span class="line">        if (this != &amp;that)</span><br><span class="line">        &#123;</span><br><span class="line">            // 释放自身的资源</span><br><span class="line">            delete[] _data;</span><br><span class="line">            </span><br><span class="line">            // 将自身的资源指针指向that对象所拥有的资源</span><br><span class="line">            _data = that._data;</span><br><span class="line">            _length = that._length;</span><br><span class="line">            </span><br><span class="line">            // 将that对象原本指向该资源的指针设为空值</span><br><span class="line">            that._data = nullptr;</span><br><span class="line">            that._length = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    size_t _length; // 资源的长度</span><br><span class="line">    int* _data; // 指向资源的指针，代表资源本身</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MemoryBlock f() &#123; return MemoryBlock(50); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行下面的代码-1"><a href="#执行下面的代码-1" class="headerlink" title="执行下面的代码"></a>执行下面的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const long long max = 100000;</span><br><span class="line">    time_t timestamp1;</span><br><span class="line">    time_t timestamp2;</span><br><span class="line">    time_t timestamp3;</span><br><span class="line"></span><br><span class="line">    time(&amp;timestamp1);</span><br><span class="line">    for (long long i = 0; i&lt;max; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        MemoryBlock a = MemoryBlock(50);</span><br><span class="line"></span><br><span class="line">        MemoryBlock c = std::move(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    time(&amp;timestamp2);</span><br><span class="line">timestamp3 = timestamp2 - timestamp1;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果把MemoryBlock c = std::move(a)换成MemoryBlock c = a;</p>
<p>性能上大概也有30%的差距。</p>
<p>这就是右值引用和移动构造语义带来的好处，我理解就是以前只能引用左值，而右值是不能引用的，新语法的加入实现了右值的引用，减少了零时对象的产生销毁，但是也带来了更多怪异的语法，明显增加了c++的学习成本，如果语法设计角度，像oc一样增加类似引用计数器来管理对象，会不会更加优雅一下，至少让上层的码农不会那么累，其实通智能指针也能达到同样的效果。</p>
<p>这么多年了c++都在做加法，让学习，使用成本太高了，标准委员为的大爷些什么时候考虑一下做点减法呢，不要让c++那么学院派或者满地都是陷阱，也不要让实现一种技术有10种方法，但是有5种都是陷阱。靠！</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="三鱼">
            
              <p class="site-author-name" itemprop="name">三鱼</p>
              <p class="site-description motion-element" itemprop="description">挥笔点墨卷再开，醉仰观岚景悠哉。倾向兰曰敬邀曰，叹矣自笑一字呆。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xyiot" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:softstarxy@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.weibo.com/5419866199/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">三鱼</span>
  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
